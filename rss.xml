<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>向阳信息</title>
    <link>https://xyxsw.ltd/</link>
    
    <atom:link href="https://xyxsw.ltd/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>若月千鸮的博客&#39;</description>
    <pubDate>Wed, 18 Oct 2023 14:45:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>https://xyxsw.ltd/2023/10/18/java_crud%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link>
      <guid>https://xyxsw.ltd/2023/10/18/java_crud%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid>
      <pubDate>Wed, 18 Oct 2023 14:45:56 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;java-crud环境配置教程&quot;&gt;&lt;a href=&quot;#java-crud环境配置教程&quot; class=&quot;headerlink&quot; title=&quot;java_crud环境配置教程&quot;&gt;&lt;/a&gt;java_crud环境配置教程&lt;/h1&gt;&lt;p&gt;本文会从安装开始，到最后写出一个带命</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="java-crud环境配置教程"><a href="#java-crud环境配置教程" class="headerlink" title="java_crud环境配置教程"></a>java_crud环境配置教程</h1><p>本文会从安装开始，到最后写出一个带命令行交互窗口的CRUD的小项目.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p><a href="https://www.oracle.com/java/technologies/downloads/#jdk17-windows">安装地址</a></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221643.png"></p><p> 建议下载java17以防止有依赖问题</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221712.png"></p><p>点击这个下载<code>.msi</code>安装包来安装</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221734.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221748.png"></p><p>这里建议不要更改<strong>默认位置</strong></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221802.png"></p><p>安装完成🥳</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>在<code>Windows开始菜单</code>搜索<code>环境变量</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221840.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221858.png"></p><p>在系统环境变量下面点击新建</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221915.png"></p><p>变量名设置为 <code>JAVA_HOME</code></p><p>变量值设置为 <code>C:\Program Files\Java\jdk-17.0.4.1</code> 如果你有安装到其他目录请填其他目录</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221927.png"></p><p>新建环境变量 <code>CLASS_PATH</code> </p><p>变量值为 <code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></p><p>如下图所示</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221948.png"></p><p>注意 变量值比较奇怪 可能理解不能  但是要照上填写</p><p>在系统变量里找到<code>path</code> 双击</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222004.png"></p><p>点击新建  值填写</p><p><code>%JAVA_HOME%\bin</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222021.png"></p><p>点击确定</p><p>接下来按 Windows键加R键  输入cmd点确定</p><p>在命令行里输入<code>java --version</code></p><p>如有正常不报错则配置成功🥳</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222038.png"></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p><a href="https://downloads.mysql.com/archives/installer/">MySQL :: Download MySQL Installer (Archived Versions)</a></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222056.png"></p><p>双击打开</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222109.png"></p><p>选default</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222120.png"></p><p>直接next</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222134.png"></p><p>yes</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222149.png"></p><p>Execute</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222201.png"></p><p>一路next</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222212.png"></p><p>设一个密码</p><p>然后一路next</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222223.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222238.png"></p><p>点check</p><p>点next</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222255.png"></p><p>最后会跳出这么一个奇奇怪怪的 MySQL JS 的命令行 （说实话我没懂为什么有这玩意</p><p>（不过你可以在上面玩玩 JS 的特性   ：）</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929230157.png"></p><p>和命令行同时弹出来的是workbench </p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929230229.png"></p><p>MySQL已安装完成🥳</p><h2 id="安装-JetBrain-IntelliJ-IDEA"><a href="#安装-JetBrain-IntelliJ-IDEA" class="headerlink" title="安装 JetBrain IntelliJ IDEA"></a>安装 JetBrain IntelliJ IDEA</h2><p><a href="https://www.jetbrains.com/zh-cn/idea/">下载地址</a></p><p>直接下载咯 0配置的</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929230750.png"></p><p>新建项目</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929230914.png"></p><p>创建配置如图所示</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231039.png"></p><p>点进 <code>src/main/java/org/example/main</code>运行一下试试</p><h2 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231348.png"></p><p>点击编辑配置</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231437.png"></p><p>新建一个Maven配置</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231601.png"></p><p>配置如图 保存应用</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231748.png"></p><p>点击运行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231717.png"></p><p>build成功后会生成一个snapshot的jar</p><p>接下来是安装maven依赖项</p><p>打开pom.xml 右键点生成</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231903.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231942.png"></p><p>搜索 mysql-connector 添加这个8版本的依赖</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929232035.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220930000633.png"></p><p>生成了如图的代码则成功</p><p>在与 dependencies 同级的标签下面 添加如下代码 配置maven依赖自动安装</p><pre><code class="xml"> &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;phase&gt;package&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;single&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;configuration&gt;                    &lt;descriptorRefs&gt;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                    &lt;/descriptorRefs&gt;                    &lt;archive&gt;                        &lt;manifest&gt;                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;                            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;                            &lt;mainClass&gt;org.example.Main&lt;/mainClass&gt;                        &lt;/manifest&gt;                    &lt;/archive&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>点击右上角 <img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929232533.png"> 重新加载maven变更</p><h2 id="加载数据库-创建数据表"><a href="#加载数据库-创建数据表" class="headerlink" title="加载数据库&amp;&amp;创建数据表"></a>加载数据库&amp;&amp;创建数据表</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929232829.png"></p><p>在右边的侧边栏中找到数据库  添加一个MySQL</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233002.png"></p><p>输入你刚设置的账号密码连接</p><p>弹出一个console</p><p>在里面输入</p><pre><code class="sql">CREATE DATABASE `java_crud_demo` CHARACTER SET &#39;utf8mb4&#39; COLLATE &#39;utf8mb4_general_ci&#39;;</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233123.png"></p><p>绿色框内是idea识别出来的sql语句  点击左上绿色箭头执行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233231.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233308.png"></p><p>右侧数据库栏里会出现你刚创建的数据库 但是里面没有表</p><p>在console里输入</p><pre><code class="sql">create table if not exists `java_crud_demo`.`article_table`(    id     int unsigned auto_increment        primary key,    title  varchar(100) not null,    author varchar(40)  not null,    time   datetime     null);</code></pre><p>ctrl + a 全选中 然后点执行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233643.png"></p><p>生成了表article_table 里面没有数据</p><p>简单的填充数据 可以 console输入</p><pre><code class="sql">INSERT INTO `java_crud_demo`.`article_table` (`title`, `author`, `time`)VALUES (&#39;标题&#39;, &#39;作者&#39;, NOW());</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929234014.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929234049.png"></p><p>插入完了记得点这个刷新</p><p>也可以直接在table预览界面</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220930000521.png"></p><p>添加行 输入完毕后 点提交</p><h2 id="数据库crud模板"><a href="#数据库crud模板" class="headerlink" title="数据库crud模板"></a>数据库crud模板</h2><p>新建一个crud.java</p><pre><code class="java">package org.example;import java.sql.*;public class Crud &#123;    // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL    //static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;    //static final String DB_URL = &quot;jdbc:mysql://localhost:3306/java_crud_demo&quot;;    // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL    static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;    static final String DB_URL = &quot;jdbc:mysql://localhost:3306/java_crud_demo?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;;    // 数据库的用户名与密码，需要根据自己的设置    static final String USER = &quot;root&quot;;    static final String PASS = &quot;123456&quot;;    public static void main(String[] args) &#123;        Connection conn = null;        Statement stmt = null;        try&#123;            // 注册 JDBC 驱动            Class.forName(JDBC_DRIVER);            // 打开链接            System.out.println(&quot;连接数据库...&quot;);            conn = DriverManager.getConnection(DB_URL,USER,PASS);            // 执行查询            System.out.println(&quot; 实例化Statement对象...&quot;);            stmt = conn.createStatement();            String sql;            sql = &quot;SELECT id, title, author, time FROM java_crud_demo&quot;;            ResultSet rs = stmt.executeQuery(sql);            // 展开结果集数据库            while(rs.next())&#123;                // 通过字段检索                int id  = rs.getInt(&quot;id&quot;);                String title = rs.getString(&quot;title&quot;);                String author = rs.getString(&quot;author&quot;);                String time = rs.getString(&quot;time&quot;);                // 输出数据                System.out.println(&quot;ID: &quot; + id);                System.out.println(&quot;标题：&quot; + title);                System.out.println(&quot;作者：&quot; + author);                System.out.println(&quot;时间：&quot; + time);            &#125;            // 完成后关闭            rs.close();            stmt.close();            conn.close();        &#125;catch(SQLException se)&#123;            // 处理 JDBC 错误            se.printStackTrace();        &#125;catch(Exception e)&#123;            // 处理 Class.forName 错误            e.printStackTrace();        &#125;finally&#123;            // 关闭资源            try&#123;                if(stmt!=null) stmt.close();            &#125;catch(SQLException se2)&#123;            &#125;// 什么都不做            try&#123;                if(conn!=null) conn.close();            &#125;catch(SQLException se)&#123;                se.printStackTrace();            &#125;        &#125;        System.out.println(&quot;Goodbye!&quot;);    &#125;&#125;</code></pre><p>接下来愉快写你的代码主逻辑咯🥳</p><h2 id="双击打开jar"><a href="#双击打开jar" class="headerlink" title="双击打开jar"></a>双击打开jar</h2><pre><code class="java">package org.example;import java.io.File;public class Main &#123;    public static void main(String[] args) &#123;        if (args.length == 0) &#123;            try &#123;                String path = System.getProperty(&quot;java.class.path&quot;);                int lastIndex = path.lastIndexOf(File.separator) + 1;                String file_name = path.substring(lastIndex);                ProcessBuilder pb = new ProcessBuilder();                pb.directory(new File(&quot;.&quot;));                System.out.printf(&quot;%s %s %s %s %s %s %s&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;start&quot;, &quot;java&quot;, &quot;-jar&quot;, file_name, &quot;eject&quot;);                        pb.command(&quot;cmd&quot;, &quot;/c&quot;, &quot;start&quot;, &quot;java&quot;, &quot;-jar&quot;, file_name, &quot;eject&quot;);                pb.start();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125; finally &#123;                System.exit(0);            &#125;        &#125;        else &#123;            //主函数            System.out.println(&quot;Hello World!&quot;);        &#125;    &#125;    &#125;</code></pre><p>在main开头加上这样一段 他会帮你输入命令来打开一个弹出的新窗口啦🥳</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>Maven 构建之后就得到了需要的jar包了🥳</p>]]></content:encoded>
      
      
      
      
      <comments>https://xyxsw.ltd/2023/10/18/java_crud%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DNS 与 Pdns OpenWrt DNS 递归服务器搭建与 MosDNS 分流</title>
      <link>https://xyxsw.ltd/2023/10/18/DNS%20%E4%B8%8E%20Pdns%20OpenWrt%20DNS%20%E9%80%92%E5%BD%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%20MosDNS%20%E5%88%86%E6%B5%81/</link>
      <guid>https://xyxsw.ltd/2023/10/18/DNS%20%E4%B8%8E%20Pdns%20OpenWrt%20DNS%20%E9%80%92%E5%BD%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%20MosDNS%20%E5%88%86%E6%B5%81/</guid>
      <pubDate>Wed, 18 Oct 2023 14:43:02 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h1&gt;&lt;h2 id=&quot;什么是DNS&quot;&gt;&lt;a href=&quot;#什么是DNS&quot; class=&quot;headerlink&quot; title=&quot;什么是DNS&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h2><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><p>简单来说就是用域名请求服务器换回来ip地址</p><p><a href="https://www.nslookup.io/">https://www.nslookup.io/</a></p><p>这个网站可以看dns请求的结果、同理还有linux或者windows的nslookup命令</p><p><strong>DNS records for dn11.top</strong></p><blockquote><p>A records</p></blockquote><table><thead><tr><th>IPv4 address</th><th>Revalidate in</th></tr></thead><tbody><tr><td>104.21.27.178</td><td>5m</td></tr><tr><td>172.67.143.107</td><td>5m</td></tr></tbody></table><p>DNS 服务器使人们无需存储复杂记不住的ip地址，而是记住有规律的域名来方便的访问互联网</p><h2 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h2><p>DNS 记录是位于权威 DNS 服务器中的指令，提供一个域的相关信息，包括哪些 IP 地址与该域关联，以及如何处理对该域的请求。</p><h3 id="常见的-DNS-记录"><a href="#常见的-DNS-记录" class="headerlink" title="常见的 DNS 记录"></a>常见的 DNS 记录</h3><p>SOA 记录 - 存储域的管理信息。</p><pre><code class="bash">;; ANSWER SECTION:dn11.top.               1800    IN      SOA     ophelia.ns.cloudflare.com. dns.cloudflare.com. 2322082117 10000 2400 604800 1800</code></pre><p>NS 记录 - 存储 DNS 条目的名称服务器。</p><pre><code class="bash">;; ANSWER SECTION:dn11.top.               21600   IN      NS      ophelia.ns.cloudflare.com.dn11.top.               21600   IN      NS      phil.ns.cloudflare.com.</code></pre><p>A 记录 - 保存域的 IPv4 地址的记录。</p><pre><code class="bash">;; ANSWER SECTION:dn11.top.               300     IN      A       104.21.27.178dn11.top.               300     IN      A       172.67.143.107</code></pre><p>AAAA 记录 - 包含域的 IPv6 地址的记录（与 A 记录相反，A 记录列出的是 IPv4 地址）。</p><p>CNAME 记录 - 将一个域或子域转发到另一个域，不提供 IP 地址。</p><p>MX 记录 - 将邮件定向到电子邮件服务器。</p><p>TXT 记录 - 可让管理员在记录中存储文本注释。这些记录通常用于电子邮件安全。</p><h2 id="有几种DNS服务器？有几种工作方式？"><a href="#有几种DNS服务器？有几种工作方式？" class="headerlink" title="有几种DNS服务器？有几种工作方式？"></a>有几种DNS服务器？有几种工作方式？</h2><p>有两种DNS服务器：DNS递归服务器和DNS权威服务器</p><p>有两种工作方式：递归和迭代</p><p>DNS客户端设置使用的DNS服务器一般都是DNS递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。</p><h2 id="如何工作的"><a href="#如何工作的" class="headerlink" title="如何工作的"></a>如何工作的</h2><p>DNS查询 涉及 4 个 DNS 服务器：</p><ol><li>DNS 递归解析器</li></ol><p>DNS 解析器是一种服务器，旨在通过 Web 浏览器等应用程序接收客户端计算机的查询。然后，解析器一<strong>般负责发出其他请求</strong>，以便满足客户端的 DNS 查询。</p><blockquote><p>常见的 dns 递归解析器有</p><p>谷歌 8.8.8.8  8.8.4.4</p><p>阿里 223.5.5.5 223.6.6.6</p><p>百度 180.76.76.76</p><p>腾讯DNSPod 119.29.29.29</p><p>CloudFlare 1.1.1.1</p><p>更多 <a href="https://en.wikipedia.org/wiki/Public_recursive_name_server">https://en.wikipedia.org/wiki/Public_recursive_name_server</a></p></blockquote><ol start="2"><li>根域名服务器</li></ol><p>根域名服务器是将主机名转换（解析）为 IP 地址的第一步。</p><p>根域名服务器（英语：root name server，简称“根域名服务器”）是互联网域名解析系统（DNS）中最高级别的域名服务器，负责返回顶级域的权威域名服务器地址。</p><p>任意正常 linux 发行版可以运行如下命令来看到这13台根域名服务器</p><pre><code class="bash">ubuntu@ubuntu_dn11:~$ dig ns . @8.8.8.8; &lt;&lt;&gt;&gt; DiG 9.18.12-0ubuntu0.22.04.3-Ubuntu &lt;&lt;&gt;&gt; ns . @8.8.8.8;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 9453;; flags: qr rd ra ad; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 512;; QUESTION SECTION:;.                              IN      NS;; ANSWER SECTION:.                       71928   IN      NS      a.root-servers.net..                       71928   IN      NS      b.root-servers.net..                       71928   IN      NS      c.root-servers.net..                       71928   IN      NS      d.root-servers.net..                       71928   IN      NS      e.root-servers.net..                       71928   IN      NS      f.root-servers.net..                       71928   IN      NS      g.root-servers.net..                       71928   IN      NS      h.root-servers.net..                       71928   IN      NS      i.root-servers.net..                       71928   IN      NS      j.root-servers.net..                       71928   IN      NS      k.root-servers.net..                       71928   IN      NS      l.root-servers.net..                       71928   IN      NS      m.root-servers.net.;; Query time: 0 msec;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP);; WHEN: Fri Oct 06 13:22:43 UTC 2023;; MSG SIZE  rcvd: 239</code></pre><p>全球13<strong>组</strong>根域名服务器以英文字母A到M依序命名，域名格式为“字母.root-servers.net”。利用任播（anycast）技术在全球多个地点设立镜像站。</p><p>截至2023年6月，全球共有1719台根域名服务器在运行。</p><blockquote><p>Q：为什么是13组？1700组不行吗？</p><p>A：由于DNS和某些协议（未分片的用户数据报协议（UDP）数据包在IPv4内的最大有效大小为512字节）的共同限制，根域名服务器地址的数量被限制为13个。一次返回的数据放不下啦~</p><p>Q：anycast是什么？</p><p>A：我们假设有三台服务器α、β、γ和一台客户机，这三台服务器都宣告了同样的一个地址比如说172.16.255.53，客户机访问172.16.255.53时，会因为路由协议的原因，选择客户机距离服务器最近的一条路径。假设α距离客户机近，访问172.16.255.53获得的数据就是α服务器给客户机的。</p><p>Q：anycast的好处？</p><p>A：防止服务挂掉、流量会自动寻找最佳路径、假设一台服务器挂掉了，整个服务会被另一台服务器承担。</p></blockquote><blockquote><p>Q：有 . 这个服务器吗</p><p>A：存放这13个根域的是一个文件，它被内置在递归服务器内，没有权威服务器会返回 . 这个域的解析给你。<br>在这里可以下载到这个文件 <a href="https://www.iana.org/domains/root/files">https://www.iana.org/domains/root/files</a><br>运营商通常需要配置一个 “Root Hints 文件” 来管理 DNS 递归解析器。该文件包含了根区域的权威名称服务器的名称和 IP 地址，以便软件可以引导 DNS 解析过程。对于许多软件来说，这个列表已经内置在软件中。<a href="https://www.internic.net/domain/named.root">https://www.internic.net/domain/named.root</a></p></blockquote><ol start="3"><li>TLD 名称服务器</li></ol><p>顶级域名（英语：Top-level Domain, TLD）是互联网域名系统的等级中，位于根域空间的最高级域名。</p><p>顶级域名服务器这个服务器是搜索特定 IP 地址的下一步，其上托管了主机名的最后一部分（例如，在 dn11.top 中，TLD 服务器为 “top”）。</p><p><a href="https://www.iana.org/domains/root/db">https://www.iana.org/domains/root/db</a> 这里是世界上完整的顶级域列表。</p><ol start="4"><li>权威性域名服务器</li></ol><p>权威性域名服务器是域名服务器查询中的最后一站。</p><p>权威名称服务器包含特定于其服务域名的信息（例如，dn11.top）权威性域名服务器包含特定于其所服务的域名的信息（例如 dn11.top），并且它可为递归解析器提供在 DNS A 记录中找到的服务器的 IP 地址（例如找到了上文的ipv4地址 104.21.27.178）</p><h2 id="图解工作流程"><a href="#图解工作流程" class="headerlink" title="图解工作流程"></a>图解工作流程</h2><h3 id="递归工作流程"><a href="#递归工作流程" class="headerlink" title="递归工作流程"></a>递归工作流程</h3><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20231006233612.png"></p><p>我这里画了一张图：其中红色服务器为DNS递归服务器，PC上的DNS客户端只与DNS递归服务器通讯，由递归服务器完成后续查询内容。蓝色云为想要访问的网站的ip地址所在的服务器。</p><p>我会逐一讲解每个过程（箭头）都做了什么。</p><p>本图的前提是dns递归服务器中不含任何缓存。</p><p>①：PC通过浏览器输入了dn11.top这个域名、dns客户端收到了请求dn11.top这个域名的ip的任务、dns客户端去请求DNS递归服务器</p><p>②：DNS递归服务器使用内置的Root Hint文件（内有根服务器的NS解析和根服务器的IP地址）去请求根权威服务器、得到了TLD服务器的NS解析并得到了TLD服务器的ip地址</p><p>③：TLD服务器的ip地址被返回给DNS递归服务器</p><p>④：DNS递归服务器去请求TLD服务器、得到了域名权威服务器的NS解析并得到了域名权威服务器的NS记录和IP地址</p><p>⑤：域名权威服务器的ip地址被返回给DNS递归服务器</p><p>⑥：DNS递归服务器去请求域名权威服务器、得到了请求域名最终的ip</p><p>⑦：请求域名最终的ip被返回给DNS递归服务器</p><p>⑧：请求域名最终的ip被返回给PC上的DNS客户端</p><p>⑨：PC上的浏览器用请求域名最终的ip访问域名所在的云服务器</p><p>⑩：云服务器返回网页数据给PC浏览器、实现页面的访问</p><h3 id="迭代工作流程"><a href="#迭代工作流程" class="headerlink" title="迭代工作流程"></a>迭代工作流程</h3><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20231015181102.png"></p><p>我这里画了一张图：其中红色服务器为DNS递归服务器，PC上的DNS客户端只与DNS递归服务器通讯，由递归服务器和权威服务器的迭代查询完成后续查询内容。蓝色云为想要访问的网站的ip地址所在的服务器。</p><p>我会逐一讲解每个过程（箭头）都做了什么。</p><p>本图的前提是dns递归服务器中不含任何缓存。</p><p>①：PC通过浏览器输入了dn11.top这个域名、dns客户端收到了请求dn11.top这个域名的ip的任务、dns客户端去请求DNS递归服务器</p><p>②：DNS递归服务器使用内置的Root Hint文件（内有根服务器的NS解析和根服务器的IP地址）去请求根权威服务器、根权威服务器收到了请求、找到了TLD权威服务器的NS记录和ip地址</p><p>③：根权威服务器请求TLD服务器、TLD服务器收到了请求、找到了域名权威服务器的NS记录和ip地址</p><p>④：TLD服务器请求域名权威服务器、权威服务器找到了域名的ip地址</p><p>⑤：域名的ip地址从域名权威服务器返回给TLD权威服务器</p><p>⑥：域名的ip地址从TLD权威服务器返回给根权威服务器</p><p>⑦：域名的ip地址从根权威返回给DNS递归服务器</p><p>⑧：请求域名最终的ip被返回给PC上的DNS客户端</p><p>⑨：PC上的浏览器用请求域名最终的ip访问域名所在的云服务器</p><p>⑩：云服务器返回网页数据给PC浏览器、实现页面的访问</p><h2 id="配置pdns"><a href="#配置pdns" class="headerlink" title="配置pdns"></a>配置pdns</h2><h3 id="1-openwrt直接启动"><a href="#1-openwrt直接启动" class="headerlink" title="1.openwrt直接启动"></a>1.openwrt直接启动</h3><h4 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h4><pre><code>opkg updateopkg install pdns pdns-backend-sqlite3 pdns-recursor sqlite3-cli</code></pre><h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><p>创建文件</p><pre><code>mkdir -p /usr/share/doc/pdns-backend-sqlite/touch schema.sqlite3.sql</code></pre><p>然后在schema.sqlite3.sql里写入</p><pre><code>nano /usr/share/doc/pdns-backend-sqlite/schema.sqlite3.sql</code></pre><pre><code class="sql">PRAGMA foreign_keys = 1;CREATE TABLE domains (  id                    INTEGER PRIMARY KEY,  name                  VARCHAR(255) NOT NULL COLLATE NOCASE,  master                VARCHAR(128) DEFAULT NULL,  last_check            INTEGER DEFAULT NULL,  type                  VARCHAR(8) NOT NULL,  notified_serial       INTEGER DEFAULT NULL,  account               VARCHAR(40) DEFAULT NULL,  options               VARCHAR(65535) DEFAULT NULL,  catalog               VARCHAR(255) DEFAULT NULL);CREATE UNIQUE INDEX name_index ON domains(name);CREATE INDEX catalog_idx ON domains(catalog);CREATE TABLE records (  id                    INTEGER PRIMARY KEY,  domain_id             INTEGER DEFAULT NULL,  name                  VARCHAR(255) DEFAULT NULL,  type                  VARCHAR(10) DEFAULT NULL,  content               VARCHAR(65535) DEFAULT NULL,  ttl                   INTEGER DEFAULT NULL,  prio                  INTEGER DEFAULT NULL,  disabled              BOOLEAN DEFAULT 0,  ordername             VARCHAR(255),  auth                  BOOL DEFAULT 1,  FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE INDEX records_lookup_idx ON records(name, type);CREATE INDEX records_lookup_id_idx ON records(domain_id, name, type);CREATE INDEX records_order_idx ON records(domain_id, ordername);CREATE TABLE supermasters (  ip                    VARCHAR(64) NOT NULL,  nameserver            VARCHAR(255) NOT NULL COLLATE NOCASE,  account               VARCHAR(40) NOT NULL);CREATE UNIQUE INDEX ip_nameserver_pk ON supermasters(ip, nameserver);CREATE TABLE comments (  id                    INTEGER PRIMARY KEY,  domain_id             INTEGER NOT NULL,  name                  VARCHAR(255) NOT NULL,  type                  VARCHAR(10) NOT NULL,  modified_at           INT NOT NULL,  account               VARCHAR(40) DEFAULT NULL,  comment               VARCHAR(65535) NOT NULL,  FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE INDEX comments_idx ON comments(domain_id, name, type);CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);CREATE TABLE domainmetadata ( id                     INTEGER PRIMARY KEY, domain_id              INT NOT NULL, kind                   VARCHAR(32) COLLATE NOCASE, content                TEXT, FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE INDEX domainmetaidindex ON domainmetadata(domain_id);CREATE TABLE cryptokeys ( id                     INTEGER PRIMARY KEY, domain_id              INT NOT NULL, flags                  INT NOT NULL, active                 BOOL, published              BOOL DEFAULT 1, content                TEXT, FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE INDEX domainidindex ON cryptokeys(domain_id);CREATE TABLE tsigkeys ( id                     INTEGER PRIMARY KEY, name                   VARCHAR(255) COLLATE NOCASE, algorithm              VARCHAR(50) COLLATE NOCASE, secret                 VARCHAR(255));CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm);</code></pre><p>初始化sqlite3</p><pre><code>mkdir -p /etc/powerdns/sqlite3 /etc/powerdns/pdns.sqlite3 &lt; /usr/share/doc/pdns-backend-sqlite/schema.sqlite3.sqlchmod +r /etc/powerdns</code></pre><h4 id="配置pdns-1"><a href="#配置pdns-1" class="headerlink" title="配置pdns"></a>配置pdns</h4><pre><code>nano /etc/powerdns/pdns.conf</code></pre><p>写入</p><pre><code>launch=gsqlite3gsqlite3-database=/etc/powerdns/pdns.sqlite3local-address=&lt;!!你的地址!!&gt;:53allow-axfr-ips=0.0.0.0/0slave=yesallow-notify-from=0.0.0.0/0allow-dnsupdate-from=0.0.0.0/0allow-unsigned-notify=yes</code></pre><p>解释：由于我们正在配置pdns权威服务器，地址可以选一个你自己子网你喜欢的、比如说我在<code>172.16.3.53</code></p><p>当然监听这种地址需要在网卡上创建一个新ip</p><p>对于op来说 可以在web管理界面 选择网络 新建一个接口 区域lan 设备br-lan 地址为<code>172.16.3.53</code></p><p>对于监听53端口、你的本地dnsmasq可能会劫持这个端口</p><p>在此我给出的解决方案是关闭dnsmasq</p><pre><code>service dnsmasq stopservice dnsmasq disable</code></pre><p>然后由于我的dnsmasq会不知道怎么着复活 我写了一个脚本来按死他</p><pre><code>nano /root/stop_dnsmasq_if_running.sh</code></pre><pre><code class="bash">#!/bin/sh # 检查 dnsmasq 是否在运行在端口53上if netstat -tlunpa | grep &#39;:53 &#39; | grep -q &#39;dnsmasq&#39;; then    service dnsmasq stopfi</code></pre><pre><code>crontab -e</code></pre><pre><code>* * * * * /root/stop_dnsmasq_if_running.sh</code></pre><p>这个的意思是一个定时脚本 每分钟检测一下 如果他开着 就给他关掉</p><h4 id="启动pdns"><a href="#启动pdns" class="headerlink" title="启动pdns"></a>启动pdns</h4><pre><code>service pdns restart</code></pre><p>配置自己的子域</p><pre><code>pdnsutil create-zone ts.dn11 ns1.ts.dn11</code></pre><p>其中ts换成你想用的域名</p><pre><code>pdnsutil edit-zone ts.dn11</code></pre><p>edit-zone会唤醒叫editor的编辑器，如果你没有这个叫editor的编辑器 可以写一下环境变量</p><pre><code>nano /etc/profile</code></pre><p>添加一行</p><pre><code>export EDITOR=/usr/bin/nano</code></pre><p>(op的nano默认安装位置在这里、其他你想配的自由发挥)</p><pre><code>source /etc/profile</code></pre><p>打开edit-zone后 写入</p><pre><code>; Warning - every name in this file is ABSOLUTE!$ORIGIN .ts.dn11 3600    IN      SOA     ns1.ts.dn11 hostmaster.ts.dn11 2023093018 60 30 604800 60ts.dn11 3600    IN      NS      ns1.ts.dn11.ns1.ts.dn11     3600    IN      A     172.16.3.53ts.dn11 60      IN      A       172.16.3.1</code></pre><p>解释：SOA记录里第一个值是你域名权威服务器所在的NS、第二个为邮箱、第三个为流水号（格式YYYYMMDD+2位顺序号）（如果你不改的话pdns会自动帮你顺延流水号）、第四个为刷新间隔、第五个为重试间隔、第六个为过期时间长、第七个为TTL（生存时间值、意为缓存过期时间、设置为60s）</p><p>最后一行就是给你的域名加一个A解析</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><pre><code>dig a ts.dn11 @172.16.3.53 -p 53</code></pre><p>如果返回类似如下内容则成功</p><pre><code>root@OP:~# dig a ts.dn11 @172.16.3.53 -p 53; &lt;&lt;&gt;&gt; DiG 9.18.16 &lt;&lt;&gt;&gt; a ts.dn11 @172.16.3.53 -p 53;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 58804;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; WARNING: recursion requested but not available;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;ts.dn11.                       IN      A;; ANSWER SECTION:ts.dn11.                60      IN      A       172.16.3.1;; Query time: 0 msec;; SERVER: 172.16.3.53#53(172.16.3.53) (UDP);; WHEN: Sun Oct 15 18:55:04 CST 2023;; MSG SIZE  rcvd: 52</code></pre><h4 id="配置TLD域、拉取同步"><a href="#配置TLD域、拉取同步" class="headerlink" title="配置TLD域、拉取同步"></a>配置TLD域、拉取同步</h4><p>内网用户需要访问 <a href="http://172.16.7.102:8083/login">http://172.16.7.102:8083/login</a> （账号密码dn11）来配置自己的域名权威的ns指向</p><p>点击dn11域、点击 add record 、添加两条记录</p><pre><code>ns1.ts    A      172.16.3.53ts        NS     ns1.ts.dn11.</code></pre><p>之后点击 save 然后点击 apply changes</p><p>解释：ns1是你本地自己启的域名权威服务器的地址</p><p>然后回到本地 输入</p><pre><code>pdnsutil create-zone dn11</code></pre><p>创建dn11域</p><pre><code>pdnsutil edit-zone dn11</code></pre><p>修改里面的soa值为</p><pre><code>dn11    300     IN      SOA     a.root.dn11 hostmaster.dn11 1 60 60 604800 60</code></pre><p>解释：流水号填小 便于拉取上游的同步</p><p>然后写数据库启用主从同步</p><pre><code>sqlite3 /etc/powerdns/pdns.sqlite3</code></pre><p>进入sqlite命令行</p><p>先启用看头</p><pre><code>sqlite&gt; .header yes</code></pre><pre><code>sqlite&gt; select * from domains;id|name|master|last_check|type|notified_serial|account|options|catalog1|ts.dn11|||NATIVE||||2|dn11|||NATIVE||||</code></pre><p>里面大概也许是这样、然后写数据库同步上游</p><pre><code>UPDATE domainsSET master = &#39;172.16.7.53&#39;, type = &#39;SLAVE&#39;WHERE name = &#39;dn11&#39;;</code></pre><p>写完按 ctrl + D 退出sqlite命令行</p><p>然后使用</p><pre><code>pdns_control retrieve dn11</code></pre><p>强制拉取一下dn11的记录</p><p>最后看下自己的记录有没有被同步</p><pre><code>root@OP:~# pdnsutil list-zone dn11</code></pre><p>检查一下</p><pre><code>root@OP:~# dig ns ts.dn11 @172.16.3.53 -p 53; &lt;&lt;&gt;&gt; DiG 9.18.16 &lt;&lt;&gt;&gt; ns ts.dn11 @172.16.3.53 -p 53;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 7351;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; WARNING: recursion requested but not available;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;ts.dn11.                       IN      NS;; ANSWER SECTION:ts.dn11.                60      IN      NS      172.16.3.53.;; Query time: 0 msec;; SERVER: 172.16.3.53#53(172.16.3.53) (UDP);; WHEN: Sun Oct 15 19:12:09 CST 2023;; MSG SIZE  rcvd: 61</code></pre><h4 id="配置pdns-recursor"><a href="#配置pdns-recursor" class="headerlink" title="配置pdns_recursor"></a>配置pdns_recursor</h4><pre><code>nano /etc/powerdns/recursor.conf</code></pre><p>写入</p><pre><code># 接受哪些IP的查询请求，0.0.0.0/0表示全部allow-from=0.0.0.0/0# 本地监听的接口IP地址local-address=172.16.255.53:53 172.16.255.53:5300# 关闭dnssec功能，4.5版本后默认开启dnssec=offdont-query=forward-zones-recurse=dn11=172.16.3.53,.=223.5.5.5</code></pre><p>解释：</p><p>本地监听的ip地址这里使用anycast、同样的你需要在你的网卡里加一个ip为172.16.255.53（监听5300的原因是、如果路由路径上有人开了dnsmasq、那么这个53请求会被劫持）</p><p>并且宣告</p><pre><code>root@OP:~# cat /etc/bird.conf.........# 宣告 172.16.3.0/24 段protocol static &#123;    ipv4 &#123;        table BGP_table;        import all;        export none;    &#125;;    # 只是为了让BGP的路由表里出现这条路由，不要担心 reject    # 这个动作其实无所谓，reject 这个动作并不会被发到其他 AS    # 后续将在导出到 master4 的时候删除这条路由，本地也不会有这一条    # 请修改为你自己要宣告的段    route 172.16.3.0/24 reject;    route 172.16.255.53/32 reject;&#125;.........root@OP:~# service bird restart</code></pre><p>dont-query&#x3D;的意思是允许内网地址进行查询（默认是禁止的、所以这里填空）</p><p>forward-zones-recurse&#x3D;dn11&#x3D;172.16.3.53,.&#x3D;223.5.5.5</p><p>这个递归配置项的意思是：如果请求到了dn11这个TLD就去请求你自己搭的ns、如果不是这个域就当公网处理转发给公网dns 223.5.5.5</p><p>然后重启</p><pre><code>service pdns-recursor restart</code></pre><p>最后测试一下、请求一下网里存在的域名</p><pre><code>root@OP:~# dig op.iraze.dn11 @172.16.255.53 -p 53; &lt;&lt;&gt;&gt; DiG 9.18.16 &lt;&lt;&gt;&gt; op.iraze.dn11 @172.16.255.53 -p 53;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 4037;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 512;; QUESTION SECTION:;op.iraze.dn11.                 IN      A;; ANSWER SECTION:op.iraze.dn11.          60      IN      A       172.16.2.2;; Query time: 39 msec;; SERVER: 172.16.255.53#53(172.16.255.53) (UDP);; WHEN: Sun Oct 15 19:23:32 CST 2023;; MSG SIZE  rcvd: 58</code></pre><h3 id="2-docker拉镜像-装pdns-admin-web界面管理"><a href="#2-docker拉镜像-装pdns-admin-web界面管理" class="headerlink" title="2.docker拉镜像 装pdns-admin web界面管理"></a>2.docker拉镜像 装pdns-admin web界面管理</h3><pre><code>[root@gs-fedora Pdns]# cat docker-compose.yml version: &quot;3&quot;services:  pdns:    image: zhonger/pdns:latest    restart: always    ports:      - &quot;172.16.7.53:53:53/tcp&quot;      - &quot;172.16.7.53:53:53/udp&quot;    environment:      - PDNS_launch=gsqlite3      - PDNS_gsqlite3_database=/var/lib/powerdns/pdns.sqlite3      - PDNS_webserver_address=0.0.0.0      - PDNS_webserver_allow_from=0.0.0.0/0      - PDNS_allow_axfr_ips=0.0.0.0/0,::1      - PDNS_allow_dnsupdate_from=0.0.0.0/0,::1      - PDNS_allow_notify_from=0.0.0.0/0,::0      - PDNS_also_notify=172.16.3.53      - PDNS_master=yes      - PDNS_api=yes      - PDNS_api_key=0F34664B2C9CA2E1B84C5A6B4605C968    volumes:      - /etc/localtime:/etc/localtime:ro      - ./powerdns:/var/lib/powerdns    command: /bin/bash ./up.sh    privileged: true  db:    image: mysql:latest    environment:      - MYSQL_ALLOW_EMPTY_PASSWORD=yes      - MYSQL_DATABASE=powerdnsadmin      - MYSQL_USER=pdns       - MYSQL_PASSWORD=my_pdns    restart: always    volumes:      - /etc/localtime:/etc/localtime:ro      - ./pda-mysql:/var/lib/mysql    privileged: true  app:    image: zhonger/powerdns-admin:latest    restart: always    depends_on:      - db      - pdns    ports:      - &quot;8083:80&quot;    logging:      driver: json-file      options:        max-size: 50m    volumes:      - /etc/localtime:/etc/localtime:ro    environment:      - SQLALCHEMY_DATABASE_URI=mysql://pdns:my_pdns@db/powerdnsadmin      - GUNICORN_TIMEOUT=60      - GUNICORN_WORKERS=2      - GUNICORN_LOGLEVEL=DEBUG      - OFFLINE_MODE=False # True for offline, False for external resources     privileged: true</code></pre><pre><code>[root@gs-fedora Pdns]# cat up.sh service system-resolve stopip addr add 172.16.7.53 dev eno1</code></pre><p>这个key是我随便写的、你可以自己生成一个</p><p>PDNS_api_key&#x3D;0F34664B2C9CA2E1B84C5A6B4605C968</p><p>在powerdns admin settings pdns中填写这个key 填好后 在上层的PowerDNS server configuration &amp; statistics里能看到一系列pdns的字段</p><h2 id="配置dns分流-MosDNS"><a href="#配置dns分流-MosDNS" class="headerlink" title="配置dns分流 MosDNS"></a>配置dns分流 MosDNS</h2><p>装包</p><pre><code>opkg updateopkg install mosdns</code></pre><p>注意不要装 luci-app-mosdns 我感觉不好用</p><p>改配置</p><pre><code>nano /etc/mosdns/config.yaml</code></pre><pre><code>log:  level: info  file: &quot;/tmp/mosdns.log&quot;api:  http: &quot;0.0.0.0:9091&quot;include: []plugins:  - tag: main_sequence    type: sequence    args:      # hdu内网dns解析      - matches: qname hdu.edu.cn        exec: forward 192.168.0.1:53      # dn11内网dns解析      - matches: qname dn11        exec: forward 172.16.255.53:5300      # 其他dns解析      - matches: &quot;!qname hdu.edu.cn dn11&quot;        exec: forward 223.5.5.5:53  # 启动端口和ip  - tag: udp_server_2    type: udp_server    args:      entry: main_sequence      listen: &quot;172.16.3.13:53&quot;  - tag: tcp_server_2    type: tcp_server    args:      entry: main_sequence      listen: &quot;172.16.3.13:53&quot;</code></pre><p>同样的 启动需要你br-lan网卡里加一个 172.16.3.13这个ip地址</p><pre><code>service mosdns restart</code></pre>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/DN11/">DN11</category>
      
      
      <comments>https://xyxsw.ltd/2023/10/18/DNS%20%E4%B8%8E%20Pdns%20OpenWrt%20DNS%20%E9%80%92%E5%BD%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%20MosDNS%20%E5%88%86%E6%B5%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DN11 使用 EBGP 重分发 IBGP OSPF（同as内部peer）</title>
      <link>https://xyxsw.ltd/2023/09/20/DN11%20%E4%BD%BF%E7%94%A8%20EBGP%20%E9%87%8D%E5%88%86%E5%8F%91%20IBGP%20OSPF%EF%BC%88%E5%90%8Cas%E5%86%85%E9%83%A8peer%EF%BC%89/</link>
      <guid>https://xyxsw.ltd/2023/09/20/DN11%20%E4%BD%BF%E7%94%A8%20EBGP%20%E9%87%8D%E5%88%86%E5%8F%91%20IBGP%20OSPF%EF%BC%88%E5%90%8Cas%E5%86%85%E9%83%A8peer%EF%BC%89/</guid>
      <pubDate>Tue, 19 Sep 2023 16:16:07 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;DN11-使用-EBGP-重分发-IBGP-OSPF（同as内部peer）&quot;&gt;&lt;a href=&quot;#DN11-使用-EBGP-重分发-IBGP-OSPF（同as内部peer）&quot; class=&quot;headerlink&quot; title=&quot;DN11 使用 EBGP 重分发 I</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="DN11-使用-EBGP-重分发-IBGP-OSPF（同as内部peer）"><a href="#DN11-使用-EBGP-重分发-IBGP-OSPF（同as内部peer）" class="headerlink" title="DN11 使用 EBGP 重分发 IBGP OSPF（同as内部peer）"></a>DN11 使用 EBGP 重分发 IBGP OSPF（同as内部peer）</h1><h2 id="连接-wg-peer"><a href="#连接-wg-peer" class="headerlink" title="连接 wg peer"></a>连接 wg peer</h2><p>1.本地机器</p><pre><code class="nginx"># wg_aws.conf[Interface]# 你的私钥PrivateKey = &lt;PRIVATEKAY&gt;# 你开的端口号（注意防火墙）ListenPort = &lt;PORT&gt;PostUp = /sbin/ip addr add dev %i &lt;your ip&gt; peer &lt;peer ip&gt;# 不创建路由（由路由协议接管）Table = off[Peer]# 你对端的ip和端口（外网机器）Endpoint = &lt;ENDPOINT&gt;:&lt;PORT&gt;# 你对端的公钥（外网机器）PublicKey = &lt;PUBLICKEY&gt; AllowedIPs = 0.0.0.0/0</code></pre><p>2.外网机器</p><pre><code class="nginx"># wg_ts_home.conf[Interface]# 你的私钥PrivateKey = &lt;PRIVATEKAY&gt;# 你开的端口号（注意防火墙）ListenPort = &lt;PORT&gt;PostUp = /sbin/ip addr add dev %i &lt;your ip&gt; peer &lt;peer ip&gt;# 不创建路由（由路由协议接管）Table = off# wg 默认的 MTU 是 1420 （这里主要排除外网机器 MTU 异常的问题，洞里打洞不要配这个）MTU = 1420[Peer]# 你对端的ip和端口（本地机器）Endpoint = &lt;ENDPOINT&gt;:&lt;PORT&gt;# 你对端的公钥（本地机器）PublicKey = &lt;PUBLICKEY&gt; AllowedIPs = 0.0.0.0/0</code></pre><h2 id="bird配置"><a href="#bird配置" class="headerlink" title="bird配置"></a>bird配置</h2><p>创建</p><pre><code class="bash">/etc/bird.conf/etc/bird/ospf.conf/etc/bird/ibgp.conf/etc/bird/bgp.conf</code></pre><p>这四个文件</p><p>内网 openwrt 和外网机器上几乎需要相同的这四个文件（唯一不同的是 bgp neighbor 那里）</p><blockquote><p>文中的 172.16.3.254、172.16.3.91 改为你本机（你的本地机器或者外网机器）的隧道ip<br>文中的 4211112243 改为你的 asn （别整出俩 as 号就行）</p></blockquote><h3 id="etc-bird-conf"><a href="#etc-bird-conf" class="headerlink" title="&#x2F;etc&#x2F;bird.conf"></a>&#x2F;etc&#x2F;bird.conf</h3><pre><code class="nginx">log syslog all;debug protocols all;router id 172.16.3.254;ipv4 table BGP_table;ipv4 table OSPF_table;ipv4 table IBGP_table;protocol device&#123;&#125;protocol kernel&#123;    ipv4 &#123;        export all;        import none;    &#125;;&#125;include &quot;/etc/bird/ospf.conf&quot;;include &quot;/etc/bird/ibgp.conf&quot;;include &quot;/etc/bird/bgp.conf&quot;;protocol pipe PIPE_OSPF_BGP&#123;    table BGP_table;    peer table OSPF_table;    import all;    export none;&#125;protocol pipe PIPE_BGP_MASTER4&#123;    table master4;    peer table BGP_table;    import filter &#123;        if source = RTS_STATIC then reject;        krt_prefsrc = 172.16.3.254;        accept;    &#125;;    export none;&#125;protocol pipe PIPE_IBGP_BGP &#123;    table BGP_table;    peer table IBGP_table;    import filter &#123;        if source = RTS_OSPF then reject;        accept;    &#125;;    export filter &#123;        if source = RTS_STATIC then reject;        accept;    &#125;;&#125;# 宣告 172.16.3.0/24 段protocol static &#123;    ipv4 &#123;        table BGP_table;        import all;        export none;    &#125;;    # 只是为了让BGP的路由表里出现这条路由，不要担心 reject    # 这个动作其实无所谓，reject 这个动作并不会被发到其他 AS    # 后续将在导出到 master4 的时候删除这条路由，本地也不会有这一条    # 请修改为你自己要宣告的段    route 172.16.3.0/24 reject;&#125;</code></pre><h3 id="etc-bird-ibgp-conf"><a href="#etc-bird-ibgp-conf" class="headerlink" title="&#x2F;etc&#x2F;bird&#x2F;ibgp.conf"></a>&#x2F;etc&#x2F;bird&#x2F;ibgp.conf</h3><pre><code class="nginx">template bgp ibgp_peers &#123;    local as 4211112243;    source address 172.16.3.254;    multihop;    ipv4 &#123;        next hop self;        igp table OSPF_table;        table IBGP_table;        import all;        export all;    &#125;;&#125;protocol bgp ibgp_aws from ibgp_peers &#123;    neighbor 172.16.3.91 internal;&#125;</code></pre><h2 id="bgp-conf"><a href="#bgp-conf" class="headerlink" title="bgp.conf"></a>bgp.conf</h2><pre><code class="nginx">template bgp BGP_peers &#123;    local 172.16.3.254 as 4211112243;    ipv4 &#123;        table BGP_table;        import all;        export filter &#123;            if source ~ [RTS_STATIC, RTS_BGP, RTS_OSPF] then accept;            reject;        &#125;;    &#125;;&#125;# collector 配置protocol bgp collect_self &#123;    local as 4211112243;    multihop;    neighbor 172.16.255.1 as 4211110101;    ipv4 &#123;        add paths tx;        table BGP_table;        import none;        export filter &#123;            if source ~ [RTS_BGP,RTS_STATIC] then accept;        &#125;;    &#125;;&#125;# 如下的 neighbor 配置应按照 wg 实际链接数量为准# 从模板定义一个BGP邻居# protocol bgp protocol 名称 from 模板名称protocol bgp baimeow from BGP_peers &#123;   neighbor 172.16.4.254%baimeow as 4220084444;&#125;# 如下为 如果你有物理链路的 BGP 配置 （没有的别抄）# protocol bgp Meva_phy from BGP_peers &#123;#     source address 172.16.3.1;#     neighbor 172.16.3.97%&#39;br-lan&#39; as 4211111024;# #     ipv4 &#123;#     import filter &#123;#             if bgp_path ~ [= 4211111024 =] then bgp_local_pref = 120;#             bgp_next_hop = 172.16.3.97;#             accept;#         &#125;;#     &#125;;# &#125;</code></pre><h2 id="ospf-conf"><a href="#ospf-conf" class="headerlink" title="ospf.conf"></a>ospf.conf</h2><pre><code class="nginx">protocol ospf v2 ospf_aws &#123;        ipv4 &#123;                table OSPF_table;                export all;                import all;        &#125;;        area 0.0.0.0 &#123;                interface &quot;wg_aws&quot; &#123;                        cost 20;                        type ptp;                &#125;;                interface &quot;lo&quot; &#123;                        type bcast;                &#125;;        &#125;;&#125;</code></pre>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/DN11/">DN11</category>
      
      
      <comments>https://xyxsw.ltd/2023/09/20/DN11%20%E4%BD%BF%E7%94%A8%20EBGP%20%E9%87%8D%E5%88%86%E5%8F%91%20IBGP%20OSPF%EF%BC%88%E5%90%8Cas%E5%86%85%E9%83%A8peer%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>go-zero api文件生成项目框架 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/08/30/go-zero%20api%E6%96%87%E4%BB%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/08/30/go-zero%20api%E6%96%87%E4%BB%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 30 Aug 2023 14:14:03 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;go-zero-api文件生成项目框架&quot;&gt;&lt;a href=&quot;#go-zero-api文件生成项目框架&quot; class=&quot;headerlink&quot; title=&quot;go-zero api文件生成项目框架&quot;&gt;&lt;/a&gt;go-zero api文件生成项目框架&lt;/h2&gt;&lt;h2 i</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="go-zero-api文件生成项目框架"><a href="#go-zero-api文件生成项目框架" class="headerlink" title="go-zero api文件生成项目框架"></a>go-zero api文件生成项目框架</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>.api文件是go-zero自创的文件格式，和protobuf的语法有很大不同，但好在不难理解。具体语法介绍可看官网文档：<a href="https://link.juejin.cn/?target=https://go-zero.dev/docs/tasks/dsl/api">go-zero.dev&#x2F;docs&#x2F;tasks&#x2F;…</a></p><p>先编写接口定义，然后直接一次性使用 goctl 生成代码。</p><p>api文件支持将一个数据结构嵌入另一个结构中，便于编写统一的响应格式。</p><p>首先定义空请求结构和基础的响应结构：</p><pre><code class="api">syntax = &quot;v1&quot;    type Empty &#123;  &#125;    type BasicResponse &#123;      StatusCode int32 `json:&quot;status_code&quot;`      StatusMsg string `json:&quot;status_msg&quot;`  &#125;</code></pre><p>type关键字也支持代码块，只需要用<code>type()</code>包裹，就可以省去关键词。下面定义了注册和登录的请求和响应结构。</p><pre><code class="go">type (      RegisterRequest struct &#123;          Username string `form:&quot;username&quot;`          Password string `form:&quot;password&quot;`      &#125;      RegisterResponse struct &#123;          BasicResponse          UserId int64 `json:&quot;user_id&quot;`       &#125;  )    type (      LoginRequest struct &#123;          Username string `form:&quot;username&quot;`          Password string `form:&quot;password&quot;`      &#125;      LoginResponse struct &#123;          BasicResponse          UserId int64 `json:&quot;user_id&quot;`      &#125;  )</code></pre><p>最后还要定义一个获取用户信息的接口。因为本文不涉及创作、社交方面的业务逻辑实现，所以<code>User</code>结构其实没什么可以返回的信息。之后将其嵌入响应类型的<code>user</code>字段中：</p><pre><code class="go">type (      User &#123;          Id int64 `json:&quot;id&quot;`          Name string `json:&quot;name&quot;`      &#125;          GetUserInfoRequest struct &#123;          UserId int64 `form:&quot;user_id&quot;`       &#125;      GetUserInfoResponse struct &#123;          BasicResponse          User User `json:&quot;user&quot;`      &#125;  )</code></pre><h2 id="定义接口路由"><a href="#定义接口路由" class="headerlink" title="定义接口路由"></a>定义接口路由</h2><p>把所有api路由配置好</p><pre><code class="api">@server(      group: app  )  service app &#123;      @handler Ping      get /ping (Empty) returns (BasicResponse)  &#125;    @server(      group: user      prefix: /douyin/user  )  service app &#123;      @handler Register      post /register (RegisterRequest) returns (RegisterResponse)        @handler Login      post /login (LoginRequest) returns (LoginResponse)        @handler GetUserInfo      get / (GetUserInfoRequest) returns (GetUserInfoResponse)  &#125;</code></pre><p>以下几点需要注意：</p><ol><li>如果service代码块有多个，要求后面的名称（即“app”）相同</li><li>形如装饰器的@server代码块可以做代码分组、路由前缀、鉴权、中间件等多种配置。<ul><li>这里把路由分成app和user两组，之后生成时会分组放在文件夹里</li><li>给user组设置了<code>/douyin/user</code>的路由器前缀，就不用重复写了</li><li>鉴权和中间件配置下文会提到</li></ul></li><li>每个接口需要一个<code>handler</code>，其实就是给函数起名</li><li>接口定义的格式是 <code>&lt;HTTP方法&gt; &lt;子路径&gt; (&lt;请求数据结构&gt;) returns (&lt;响应数据结构&gt;) </code></li></ol><h2 id="创建项目模板"><a href="#创建项目模板" class="headerlink" title="创建项目模板"></a>创建项目模板</h2><p>这次不是新建示例项目，而是根据现有的api声明创建</p><p>安装 goctl</p><p><a href="https://go-zero.dev/docs/tasks/installation/goctl">https://go-zero.dev/docs/tasks/installation/goctl</a></p><pre><code class="bash">$ GO111MODULE=on go install github.com/zeromicro/go-zero/tools/goctl@latest</code></pre><p>安装 protoc</p><p><a href="https://go-zero.dev/docs/tasks/installation/protoc">https://go-zero.dev/docs/tasks/installation/protoc</a></p><pre><code class="bash">$ goctl env check --install --verbose --force</code></pre><pre><code class="shell">goctl api go --api app.api --dir=. --style=goZero </code></pre><p>这会在当前目录生成项目文件。之后进入目录安装依赖：</p><pre><code class="shell">go mod tidy</code></pre><h2 id="测试Ping接口"><a href="#测试Ping接口" class="headerlink" title="测试Ping接口"></a>测试Ping接口</h2><p>Ping接口的逻辑在<code>internal/logic/app/pingLogic.go</code>，打开文件并编辑handler函数：</p><pre><code class="go">func (l *PingLogic) Ping(req *types.Empty) (resp *types.BasicResponse, err error) &#123;      return &amp;types.BasicResponse&#123;        StatusCode: 0,        StatusMsg:  &quot;pong&quot;,    &#125;, nil&#125;</code></pre><p>这里的写法和rpc微服务有点区别。注意到传入的<code>resp</code>是一个指针，所以需要<strong>手动创建</strong>一个响应结构体并设置键值。</p><p>这样就算完成Ping接口了，可以运行服务。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/08/30/go-zero%20api%E6%96%87%E4%BB%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>gorm 进阶 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/08/30/gorm%E8%BF%9B%E9%98%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/08/30/gorm%E8%BF%9B%E9%98%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 30 Aug 2023 11:21:58 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;gorm&quot;&gt;&lt;a href=&quot;#gorm&quot; class=&quot;headerlink&quot; title=&quot;gorm&quot;&gt;&lt;/a&gt;gorm&lt;/h2&gt;&lt;p&gt;关于简单的 gorm 总结 可以看上一篇文章  gorm 初体验 ｜ 青训营笔记&lt;/p&gt;
&lt;h3 id=&quot;软删除&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h2><p>关于简单的 gorm 总结 可以看上一篇文章  gorm 初体验 ｜ 青训营笔记</p><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p><code>Gorm</code>提供了软删除的能力，需要在结构体中定义一个<code>Deleted</code>字段，此时再调用<code>Delete</code>删除函数，则会生成<code>update</code>语句，并将<code>deleted</code>字段赋值为当前删除时间。</p><pre><code class="go">type Product struct &#123;    ID      uint    Code    string    Price   uint    Deleted gorm.DeletedAt&#125;</code></pre><p>再次执行删除操作：</p><pre><code class="go">godb.Delete(&amp;Product&#123;&#125;, 1)</code></pre><p>生成的<code>sql</code>为：</p><pre><code class="sql">UPDATE `product` SET `deleted`=&#39;2023-01-30 22:22:22.202&#39; WHERE `product`.`id` = 1 AND `product`.`deleted` IS NULL</code></pre><p>查询被软删除的操作，要使用<code>Unscoped</code>函数：</p><pre><code class="go">db.Unscoped().First(&amp;product, 2)</code></pre><p>有了<code>DeleteAt</code>字段后，删除操作已经变成了更新操作，那么想要物理删除怎么办？也是使用<code>Unscoped</code>函数：</p><pre><code class="go">db.Unscoped().Delete(&amp;Product&#123;&#125;, 1)</code></pre><h2 id="Gorm事务"><a href="#Gorm事务" class="headerlink" title="Gorm事务"></a>Gorm事务</h2><p><code>Gorm</code>提供了<code>Begin</code>、<code>Commit</code>、<code>Rollback</code>方法用于使用事务。</p><pre><code class="go">// 开启事务tx := db.Begin()if err := tx.Create(&amp;Product&#123;Code: &quot;D32&quot;, Price: 100&#125;).Error; err != nil &#123;    // 出现错误回滚    tx.Rollback()    return&#125;if err := tx.Create(&amp;Product&#123;Code: &quot;D33&quot;, Price: 100&#125;).Error; err != nil &#123;    // 出现错误回滚    tx.Rollback()    return&#125;// 提交事务tx.Commit()</code></pre><p>在开启事务后，调用增删改操作是应该使用开启事务返回的<code>tx</code>而不是<code>db</code>。</p><p><code>Gorm</code>还提供了<code>Transaction</code>函数用于自定提交事务，避免用户漏写<code>Commit</code>、<code>Rollback</code>。</p><pre><code class="go">if err = db.Transaction(func(tx *gorm.DB) error &#123;    if err := db.Create(&amp;Product&#123;Code: &quot;D55&quot;, Price: 100&#125;).Error; err != nil &#123;        return err    &#125;    if err := db.Create(&amp;Product&#123;Code: &quot;D56&quot;, Price: 100&#125;).Error; err != nil &#123;        return err    &#125;    return nil&#125;); err != nil &#123;    return&#125;</code></pre><p>这种写法，当出现错误时会自动进行<code>Rollback</code>，当正常执行时会自动<code>Commit</code>。</p><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>当我们想在执行增删改查操作前后做一些额外的操作时，可以使用<code>Gorm</code>提供的<code>Hook</code>能力。</p><p><code>Hook</code>是在创建、查询、更新、删除等操作之前、之后自动调用的函数，如果任何<code>Hook</code>返回错误，<code>Gorm</code>将停止后续的操作并回滚事务。</p><p><code>Hook</code>会开启默认事务，所以会带来了一些性能损失。</p><h3 id="性能提高"><a href="#性能提高" class="headerlink" title="性能提高"></a>性能提高</h3><p>对于写操作（创建、更新、删除），为了确保数据的完整性，<code>Gorm</code>会将他们封装在事务内运行，但是这样会降低性能，可以使用<code>SkipDefaultTransaction</code>关闭默认事务。</p><p>使用<code>PrepareStmt</code>缓存预编译语句可以提高后续调用的速度。</p><pre><code class="go">db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  SkipDefaultTransaction: true,  PrepareStmt: true,&#125;)</code></pre><h2 id="Gorm生态"><a href="#Gorm生态" class="headerlink" title="Gorm生态"></a>Gorm生态</h2><p>Gorm拥有非常丰富的扩展生态，下面列举一些常用的扩展。</p><ul><li>代码生成工具:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/gen">github.com&#x2F;go-gorm&#x2F;gen</a></li><li>分片分库方案:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/sharding">github.com&#x2F;go-gorm&#x2F;sha…</a></li><li>手动索引:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/hints">github.com&#x2F;go-gorm&#x2F;hin…</a></li><li>乐观锁:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/optimisticlock">github.com&#x2F;go-gorm&#x2F;opt…</a></li><li>读写分离:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/dbresolver">github.com&#x2F;go-gorm&#x2F;dbr…</a></li><li>OpenTelemetry扩展:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/opentelemetry">github.com&#x2F;go-gorm&#x2F;ope…</a></li></ul><h2 id="GORM-配置"><a href="#GORM-配置" class="headerlink" title="GORM 配置"></a>GORM 配置</h2><p>GORM 提供的配置可以在初始化时使用</p><pre><code class="go">type Config struct &#123;  SkipDefaultTransaction   bool  NamingStrategy           schema.Namer  Logger                   logger.Interface  NowFunc                  func() time.Time  DryRun                   bool  PrepareStmt              bool  DisableNestedTransaction bool  AllowGlobalUpdate        bool  DisableAutomaticPing     bool  DisableForeignKeyConstraintWhenMigrating bool&#125;</code></pre><h3 id="跳过默认事务"><a href="#跳过默认事务" class="headerlink" title="跳过默认事务"></a>跳过默认事务</h3><p>为了确保数据一致性，GORM 会在事务里执行写入操作（创建、更新、删除）。如果没有这方面的要求，您可以在初始化时禁用它。</p><pre><code class="go">db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  SkipDefaultTransaction: true,&#125;)</code></pre><h3 id="命名策略"><a href="#命名策略" class="headerlink" title="命名策略"></a>命名策略</h3><p>GORM 允许用户通过覆盖默认的<code>NamingStrategy</code>来更改命名约定，这需要实现接口 <code>Namer</code></p><pre><code class="go">type Namer interface &#123;    TableName(table string) string    SchemaName(table string) string    ColumnName(table, column string) string    JoinTableName(table string) string    RelationshipFKName(Relationship) string    CheckerName(table, column string) string    IndexName(table, column string) string&#125;</code></pre><p>默认 <code>NamingStrategy</code> 也提供了几个选项，如：</p><pre><code class="go">db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  NamingStrategy: schema.NamingStrategy&#123;    TablePrefix: &quot;t_&quot;,   // table name prefix, table for `User` would be `t_users`    SingularTable: true, // use singular table name, table for `User` would be `user` with this option enabled    NoLowerCase: true, // skip the snake_casing of names    NameReplacer: strings.NewReplacer(&quot;CID&quot;, &quot;Cid&quot;), // use name replacer to change struct/field name before convert it to db name  &#125;,&#125;)</code></pre><h3 id="NowFunc"><a href="#NowFunc" class="headerlink" title="NowFunc"></a>NowFunc</h3><p>更改创建时间使用的函数</p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  NowFunc: func() time.Time &#123;    return time.Now().Local()  &#125;,&#125;)</code></pre><h3 id="DryRun"><a href="#DryRun" class="headerlink" title="DryRun"></a>DryRun</h3><p>生成 <code>SQL</code> 但不执行，可以用于准备或测试生成的 SQL</p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  DryRun: false,&#125;)</code></pre><h3 id="PrepareStmt"><a href="#PrepareStmt" class="headerlink" title="PrepareStmt"></a>PrepareStmt</h3><p><code>PreparedStmt</code> 在执行任何 SQL 时都会创建一个 prepared statement 并将其缓存，以提高后续的效率</p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  PrepareStmt: false,&#125;)</code></pre><h3 id="禁用嵌套事务"><a href="#禁用嵌套事务" class="headerlink" title="禁用嵌套事务"></a>禁用嵌套事务</h3><p>在一个事务中使用 <code>Transaction</code> 方法，GORM 会使用 <code>SavePoint(savedPointName)</code>，<code>RollbackTo(savedPointName)</code> 为你提供嵌套事务支持，你可以通过 <code>DisableNestedTransaction</code> 选项关闭它</p><h3 id="DisableAutomaticPing"><a href="#DisableAutomaticPing" class="headerlink" title="DisableAutomaticPing"></a>DisableAutomaticPing</h3><p>在完成初始化后，GORM 会自动 ping 数据库以检查数据库的可用性，若要禁用该特性，可将其设置为 <code>true</code></p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  DisableAutomaticPing: true,&#125;)</code></pre><h3 id="DisableForeignKeyConstraintWhenMigrating"><a href="#DisableForeignKeyConstraintWhenMigrating" class="headerlink" title="DisableForeignKeyConstraintWhenMigrating"></a>DisableForeignKeyConstraintWhenMigrating</h3><p>在 <code>AutoMigrate</code> 或 <code>CreateTable</code> 时，GORM 会自动创建外键约束，若要禁用该特性，可将其设置为 <code>true</code></p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  DisableForeignKeyConstraintWhenMigrating: true,&#125;)</code></pre>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/08/30/gorm%E8%BF%9B%E9%98%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>go字节三件套 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/08/28/go%E5%AD%97%E8%8A%82%E4%B8%89%E4%BB%B6%E5%A5%97%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/08/28/go%E5%AD%97%E8%8A%82%E4%B8%89%E4%BB%B6%E5%A5%97%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 28 Aug 2023 14:26:29 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Gorm、Kitex、Hertz：三件套介绍与基本用法&quot;&gt;&lt;a href=&quot;#Gorm、Kitex、Hertz：三件套介绍与基本用法&quot; class=&quot;headerlink&quot; title=&quot;Gorm、Kitex、Hertz：三件套介绍与基本用法&quot;&gt;&lt;/a&gt;Gorm、</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Gorm、Kitex、Hertz：三件套介绍与基本用法"><a href="#Gorm、Kitex、Hertz：三件套介绍与基本用法" class="headerlink" title="Gorm、Kitex、Hertz：三件套介绍与基本用法"></a>Gorm、Kitex、Hertz：三件套介绍与基本用法</h2><h3 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h3><p>Gorm是Golang中广受欢迎的ORM（对象关系映射）框架，已经发展数十年，具有强大的功能和出色的性能。</p><p>ORM框架用于将面向对象的概念与数据库中的表相对应，简化数据操作过程。在Golang中，自定义的结构体与数据库表一一对应，结构体的实例对应表中的一条记录。</p><p>基本用法</p><p>定义结构体：在Gorm中，定义结构体来映射数据库表。</p><pre><code class="go">type User struct &#123;  ID    uint   `gorm:&quot;primary_key&quot;`  Name  string `gorm:&quot;type:varchar(100)&quot;`  Email string `gorm:&quot;type:varchar(100);uniqueIndex&quot;`&#125;</code></pre><p>增加数据：使用Create方法来新增数据条目。</p><pre><code class="go">db.Create(&amp;User&#123;Name: &quot;John&quot;, Email: &quot;john@example.com&quot;&#125;)</code></pre><p>查询数据：使用Find进行数据查找，可以通过Where和Or条件构建查询条件。</p><pre><code class="go">var user Userdb.Where(&quot;name = ?&quot;, &quot;John&quot;).First(&amp;user)</code></pre><p>更新数据：使用Update进行数据更新，可以使用Model结合Update或Updates方法来更新列。</p><pre><code class="go">db.Model(&amp;user).Update(&quot;Name&quot;, &quot;John Updated&quot;)</code></pre><p>删除数据：使用Delete进行数据删除操作，根据是否包含gorm.deletedat字段执行物理或逻辑删除。</p><pre><code class="go">db.Delete(&amp;user)</code></pre><h3 id="Kitex"><a href="#Kitex" class="headerlink" title="Kitex"></a>Kitex</h3><p><a href="https://www.cloudwego.io/zh/docs/kitex/overview/">https://www.cloudwego.io/zh/docs/kitex/overview/</a></p><p>Kitex是字节开发的高性能Golang微服务RPC框架，具备出色的可扩展性和高性能。<br>服务端</p><pre><code class="go">func main() &#123;  srv := kitex.NewServer(new(YourServiceImpl),                           kitex.WithServiceAddr(&quot;:8888&quot;))  srv.Run()&#125;</code></pre><p>客户端</p><pre><code class="go">func main() &#123;  client := NewYourServiceClient(&quot;127.0.0.1:8888&quot;, kitex.WithTransportProtocol(protocol.TRPC))  // 调用RPC方法&#125;</code></pre><p>高性能：Kitex具有优异的性能表现，适用于高负载的微服务场景。<br>可扩展：支持多协议，并且有丰富的开源扩展库，可以满足各种需求。</p><h3 id="Hertz"><a href="#Hertz" class="headerlink" title="Hertz"></a>Hertz</h3><p><a href="https://www.cloudwego.io/zh/docs/hertz/overview/">https://www.cloudwego.io/zh/docs/hertz/overview/</a></p><p>Hertz是字节开发的HTTP框架，结合了其他开源框架的优点，同时满足字节跳动内部的需求，具有高可用性、高性能和高扩展性。</p><pre><code class="go">package mainimport (    &quot;context&quot;    &quot;github.com/cloudwego/hertz/pkg/app&quot;    &quot;github.com/cloudwego/hertz/pkg/app/server&quot;    &quot;github.com/cloudwego/hertz/pkg/common/utils&quot;    &quot;github.com/cloudwego/hertz/pkg/protocol/consts&quot;)func main() &#123;    h := server.Default()    h.GET(&quot;/ping&quot;, func(c context.Context, ctx *app.RequestContext) &#123;            ctx.JSON(consts.StatusOK, utils.H&#123;&quot;message&quot;: &quot;pong&quot;&#125;)    &#125;)    h.Spin()&#125;</code></pre><p>高可用性：Hertz框架被设计为具有高度的稳定性和可用性，适用于大规模的应用场景。<br>高性能：框架在性能方面表现出色，适合处理高并发请求。<br>高扩展性：Hertz框架允许根据业务需求进行定制和扩展，以满足复杂应用的要求。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/08/28/go%E5%AD%97%E8%8A%82%E4%B8%89%E4%BB%B6%E5%A5%97%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>网站安全漏洞 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/08/26/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/08/26/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sat, 26 Aug 2023 06:33:42 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;什么是漏洞&quot;&gt;&lt;a href=&quot;#什么是漏洞&quot; class=&quot;headerlink&quot; title=&quot;什么是漏洞&quot;&gt;&lt;/a&gt;什么是漏洞&lt;/h2&gt;&lt;p&gt;漏洞是指在网站或网络应用中存在的安全弱点，它们可能由于各种原因而产生，包括编码错误、配置不当或第三方组件的安全性不足</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是漏洞"><a href="#什么是漏洞" class="headerlink" title="什么是漏洞"></a>什么是漏洞</h2><p>漏洞是指在网站或网络应用中存在的安全弱点，它们可能由于各种原因而产生，包括编码错误、配置不当或第三方组件的安全性不足。了解一个网站的基本构成是理解漏洞的第一步。网站通常由以下几个关键组成部分构成，而攻击者通常会尝试从这些部分找出弱点进行攻击：</p><ul><li><strong>前端</strong>：使用的技术可能包括HTML、CSS、JavaScript、Vue.js、React.js等。</li><li><strong>网关</strong>：例如nginx或Apache，负责处理进出的网络流量。</li><li><strong>后端</strong>：可能是用Go、Java、Node.js、Python等语言编写的。</li><li><strong>前后端交互</strong>：通常通过HTTP或WebSocket进行。</li></ul><h2 id="常见的安全事件"><a href="#常见的安全事件" class="headerlink" title="常见的安全事件"></a>常见的安全事件</h2><p>由安全漏洞引发的攻击事件不仅可能导致数据泄露、服务瘫痪、成果失窃和系统劫持，还可能带来以下更为严重的后果：</p><ul><li><strong>法律责任</strong>：泄露用户数据可能导致法律诉讼和巨额罚款。</li><li><strong>品牌声誉受损</strong>：一次严重的安全事件可能永久性地影响公司的声誉。</li><li><strong>业务中断</strong>：服务中断可能导致用户流失和收入减少。</li><li><strong>内外部信任度下降</strong>：员工和合作伙伴也可能因为安全事件而对企业失去信任。</li></ul><h2 id="网站攻击者的意图"><a href="#网站攻击者的意图" class="headerlink" title="网站攻击者的意图"></a>网站攻击者的意图</h2><p>确切地知道攻击者的意图可以帮助企业更有效地防御威胁。除了政治、经济和竞争等原因外，还有以下可能的攻击动机：</p><ul><li><strong>社会工程攻击</strong>：通过人为操作或欺骗，使内部人员泄露敏感信息。</li><li><strong>黑帽SEO</strong>：通过各种手段来操纵搜索引擎排名。</li><li><strong>资源占用</strong>：攻击者可能只是为了消耗目标网站的资源。</li><li><strong>纯粹的破坏欲</strong>：有些攻击者可能只是出于破坏的乐趣。</li></ul><h3 id="红蓝对抗"><a href="#红蓝对抗" class="headerlink" title="红蓝对抗"></a>红蓝对抗</h3><p>红蓝对抗是一种模拟现实世界网络攻防场景的方法，通常用于评估和提升组织的安全防护能力。在这一模式中，红军（Red Team）模拟攻击者，寻找系统的弱点和漏洞；蓝军（Blue Team）则扮演防御方，负责检测和阻止这些攻击。除此之外，还有所谓的“紫军”（Purple Team），负责协调红蓝两方，以确保双方都从对抗中获得最大的学习价值。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>网站攻击通常可以分为两大类：针对客户端的攻击和针对服务端的攻击。</p><ul><li><strong>针对客户端的攻击</strong>：这类攻击直接影响网站的终端用户，例如通过XSS（跨站脚本）或CSRF（跨站请求伪造）等方式。</li><li><strong>针对服务端的攻击</strong>：这类攻击目标是网站后端的服务器或数据库，例如通过SQL注入或命令执行等方式。 每一种攻击都有其自己的防护机制和修补方案，因此对这些攻击手段有深入的了解是非常重要的。</li></ul><h3 id="服务端漏洞"><a href="#服务端漏洞" class="headerlink" title="服务端漏洞"></a>服务端漏洞</h3><p>服务端漏洞通常比客户端漏洞更为严重，因为它们直接影响到整个系统的安全性。其中，第三方组件漏洞是一个常见但经常被忽视的问题。例如，一些流行的开源库或框架可能存在已知的安全问题，如果开发人员没有及时更新这些组件，就可能导致整个系统的安全性受到威胁。</p><h3 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h3><p>SQL注入是一种常见但危险的攻击手段，它出现在应用程序未能正确地处理用户输入的场合。更准确地说，攻击者通过输入特定的SQL代码片段，使得原SQL查询逻辑被改变，从而达到非法获取数据或执行特定操作的目的。防范SQL注入的基础是编码规范，包括但不限于使用预编译SQL语句、参数化查询，以及进行严格的输入验证。</p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>命令执行漏洞通常发生在应用需要与操作系统进行交互时。与SQL注入类似，这一漏洞也常常是由于不正确的输入处理引起的。攻击者可能会尝试插入恶意命令或参数，以此来控制或破坏目标系统。防护措施包括使用安全的API进行命令调用、对用户输入进行严格的验证和过滤，以及使用最小权限原则来限制应用程序对系统资源的访问。</p><h3 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h3><p>越权漏洞是授权控制不当导致的一类安全问题，它们通常分为三类：</p><ul><li><strong>未授权</strong>：用户无需任何授权即可访问受限制的资源。</li><li><strong>水平越权</strong>：用户访问同一权限级别但不属于自己的资源。</li><li><strong>垂直越权</strong>：低权限用户访问高权限用户的资源。 越权问题的根本在于不恰当的权限控制和会话管理，因此相应的防护措施应从这两方面入手。</li></ul><h3 id="SSRF攻击"><a href="#SSRF攻击" class="headerlink" title="SSRF攻击"></a>SSRF攻击</h3><p>服务端请求伪造（SSRF）是一种利用目标服务器作为中间人来发起请求的攻击。这样做可能会暴露原本不可达的内部网络资源。SSRF通常利用的是应用程序或服务器配置中的不当输入验证或URL解析缺陷。防范措施包括限制从服务器发出的请求类型和目标，以及对所有外部输入进行严格的验证。</p><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>文件上传漏洞是一种常见的安全风险，尤其是在允许用户上传文件的应用中。如果没有适当的安全措施，攻击者可能会上传含有恶意代码的文件，这些文件一旦被执行，可能会导致严重的安全后果。因此，除了基本的文件类型检测和大小限制外，更高级的防护措施，如内容扫描和安全存储策略，也是非常必要的。</p><h3 id="客户端漏洞"><a href="#客户端漏洞" class="headerlink" title="客户端漏洞"></a>客户端漏洞</h3><p>客户端漏洞主要影响网站的最终用户，而不是服务器或数据库。这些漏洞通常涉及到如何处理从客户端（通常是Web浏览器）发来的数据和请求。例如，开放重定向是一种常见的客户端漏洞，攻击者通过这种漏洞可以将用户重定向到恶意网站。修复这类问题通常需要在客户端和服务器端都进行适当的输入验证。</p><h3 id="跨站脚本（XSS）攻击"><a href="#跨站脚本（XSS）攻击" class="headerlink" title="跨站脚本（XSS）攻击"></a>跨站脚本（XSS）攻击</h3><p>跨站脚本（XSS）是一种在目标网站上执行恶意脚本的攻击方式。它利用的是网站没有对用户提交的数据进行适当的过滤和转义。根据攻击的具体形式，XSS攻击可以进一步分为存储型、反射型和DOM型三类。每种类型的XSS攻击都有其独特的防御方法，如输入过滤、输出编码和内容安全策略（CSP）。</p><h3 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h3><p>跨站请求伪造（CSRF）是一种攻击手法，攻击者通过某种方式诱导用户点击一个链接或按钮，从而在用户不知情的情况下，以该用户的身份执行非预期的操作。防御CSRF攻击的常见方法包括使用CSRF令牌、设置SameSite属性等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们列举了网站安全漏洞的多个方面，从基础概念到各种类型的安全漏洞，以及如何防范这些漏洞。重要的是，无论是服务端还是客户端，安全漏洞都可能存在，并且都需要得到妥善的处理。</p><p>网站安全是一个涉及多个层面的复杂问题，需要开发者、运维人员、以及安全团队共同努力来维护。只有全方位、多层次的安全防护措施，才能有效地减少安全风险，保护网站和用户数据的安全。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/08/26/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>go架构 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/08/24/go%E6%9E%B6%E6%9E%84%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/08/24/go%E6%9E%B6%E6%9E%84%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Thu, 24 Aug 2023 10:35:56 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;什么是架构&quot;&gt;&lt;a href=&quot;#什么是架构&quot; class=&quot;headerlink&quot; title=&quot;什么是架构&quot;&gt;&lt;/a&gt;什么是架构&lt;/h2&gt;&lt;p&gt;主要针对互联网服server系统（类似网站）来定义架构：架构是系统的骨架，支撑和链接各个部分，包括组件、连接件、约束</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h2><p>主要针对互联网服server系统（类似网站）来定义架构：架构是系统的骨架，支撑和链接各个部分，包括组件、连接件、约束规范，以及指导这些内容设计与演化的原理。</p><ul><li><p>组件：类似应用服务，独立模块、数据库、nginx等等、</p></li><li><p>连接件：分布式调用、进程间调用、调用使用http协议还是tcp协议、组件之间的交互关系、</p></li><li><p>约束规范： 定规则做限制：例如设计原则、编码规范等等。</p></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是架构的构建块，包括独立模块、数据库、Nginx等。</p><p>例如，Go语言中可以定义一个组件，如一个HTTP服务器：</p><pre><code class="go">package mainimport (    &quot;net/http&quot;)func main() &#123;    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;        w.Write([]byte(&quot;Hello, World!&quot;))    &#125;)    http.ListenAndServe(&quot;:8080&quot;, nil)&#125;</code></pre><h3 id="连接件"><a href="#连接件" class="headerlink" title="连接件"></a>连接件</h3><p>连接件处理组件之间的交互关系，例如分布式调用、进程间调用、使用的协议等。</p><h3 id="约束规范"><a href="#约束规范" class="headerlink" title="约束规范"></a>约束规范</h3><p>约束规范定义了架构中的规则和限制，例如设计原则和编码规范。</p><h2 id="几种典型架构"><a href="#几种典型架构" class="headerlink" title="几种典型架构"></a>几种典型架构</h2><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><p>单机架构就是把所有功能都实现在一个进程中，并部署在一台机器上。</p><p>单机架构的<strong>优点</strong>是非常简单，<strong>缺点</strong>是会遇到并发处理的难题，而且运维需要停服。</p><p>当时计算机软硬件性能比较基础，这个问题引起人们对网络套接字优化和服务端调度的关注，这个词语也随着时代的发展逐渐变化，如<code>C10M</code>代表的是处理1000万个并发连接。现在的计算机已经有足够的性能和优秀的软件来支撑单机数百万连接了，然而并发问题仍然是后端架构设计中不能略过的关键问题。</p><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>单体架构是对单机架构的改进。既然单机处理能力有限，就可以采用分布式部署的模式设置多台单机，再设置一个分流环节，将请求转发给各个单体服务器来处理。</p><p>单体架构的优点是可以实现水平扩容，处理能力不够时只需要简单添加新的单机即可；运维不需要停服，可以逐个对单机维护不影响其他单机的运行。单体架构下，每台机器的功能是一致的，因此它没有解决这两个缺点：</p><ol><li>职责太多，开发效率低：每台机器都要实现系统的完整功能，不能专注于某个功能的开发。</li><li><strong>爆炸半径大</strong>： 爆炸半径是指爆炸可能造成损害的区域范围。在生产环境中指的就是部署的服务故障时可能影响的软件功能范围。单体架构下每一个单机下线，都会造成所有功能的处理承载量下降，因此爆炸半径覆盖了软件多数功能。</li></ol><h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>为了解决单体架构的问题，垂直应用架构提供了一种思路，将系统按照服务拆分任务，分配给不同的服务器，从而实现职责的简单划分，一定程度上提高开发和运维的效率。不过在实践中一个服务往往是大量功能点的集合，仍然存在功能琐碎的问题</p><h2 id="更加高级的架构"><a href="#更加高级的架构" class="headerlink" title="更加高级的架构"></a>更加高级的架构</h2><h3 id="SOA、微服务架构"><a href="#SOA、微服务架构" class="headerlink" title="SOA、微服务架构"></a>SOA、微服务架构</h3><p>SOA（Service-Oriented Architecture）架构具有两个特性：</p><ol><li>将应用的不同功能单元抽象为服务，从而细分职责</li><li>定义服务之间的通信标准，确保服务之间的数据流通</li></ol><p>微服务架构则是SOA架构去中心化的演进方向，旨在减少服务之间的沟通消耗，避免SOA服务内部集中沟通导致的过度中心化问题，他实现了水平切分，减少了跨级别调用链，让每个服务直接负责的上下级减少。</p><p>这类架构在解决之前的弊端时，也会引入新的问题：</p><ul><li>数据一致性问题：不同服务如何确保数据同步</li><li>高可用问题：服务之间如何进行可靠合作</li><li>治理问题：一个服务出现问题时，要如何容灾</li><li>解耦和过微问题：过度细分会导致运维成本提高，要如何权衡？</li></ul><h3 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h3><p>事件驱动架构（EDA）是一种异步架构，其中生产者生成事件，并由一个或多个消费者消费。这允许解耦生产者和消费者，并实现高度可扩展和灵活的系统。</p><p>Apache Kafka<br>Apache Kafka是一种流行的事件流平台。您可以使用Go编写Kafka的生产者和消费者。</p><p>如下是示例代码 </p><pre><code class="go">package mainimport (    &quot;github.com/confluentinc/confluent-kafka-go/kafka&quot;)func main() &#123;    producer, err := kafka.NewProducer(&amp;kafka.ConfigMap&#123;&quot;bootstrap.servers&quot;: &quot;localhost&quot;&#125;)    if err != nil &#123;        panic(err)    &#125;    // 生产消息    producer.Produce(&amp;kafka.Message&#123;        TopicPartition: kafka.TopicPartition&#123;Topic: &amp;topic, Partition: kafka.PartitionAny&#125;,        Value:          []byte(&quot;Message Value&quot;),    &#125;, nil)    // 消费消息    consumer, err := kafka.NewConsumer(&amp;kafka.ConfigMap&#123;        &quot;bootstrap.servers&quot;: &quot;localhost&quot;,        &quot;group.id&quot;:          &quot;myGroup&quot;,        &quot;auto.offset.reset&quot;: &quot;earliest&quot;,    &#125;)    consumer.SubscribeTopics([]string&#123;&quot;myTopic&quot;&#125;, nil)    msg, err := consumer.ReadMessage(-1)    if err == nil &#123;        fmt.Printf(&quot;Message on %s: %s\n&quot;, msg.TopicPartition, string(msg.Value))    &#125;&#125;</code></pre><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>云计算是指通过软件自动化管理，提供计算资源的服务网络，是现在互联网大规模数据分析和存储的基石。</p><p>云计算的基础是虚拟化技术和编排方式，关系到资源的分配和调度。</p><p>云计算提供一系列特有的架构：</p><ul><li>基础设施即服务IaaS（Infrastructure as a Service）：服务商提供互联网基础设施，比如用户只需要获得服务器、云硬盘、宽带网络，而不用关心物理的机房、数据中心、网络怎么建设。但是，用户需要自己进行服务器系统安装、环境部署和软件配置。</li><li>平台即服务PaaS（Platform as a Service）：服务商提供底层软件设施，比如为用户准备安装了指定操作系统、数据库软件、环境套件的主机。用户需要自己控制上层应用的部署和托管。</li><li>软件即服务Saas（Software as a Service）：服务商及提供基于软件的解决方案来满足客户的需求，比如用户想要一套OA办公系统，CMS内容管理系统，HRM人事管理系统等，而不用自行搭建和维护这样的服务，能够简化用户的工作。</li><li>函数即服务FaaS（Function as a service）：服务商提供一个平台，允许客户开发、运行和管理应用程序功能，而不用关心如何启动和部署这样的程序。这个模式是“无服务器”体系架构的方式，具有灵活性，适合构建微服务应用程序。</li></ul><h3 id="云原生架构"><a href="#云原生架构" class="headerlink" title="云原生架构"></a>云原生架构</h3><p>云原生技术为公司在公有云、私有云、混合云等新型动态环境中，构建和运行可弹性拓展的应用提供了可能。</p><p>云原生为公司提供了以下关键能力：</p><h3 id="弹性资源调度"><a href="#弹性资源调度" class="headerlink" title="弹性资源调度"></a>弹性资源调度</h3><ul><li>服务资源调度：分配微服务、大服务使用的资源。</li><li>计算资源调度：分配在线计算、离线计算使用的资源</li><li>消息队列：和计算资源调度类似，提供海量的数据吞吐和大数据分析能力。</li></ul><h3 id="弹性存储资源"><a href="#弹性存储资源" class="headerlink" title="弹性存储资源"></a>弹性存储资源</h3><p>云原生让用户可以将存储资源看作服务，寻找对应的服务来满足自己的存储需求。</p><ul><li>经典存储：对象存储、大数据记录存储。</li><li>关系型数据库：业务记录存储。</li><li>元数据：提供服务发现能力</li><li>NoSQL：key-value存储，实现缓存和分布式事务。</li></ul><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>DevOps贯穿整个软件开发周期，使用一系列自动化流程，提高软件开发、交付的效率。DevOps提供了敏捷开发、持续集成&#x2F;交付（CI&#x2F;CD）的能力。</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构实现业务功能单元的解耦，同时提供一套统一的通信标准确保服务之间的数据流通。</p><p>微服务常见的通信标准是HTTP（RESTful API）和RPC（Thrift, gRPC），需要结合性能、服务治理、协议可解释性来选择。实际场景下，常常使用微服务框架提供的通信能力，而不用自己从头实现一套。</p><h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>服务网格实现业务与治理的结构以及异构系统治理的统一化，从而提供复杂的治理能力。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务注册与发现 Eureka或Consul等服务可以用于服务发现。</p><p>服务注册与发现使服务可以动态地找到其他服务的位置。</p><pre><code class="go">// 使用Consul进行服务注册consulConfig := consulapi.DefaultConfig()consulConfig.Address = &quot;localhost:8500&quot;client, err := consulapi.NewClient(consulConfig)if err != nil &#123;    log.Fatal(err)&#125;// 创建新的服务registration := new(consulapi.AgentServiceRegistration)registration.ID = &quot;my-service-id&quot;registration.Name = &quot;my-service&quot;registration.Port = 8080registration.Tags = []string&#123;&quot;my-service&quot;&#125;// 注册服务agent := client.Agent()if err := agent.ServiceRegister(registration); err != nil &#123;    log.Fatal(err)&#125;// 服务发现逻辑...</code></pre><h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>分布式锁</p><p>在分布式环境中，协调多个节点的访问资源可能会变得复杂。分布式锁是一种解决方案，可以在多个节点之间同步访问。</p><p>可以使用Go语言和Redis创建分布式锁：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;github.com/go-redis/redis/v8&quot;    &quot;golang.org/x/net/context&quot;)func main() &#123;    rdb := redis.NewClient(&amp;redis.Options&#123;        Addr: &quot;localhost:6379&quot;,    &#125;)    ctx := context.Background()    lockKey := &quot;lock_key&quot;    // 尝试获取锁    locked, err := rdb.SetNX(ctx, lockKey, &quot;lock_value&quot;, 0).Result()    if err != nil || !locked &#123;        fmt.Println(&quot;获取锁失败&quot;)        return    &#125;    // 执行业务逻辑...    // 释放锁    rdb.Del(ctx, lockKey)    fmt.Println(&quot;业务逻辑执行完毕，锁已释放&quot;)&#125;</code></pre><h2 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h2><h3 id="离在线资源并池"><a href="#离在线资源并池" class="headerlink" title="离在线资源并池"></a>离在线资源并池</h3><p>在线业务以<strong>IO密集型</strong>为主，要求计算的<strong>实时性</strong>，但是具有<strong>潮汐性</strong>，不同时间段的压力不同。离线业务以<strong>计算密集型</strong>为主，对计算实时性不高。</p><p>把在线和离线资源放入同一个资源池进行调度，利用在线业务的潮汐性自动扩缩容，能够有效降低物理资源成本，提供更多的弹性资源，增加收益。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>简单的http负载均衡 轮询算法</p><pre><code class="go">package mainimport (    &quot;net/http&quot;    &quot;net/http/httputil&quot;    &quot;net/url&quot;)var servers = []string&#123;    &quot;http://localhost:8081&quot;,    &quot;http://localhost:8082&quot;,&#125;var currentServer = 0func nextServer() string &#123;    server := servers[currentServer]    currentServer = (currentServer + 1) % len(servers)    return server&#125;func main() &#123;    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;        server := nextServer()        target, _ := url.Parse(server)        proxy := httputil.NewSingleHostReverseProxy(target)        proxy.ServeHTTP(w, r)    &#125;)    http.ListenAndServe(&quot;:8080&quot;, nil)&#125;</code></pre><h3 id="亲和性部署"><a href="#亲和性部署" class="headerlink" title="亲和性部署"></a>亲和性部署</h3><p>如果两个微服务之间通信密切，则这两个服务的亲和性较高。将满足亲和性条件的容器调度到一台宿主机，让微服务中间件与服务网格通过共享内存通信，能够有效降低通信成本，提高服务可用性。</p><h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><p>基于微服务中间件和服务网格的流量治理，赋予微服务熔断、重试的能力，提供复杂环境下的流量调度，可以提高微服务调用容错性，增强容灾能力，还能进一步提高开发效率。</p><h3 id="CPU水位负载均衡"><a href="#CPU水位负载均衡" class="headerlink" title="CPU水位负载均衡"></a>CPU水位负载均衡</h3><p>结合IaaS提供的资源探针和服务网格的负载均衡能力，能够为自动扩缩容提供反馈，打平异构环境下算力的差异。</p><h3 id="容器化与服务编排"><a href="#容器化与服务编排" class="headerlink" title="容器化与服务编排"></a>容器化与服务编排</h3><p>Docker</p><p>可以使用Docker将Go应用程序打包到容器中，并确保它在任何支持Docker的平台上以相同的方式运行。</p><p>Kubernetes</p><p>Kubernetes是一种强大的容器编排工具，用于自动部署、扩展和管理容器化应用程序。Go语言是Kubernetes的主要实现语言。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现代软件架构的复杂性和灵活性要求了解许多概念和技术。从单机到分布式，从单体到微服务，架构演化为满足不断增长的需求。</p><p>通过使用强大和灵活的编程语言，如Go，您可以构建符合这些需求的解决方案。从分布式锁到服务发现，从负载均衡到微服务通信，Go为构建现代、可扩展和高性能的系统提供了强大的工具和库。</p><p>不断学习和实践这些概念和技术将使您更好地设计和构建复杂的系统，满足业务目标，并应对未来的挑战。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/08/24/go%E6%9E%B6%E6%9E%84%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>gorm 初体验 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/08/23/gorm%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/08/23/gorm%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 23 Aug 2023 13:50:26 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;gorm&quot;&gt;&lt;a href=&quot;#gorm&quot; class=&quot;headerlink&quot; title=&quot;gorm&quot;&gt;&lt;/a&gt;gorm&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gorm.io/gorm.svg&quot;&gt;&lt;/p&gt;
&lt;p&gt;gorm是Golang语言中一款性能</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h2><p><img src="https://gorm.io/gorm.svg"></p><p>gorm是Golang语言中一款性能极好的ORM库，对开发人员相对是比较友好的。接下来主要学习下gorm库的一些基本使用。</p><p>功能概览</p><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 Preload、Joins 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context、预编译模式、DryRun 模式</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询<br>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装</p><pre><code class="bash">go get -u gorm.io/gormgo get -u gorm.io/driver/sqlite</code></pre><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>因为orm可以自动创建数据库，创建表，所以我们要用一个约定的形式来描述一个schema，便于他创建表，也便于代码中调用</p><p>例如</p><pre><code class="go">type User struct &#123;  Name         string  Email        string  Age          uint8&#125;</code></pre><p>这样的一个结构体就可以描述user这个表</p><h4 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h4><pre><code class="go">// gorm.Model 的定义type Model struct &#123;  ID        uint           `gorm:&quot;primaryKey&quot;`  CreatedAt time.Time  UpdatedAt time.Time  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`&#125;</code></pre><p>这个约定了一些gorm的标准配置，相当于implement了这个结构体</p><p>例如</p><pre><code class="go">type User struct &#123;  gorm.Model  Name         string  Email        string  Age          uint8&#125;</code></pre><p>这样这个gorm.Model相当于在user表里添加了一些基础的字段</p><p>这个user最终会变成 相当于</p><pre><code class="go">type User struct &#123;  ID        uint           `gorm:&quot;primaryKey&quot;`  CreatedAt time.Time  UpdatedAt time.Time  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`  Name         string  Email        string  Age          uint8&#125;</code></pre><h4 id="嵌入结构体"><a href="#嵌入结构体" class="headerlink" title="嵌入结构体"></a>嵌入结构体</h4><p>如上的gorm.Model就是一种嵌入结构体</p><p>官网的解释是：对于匿名字段，GORM 会将其字段包含在父结构体中</p><p>其他嵌入方法为：</p><p>对于正常的结构体字段，你也可以通过标签 embedded 将其嵌入，例如：</p><pre><code class="go">type Author struct &#123;    Name  string    Email string&#125;type Blog struct &#123;  ID      int  Author  Author `gorm:&quot;embedded&quot;`  Upvotes int32&#125;</code></pre><pre><code class="go">// 它等效于type Blog struct &#123;  ID    int64  Name  string  Email string  Upvotes  int32&#125;</code></pre><blockquote><p>可以使用标签 embeddedPrefix 来为 db 中的字段名添加前缀<br>Author  Author &#96;gorm:”embedded;embeddedPrefix:author_”</p></blockquote><h4 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h4><p>声明 model 时，tag 是可选的，gorm 支持以下这些 tag： tag 名大小写不敏感，但我们写的时候最好用驼峰命名法。</p><p>写法为 在字段后面添加飘号和gorm:</p><p>例如</p><pre>ID        uint           `gorm:"primaryKey"`</pre><table><thead><tr><th align="left">标签名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 database 的列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td align="left">serializer</td><td align="left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td align="left">size</td><td align="left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td align="left">primaryKey</td><td align="left">将列定义为主键</td></tr><tr><td align="left">unique</td><td align="left">将列定义为唯一键</td></tr><tr><td align="left">default</td><td align="left">定义列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">scale</td><td align="left">指定列大小</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">autoIncrementIncrement</td><td align="left">自动步长，控制连续记录之间的间隔</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌入字段的列名前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">创建&#x2F;更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td align="left">-</td><td align="left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td align="left">comment</td><td align="left">迁移时为字段添加注释</td></tr></tbody></table><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>官方提供的代码</p><pre><code class="go">import (  &quot;gorm.io/driver/mysql&quot;  &quot;gorm.io/gorm&quot;)func main() &#123;  // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情  dsn := &quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)&#125;</code></pre><p>这里我提供一种封装方案，因为一般数据库配置写在配置文件里，防止泄露与主代码分离‘</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;gorm.io/driver/mysql&quot;    &quot;gorm.io/gorm&quot;    &quot;gorm.io/gorm/schema&quot;)type Config struct &#123;    // 数据库配置    DBList DBListConf&#125;type DBListConf struct &#123;    Mysql MysqlConf&#125;type MysqlConf struct &#123;    Address     string    Username    string    Password    string    DBName      string    TablePrefix string&#125;type ServiceContext struct &#123;    Config Config    DBList *DBList&#125;type DBList struct &#123;    Mysql *gorm.DB&#125;func NewServiceContext(c Config) *ServiceContext &#123;    return &amp;ServiceContext&#123;        Config: c,        DBList: initDB(c),    &#125;&#125;func initDB(c Config) *DBList &#123;    dbList := new(DBList)    dbList.Mysql = initMysql(c)    return dbList&#125;func initMysql(c Config) *gorm.DB &#123;    dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;,        c.DBList.Mysql.Username,        c.DBList.Mysql.Password,        c.DBList.Mysql.Address,        c.DBList.Mysql.DBName,    )    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;        NamingStrategy: schema.NamingStrategy&#123;            TablePrefix:   c.DBList.Mysql.TablePrefix, // 表名前缀            SingularTable: true,                       // 使用单数表名        &#125;,        DisableForeignKeyConstraintWhenMigrating: true,    &#125;)    if err != nil &#123;        panic(err)    &#125;    // 自动建表    err = db.AutoMigrate(&amp;model.Video&#123;&#125;, &amp;model.Favorite&#123;&#125;, &amp;model.Comment&#123;&#125;)    if err != nil &#123;        panic(err)    &#125;    return db&#125;func main() &#123;    // 创建配置实例    config := Config&#123;        DBList: DBListConf&#123;            Mysql: MysqlConf&#123;                Address:     &quot;Address&quot;,                Username:    &quot;root&quot;,                Password:    &quot;1111111111111&quot;,                DBName:      &quot;dbname&quot;,                TablePrefix: &quot;Prefix&quot;,            &#125;,        &#125;,    &#125;    // 创建服务上下文    serviceContext := NewServiceContext(config)        // 在这里你可以使用 serviceContext 进行操作    // ...    fmt.Println(&quot;Database initialization and configuration completed.&quot;)&#125;</code></pre><p>这里出现了自动建表的操作AutoMigrate 你需要把你想要创建的模型传进来自动建表</p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="1-C"><a href="#1-C" class="headerlink" title="1. C"></a>1. C</h3><p>接下来开始 crud,</p><p>假如你有一个user表，可以使用create创建多个数据</p><pre><code class="go">users := []*User&#123;    User&#123;Name: &quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;,    User&#123;Name: &quot;Jackson&quot;, Age: 19, Birthday: time.Now()&#125;,&#125;result := db.Create(users) // pass a slice to insert multiple rowresult.Error        // returns errorresult.RowsAffected // returns inserted records count</code></pre><p>Error相信你会接</p><pre><code class="go">if result.Error != nil &#123;    return exit&#125;</code></pre><p>或者可以直接在create里</p><pre><code class="go">err := db.create().Errorif err != nil &#123;    return exit&#125;</code></pre><h3 id="2-R"><a href="#2-R" class="headerlink" title="2.R"></a>2.R</h3><p>根据主键检索</p><pre><code class="go">db.First(&amp;user, 10)// SELECT * FROM users WHERE id = 10;db.First(&amp;user, &quot;10&quot;)// SELECT * FROM users WHERE id = 10;db.Find(&amp;users, []int&#123;1,2,3&#125;)// SELECT * FROM users WHERE id IN (1,2,3);</code></pre><p>这里的first为检索第一个 limit为1</p><p>检索全部对象</p><pre><code class="go">// Get all recordsresult := db.Find(&amp;users)// SELECT * FROM users;result.RowsAffected // returns found records count, equals `len(users)`result.Error        // returns error</code></pre><p>条件检索</p><p>这样相当于拼sql语句</p><pre><code class="go">// Get first matched recorddb.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user)// SELECT * FROM users WHERE name = &#39;jinzhu&#39; ORDER BY id LIMIT 1;// Get all matched recordsdb.Where(&quot;name &lt;&gt; ?&quot;, &quot;jinzhu&quot;).Find(&amp;users)// SELECT * FROM users WHERE name &lt;&gt; &#39;jinzhu&#39;;// INdb.Where(&quot;name IN ?&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;).Find(&amp;users)// SELECT * FROM users WHERE name IN (&#39;jinzhu&#39;,&#39;jinzhu 2&#39;);// LIKEdb.Where(&quot;name LIKE ?&quot;, &quot;%jin%&quot;).Find(&amp;users)// SELECT * FROM users WHERE name LIKE &#39;%jin%&#39;;// ANDdb.Where(&quot;name = ? AND age &gt;= ?&quot;, &quot;jinzhu&quot;, &quot;22&quot;).Find(&amp;users)// SELECT * FROM users WHERE name = &#39;jinzhu&#39; AND age &gt;= 22;// Timedb.Where(&quot;updated_at &gt; ?&quot;, lastWeek).Find(&amp;users)// SELECT * FROM users WHERE updated_at &gt; &#39;2000-01-01 00:00:00&#39;;// BETWEENdb.Where(&quot;created_at BETWEEN ? AND ?&quot;, lastWeek, today).Find(&amp;users)// SELECT * FROM users WHERE created_at BETWEEN &#39;2000-01-01 00:00:00&#39; AND &#39;2000-01-08 00:00:00&#39;;</code></pre><p>高级查询 <a href="https://gorm.io/zh_CN/docs/advanced_query.html">https://gorm.io/zh_CN/docs/advanced_query.html</a></p><h3 id="3-U"><a href="#3-U" class="headerlink" title="3.U"></a>3.U</h3><p>更新 所有字段</p><pre><code class="go">db.Save(&amp;User&#123;Name: &quot;jinzhu&quot;, Age: 100&#125;)// INSERT INTO `users` (`name`,`age`,`birthday`,`update_at`) VALUES (&quot;jinzhu&quot;,100,&quot;0000-00-00 00:00:00&quot;,&quot;0000-00-00 00:00:00&quot;)db.Save(&amp;User&#123;ID: 1, Name: &quot;jinzhu&quot;, Age: 100&#125;)// UPDATE `users` SET `name`=&quot;jinzhu&quot;,`age`=100,`birthday`=&quot;0000-00-00 00:00:00&quot;,`update_at`=&quot;0000-00-00 00:00:00&quot; WHERE `id` = 1</code></pre><p>更多更新方法 <a href="https://gorm.io/zh_CN/docs/update.html">https://gorm.io/zh_CN/docs/update.html</a></p><h3 id="4-D"><a href="#4-D" class="headerlink" title="4.D"></a>4.D</h3><p>删除一条记录 </p><pre><code class="go">// Email 的 ID 是 `10`db.Delete(&amp;email)// DELETE from emails where id = 10;// 带额外条件的删除db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Delete(&amp;email)// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</code></pre><p>更多删除方法 <a href="https://gorm.io/zh_CN/docs/delete.html">https://gorm.io/zh_CN/docs/delete.html</a></p><p>其中的软删除感觉很有用</p><blockquote><p>当调用Delete时，GORM并不会从数据库中删除该记录，而是将该记录的DeleteAt设置为当前时间，而后的一般查询方法将无法查找到此条记录。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>gorm是个很好用的go的orm框架，对很多数据库都兼容</p><p>性能也很好，操作起来也很简单。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/08/23/gorm%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>go语言三个小项目 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/07/25/go%E8%AF%AD%E8%A8%80%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/07/25/go%E8%AF%AD%E8%A8%80%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 25 Jul 2023 11:59:09 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;猜数字&quot;&gt;&lt;a href=&quot;#猜数字&quot; class=&quot;headerlink&quot; title=&quot;猜数字&quot;&gt;&lt;/a&gt;猜数字&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;猜数字&lt;br&gt;这个项目非常简单，它涉及到随机数的生成和用户输入操作。&lt;br&gt;我们使用了bufio库来处理输入数据。&lt;/l</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><ol><li>猜数字<br>这个项目非常简单，它涉及到随机数的生成和用户输入操作。<br>我们使用了bufio库来处理输入数据。</li></ol><pre><code class="go">reader := bufio.NewReader(os.Stdin)input, _ := reader.ReadString(&#39;\n&#39;)</code></pre><h2 id="简单字典"><a href="#简单字典" class="headerlink" title="简单字典"></a>简单字典</h2><ol start="2"><li>标准库strconv<br>它主要用于字符和其他类型之间的转换。</li></ol><pre><code class="go">strconv.Atoi(s string) int </code></pre><ol start="3"><li>标准库strings</li></ol><pre><code class="go">strings.TrimSuffix(s string ,  suffix string) string</code></pre><p>删除末尾字符，如果没有就正常返回</p><ol start="4"><li>网络库</li></ol><pre><code class="go">client := &amp;http.Client&#123;&#125;</code></pre><p>初始化请求客户端</p><pre><code class="go">req,  err := http.NewRequest(&quot;POST&quot;, &quot;https://api.interpreter.caiyunai.com/v1/dict&quot;,  data)</code></pre><p>构造头</p><pre><code class="go">req.Header.Set(&quot;authority&quot;,  &quot;api.interpreter.caiyunai.com&quot;)</code></pre><p>请求</p><pre><code class="go">bodyText,  err := io.ReadAll(resp.Body)err = json.Unmarshal(bodyText,  &amp;dictResponse)</code></pre><ol start="5"><li>os库</li></ol><pre><code class="go">word := os.Args[1]</code></pre><p>获取环境参数</p><h2 id="socks5代理"><a href="#socks5代理" class="headerlink" title="socks5代理"></a>socks5代理</h2><pre><code class="go">package mainimport (    &quot;context&quot;    &quot;encoding/binary&quot;    &quot;fmt&quot;    &quot;io&quot;    &quot;net&quot;)const (    socks5Ver  = 0x05    atypeIPV4  = 0x01    atypeHOST  = 0x03    cmdConnect = 0x01)func main() &#123;    // 假设在这里建立一个 net.Listener 监听 Socks5 代理请求    for &#123;        client, err := acceptConnection()        if err != nil &#123;            continue        &#125;        // 开启一个 goroutine 处理客户端请求        go handleSocks5Client(client)    &#125;&#125;func acceptConnection() (net.Conn, error) &#123;    // 实现接收连接请求的逻辑&#125;func handleSocks5Client(conn net.Conn) &#123;    defer conn.Close()    // 鉴权阶段    if err := auth(conn); err != nil &#123;        fmt.Println(&quot;Authentication error:&quot;, err)        return    &#125;    // 通讯阶段    addr, err := connect(conn)    if err != nil &#123;        fmt.Println(&quot;Connection error:&quot;, err)        return    &#125;    // 给客户端回包，表示连接成功    _, _ = conn.Write([]byte&#123;socks5Ver, 0x00, 0x00, atypeIPV4, 0, 0, 0, 0, 0, 0&#125;)    // 开始进行数据转发    dest, err := net.Dial(&quot;tcp&quot;, addr)    if err != nil &#123;        fmt.Println(&quot;Failed to connect to destination:&quot;, err)        return    &#125;    defer dest.Close()    ctx, cancel := context.WithCancel(context.Background())    defer cancel()    // 从客户端到目标地址的数据拷贝    go func() &#123;        _, _ = io.Copy(dest, conn)        cancel()    &#125;()    // 从目标地址到客户端的数据拷贝    go func() &#123;        _, _ = io.Copy(conn, dest)        cancel()    &#125;()    &lt;-ctx.Done()&#125;func auth(conn net.Conn) error &#123;    buf := make([]byte, 2)    _, err := io.ReadFull(conn, buf)    if err != nil &#123;        return err    &#125;    ver, nmethods := buf[0], buf[1]    methods := make([]byte, nmethods)    _, err = io.ReadFull(conn, methods)    if err != nil &#123;        return err    &#125;    // 在这里根据收到的 methods 进行认证处理    // 假设这里选择不需要认证，回包告知客户端不需要认证    _, err = conn.Write([]byte&#123;socks5Ver, 0x00&#125;)    if err != nil &#123;        return err    &#125;    return nil&#125;func connect(conn net.Conn) (string, error) &#123;    buf := make([]byte, 4)    _, err := io.ReadFull(conn, buf)    if err != nil &#123;        return &quot;&quot;, err    &#125;    ver, cmd, _, atyp := buf[0], buf[1], buf[2], buf[3]    if ver != socks5Ver || cmd != cmdConnect &#123;        return &quot;&quot;, fmt.Errorf(&quot;Unsupported SOCKS5 command&quot;)    &#125;    var addr string    switch atyp &#123;    case atypeIPV4:        buf := make([]byte, 4)        _, err := io.ReadFull(conn, buf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        addr = fmt.Sprintf(&quot;%d.%d.%d.%d&quot;, buf[0], buf[1], buf[2], buf[3])    case atypeHOST:        hostSizeBuf := make([]byte, 1)        _, err := io.ReadFull(conn, hostSizeBuf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        hostSize := int(hostSizeBuf[0])        hostBuf := make([]byte, hostSize)        _, err = io.ReadFull(conn, hostBuf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        addr = string(hostBuf)    &#125;    portBuf := make([]byte, 2)    _, err = io.ReadFull(conn, portBuf)    if err != nil &#123;        return &quot;&quot;, err    &#125;    port := binary.BigEndian.Uint16(portBuf)    return fmt.Sprintf(&quot;%v:%v&quot;, addr, port), nil&#125;</code></pre><p>使用 SOCKS5 代理的实现，涵盖了以下主要步骤：</p><p>鉴权阶段：</p><p>解析客户端发送的版本号、支持的认证方法数量和认证方法列表。<br>针对支持的认证方法进行验证，返回认证成功的回包。<br>通讯阶段：</p><p>解析客户端发送的连接请求，包括版本号、命令类型、目标地址类型、目标地址、目标端口等信息。<br>根据目标地址类型和地址解析方式，获取目标地址和端口号。<br>向目标地址发起连接请求，并返回连接成功的回包。<br>进程管理：</p><p>使用 goroutine 后台开启两个服务器交互进程。<br>通过 context 库进行进程管理，确保进程在必要时可以被关闭。<br>将客户端和目标之间的数据互相拷贝，使得数据能够在两者之间传递。</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>在这节课学习的内容中，我收获了很多关于Go语言编程的知识和技能。以下是我的感想：</p><p>Go语言的简洁和高效：通过学习这些基础标准库和相关功能，我深刻感受到Go语言的简洁和高效。标准库提供了丰富的功能，让编程变得更加简单和高效。</p><p>数据类型转换和字符串处理：学习了strconv和strings包，对于数据类型转换和字符串处理有了更深入的了解。这些工具使得在处理用户输入和数据转换时更加方便。</p><p>网络编程和HTTP库：了解了Go语言中的网络编程和net&#x2F;http包，我现在能够编写简单的HTTP服务器和客户端，这对于开发网络应用和服务端程序非常有用。</p><p>文件操作和系统交互：通过os包的学习，我学会了如何在Go语言中进行文件操作和与操作系统进行交互，这对于处理文件和系统配置十分重要。</p><p>代理和鉴权：学习了socks5代理和鉴权机制，我对网络代理和安全认证有了更深刻的理解，这对于开发安全性较高的应用非常重要。</p><p>上下文处理：context包的学习使我了解了在Go语言中如何优雅地处理请求上下文，更好地控制请求的流程和生命周期。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/07/25/go%E8%AF%AD%E8%A8%80%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LINUX 挑战：用户和组管理</title>
      <link>https://xyxsw.ltd/2023/05/08/%E6%8C%91%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</link>
      <guid>https://xyxsw.ltd/2023/05/08/%E6%8C%91%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</guid>
      <pubDate>Mon, 08 May 2023 12:26:21 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;LINUX-挑战：用户和组管理&quot;&gt;&lt;a href=&quot;#LINUX-挑战：用户和组管理&quot; class=&quot;headerlink&quot; title=&quot;LINUX 挑战：用户和组管理&quot;&gt;&lt;/a&gt;LINUX 挑战：用户和组管理&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="LINUX-挑战：用户和组管理"><a href="#LINUX-挑战：用户和组管理" class="headerlink" title="LINUX 挑战：用户和组管理"></a>LINUX 挑战：用户和组管理</h1><ol><li></li></ol><pre><code>wget https://labfile.oss.aliyuncs.com/courses/2585/06.tar.gztar -xzf 06.tar.gzchmod 700 ./06.sh./06.sh</code></pre><ol start="2"><li></li></ol><pre><code>sudo userdel guest2sudo userdel guest3sudo userdel guest4sudo userdel guest5sudo rm -rf /home/guest2sudo rm -rf /home/guest3sudo rm -rf /home/guest4sudo rm -rf /home/guest5sudo groupadd guestmkdir /tmp/tempusersudo usermod -u 2000 -g guest -d /tmp/tempuser guest1 </code></pre><ol start="3"><li></li></ol><pre><code>sudo mkdir /home/vsftpdusersudo useradd vsftpduser -d /home/vsftpduser -s /usr/sbin/nologin sudo chown vsftpduser /home/vsftpdusersudo chgrp vsftpduser /home/vsftpdusersudo chmod 744 /home/vsftpduser</code></pre><ol start="4"><li></li></ol><pre><code>sudo useradd magsudo useradd devsudo useradd testsudo mkdir /srv/projectx/magsudo mkdir /srv/projectx/devsudo mkdir /srv/projectx/testsudo usermod -G dev magsudo chown dev:dev /srv/projectxsudo chmod 751 /srv/projectxsudo chmod o+rx /srv/projectx/devsudo chmod o+rx /srv/projectx/test</code></pre><ol start="5"><li></li></ol><pre><code>cat /etc/passwd | grep bash | cut -d &#39;:&#39; -f 1,3 &gt; users.txt</code></pre><ol start="6"><li></li></ol><pre><code>sudo useradd stusudo passwd stu123456123456sudo visudo:21# 按i往里写stu ALL=(shiyanlou:shiyanlou) /bin/touch# 退出按:wq</code></pre><ol start="7"><li></li></ol><pre><code>sudo passwd dev123456123456sudo touch /etc/sudoers.d/devsudo chmod 777 /etc/sudoers.d/devvim /etc/sudoers.d/dev# 按i往里写dev  ALL=(root:root) /usr/sbin/useradd# 退出按:wq</code></pre>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/Linux%E5%AE%9E%E9%AA%8C/">Linux实验</category>
      
      
      <comments>https://xyxsw.ltd/2023/05/08/%E6%8C%91%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Web 开发安全 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/02/08/Web%20%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/02/08/Web%20%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 08 Feb 2023 02:51:11 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 17 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;课程重点&quot;&gt;&lt;a href=&quot;#课程重点&quot; class=&quot;headerlink&quot; title=&quot;课程重点&quot;&gt;&lt;/a&gt;课程重点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 17 天</strong></p><h2 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h2><ul><li><p>Web 相关的攻击介绍</p></li><li><p>Web 相关的防御介绍</p></li></ul><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="XSS-Cross-Site-Scripting"><a href="#XSS-Cross-Site-Scripting" class="headerlink" title="XSS (Cross-Site Scripting)"></a>XSS (Cross-Site Scripting)</h3><p>主要是由于盲目信任用户输入，直接将用户输入渲染出来，导致了攻击脚本的植入</p><p>特点：</p><ol><li>通常难以从 UI 上感知</li><li>窃取用户信息，例如 cookie 和 token</li></ol><p>常见的会导致XSS的代码：</p><pre><code>document.writeel.innerHTML = anyString</code></pre><p>总结来说，所有能够渲染dom结构的函数，都有可能导致XSS攻击。</p><p>比如论坛场景中，<strong>用户提交的内容包含恶意script标签</strong></p><pre><code class="js">fetch(&quot;/submit&quot;, &#123;    body: JSON.stringify(&#123;        id: &quot;1&quot;,        content: `&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;`    &#125;)&#125;)</code></pre><p>导致代码被插入到帖子中，所有用户访问页面都会执行恶意脚本</p><p>XSS 能够分成下面四类</p><p><code>Stored XSS</code> 直接将恶意脚本储存到了数据库中，导致之后的所有访问均会携带恶意脚本，危害很大</p><pre><code>Reflected XSS` 反射型，不储存数据，仅仅从URL传入脚本导致攻击，例如 `/path?param=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p><code>DOM-based XSS</code> 不由服务器参与，攻击的发起和执行都在浏览器，常见于前端框架中</p><p><code>Mutation-based XSS</code> 利用浏览器的特性，不同浏览器会有区别，例如</p><pre><code>&lt;noscript&gt;&lt;p title=&quot;&lt;/noscript&gt;&lt;img src=x onerror=alert(1)&gt;&quot;&gt;</code></pre><h3 id="CSRF-Cross-site-request-forgery"><a href="#CSRF-Cross-site-request-forgery" class="headerlink" title="CSRF (Cross-site request forgery)"></a>CSRF (Cross-site request forgery)</h3><p>特点：</p><ol><li>在用户不知情的前提下</li><li>利用用户权限（cookie）</li><li>构造指定HTTP请求，窃取或修改用户敏感信息</li></ol><p>例子：</p><p>用户没有访问银行网页，但是访问了一个带有攻击内容的网页，该网页尝试请求银行接口，由于用户登录过银行，接口携带cookie，导致请求成功，使得用户受到损失。</p><h3 id="SQL-注入-SQL-Injection"><a href="#SQL-注入-SQL-Injection" class="headerlink" title="SQL 注入 (SQL Injection)"></a>SQL 注入 (SQL Injection)</h3><p>在请求参数中构造恶意字符串，拼接SQL语句，导致服务器执行了特定的SQL语句，造成数据库内容泄露</p><p>例子：</p><pre><code class="js">sql.query(`    SELECT a, b, c FROM table    WHERE username = $&#123;username&#125;    AND form_id = $&#123;form_id&#125;`)</code></pre><p>上面的这段后端代码，攻击者就能够通过构造特殊的 username 或 form_id，使得SQL语句的意义被改变</p><p>例如传入 form_id &#x3D; <code>any; DROP TABLE table;</code></p><p>SQL 语句拼接后变成 <code>SELECT a,b,c FROM table WHERE xxxx AND form_id = any; DROP TABLE table;</code></p><p>将导致数据库被删除</p><h3 id="SSRF-Server-Side-Request-Forgery"><a href="#SSRF-Server-Side-Request-Forgery" class="headerlink" title="SSRF (Server-Side Request Forgery)"></a>SSRF (Server-Side Request Forgery)</h3><p>服务端伪造请求</p><p>例子：</p><pre><code>ctx.body = await fetch(ctx.query.callback)</code></pre><p>导致能够通过传入的参数访问到服务器内网的相关服务</p><h3 id="DoS-Denial-of-Service"><a href="#DoS-Denial-of-Service" class="headerlink" title="DoS (Denial of Service)"></a>DoS (Denial of Service)</h3><p><code>「 不搞复杂的 ， 量大就完事儿了 」</code></p><p>通过构造特定请求，导致服务器资源被消耗，来不及响应更多请求，引发雪崩效应</p><p>例如：</p><ol><li>耗时的同步操作</li><li>文件备份</li><li>数据库写入</li><li>SQL join</li><li>循环执行逻辑</li></ol><h4 id="DDoS-Distributed-DoS"><a href="#DDoS-Distributed-DoS" class="headerlink" title="DDoS (Distributed DoS)"></a>DDoS (Distributed DoS)</h4><p>攻击特点</p><ul><li>直接访问 IP</li><li>任意 API</li><li>消耗大量带宽 （ 耗尽 ）</li></ul><p>SYN Flood</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>安全无小事<br>使用的依赖 npm package，甚至是 NodeJS 可能成为最薄弱的一环</p><ul><li>保持学习心态<br>npm install 除了带来了果洞 ， 还可以带来漏洞</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://bytedance.feishu.cn/file/boxcn9L4YzmTK3mwE3tIBL2UVme">https://bytedance.feishu.cn/file/boxcn9L4YzmTK3mwE3tIBL2UVme</a></p><p><a href="https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065">https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/02/08/Web%20%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NextJs ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/02/01/NextJS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/02/01/NextJS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 01 Feb 2023 06:54:49 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 16 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、本堂课重点内容：&quot;&gt;&lt;a href=&quot;#一、本堂课重点内容：&quot; class=&quot;headerlink&quot; title=&quot;一、本堂课重点内容：&quot;&gt;&lt;/a&gt;一、本</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 16 天</strong></p><h2 id="一、本堂课重点内容："><a href="#一、本堂课重点内容：" class="headerlink" title="一、本堂课重点内容："></a>一、本堂课重点内容：</h2><ol><li>CSR, SSR, SSG</li><li>什么是 Next.js</li><li>Next.js 客户端开发</li><li>Next.js服务端开发</li><li>核心功能</li></ol><h2 id="二、详细知识点介绍："><a href="#二、详细知识点介绍：" class="headerlink" title="二、详细知识点介绍："></a>二、详细知识点介绍：</h2><h3 id="1-CSR-SSR-SSG"><a href="#1-CSR-SSR-SSG" class="headerlink" title="1. CSR, SSR, SSG"></a>1. CSR, SSR, SSG</h3><h4 id="1-CSR（客户端渲染-Client-Side-Render）"><a href="#1-CSR（客户端渲染-Client-Side-Render）" class="headerlink" title="1. CSR（客户端渲染 Client Side Render）"></a>1. CSR（客户端渲染 Client Side Render）</h4><p>即在客户端渲染网页结构，一般情况下我们所熟知的 Vue、React 均采用这种模式。在构建时并不会生成HTML结构，仅仅包含js代码的引用。在浏览器端将HTML结构渲染出来。客户端渲染会在项目体积较大的时候可能会导致较长的首屏加载时间，用户体验不好，且对于SSO来说并不友好。</p><h4 id="2-SSR（服务端渲染-Server-Side-Render）"><a href="#2-SSR（服务端渲染-Server-Side-Render）" class="headerlink" title="2. SSR（服务端渲染 Server Side Render）"></a>2. SSR（服务端渲染 Server Side Render）</h4><p>浏览器请求时，服务器直接生成HTML结构并返回，这种模式其实并不少见，曾经的<code>php</code>和<code>jsp</code>都是这种模式。<code>Vue</code> 和 <code>React</code> 也对这种模式进行了支持，例如 React 下有 <code>Vercel</code> 主导的 <code>Next.js</code> 框架支持服务端渲染，Vue 下也有类似的框架 Nuxt.js。与前者的区别是，<code>php</code>和<code>jsp</code>的前后端代码实际上仍是分离的，需要动态交互的部分还是需要<code>js</code>介入。而<code>React</code>和<code>Vue</code>在服务端和客户端都是同一套代码，这也就导致其比前者多了一步水合 <code>hydrate</code> (也称注水) 的操作。</p><p>在这种模式下，服务端在生成HTML的同时对其进行“脱水”，即将渲染结构的初始数据分离出来，单独储存，以便让前端读取。在浏览器收到页面后，相关的代码读取这部分内容，再对html结构进行“注水”（水合），使得服务端和客户端的数据同步，且浏览器端的元素能够正常交互。</p><p>比起CSR，SSR能够大幅缩短首屏加载的时间，且对于SSO友好，但是需要服务器支持。</p><h4 id="3-SSG（静态网页生成-Static-Site-Generation）"><a href="#3-SSG（静态网页生成-Static-Site-Generation）" class="headerlink" title="3. SSG（静态网页生成 Static Site Generation）"></a>3. SSG（静态网页生成 Static Site Generation）</h4><p>这种形式实际上和SSR类似，但是无需运行一个服务端，HTML结构在构建时就已经创建完了，用户访问时，仍然是个静态页，却具有SSR首屏加载时间短的优势，适合那些修改不频繁的站点，例如一些开发文档。</p><h3 id="2-什么是-Next-js"><a href="#2-什么是-Next-js" class="headerlink" title="2.什么是 Next.js"></a>2.什么是 Next.js</h3><p>基于 React 提供的相关服务器端渲染 API 实现 ， 整个过程实现比较繁琐重复 ， 从零实现对新上手同学很不友好迫切需要一个封装好的集合来快速上手服务器端渲染。</p><p>Next.js是一个构建于 Node.js之上的开源 we b 开发框架 ，支持基于 React 的 web 应用程序功能 ， 例如服务端渲染和生成静态网站 。上手快 ， 能力集全 ， 覆盖了足够多的性能优化。</p><p>对于新同学掌握前后端一体化的开发模式很友好 。</p><h3 id="3-Next-js-客户端开发"><a href="#3-Next-js-客户端开发" class="headerlink" title="3. Next.js 客户端开发"></a>3. Next.js 客户端开发</h3><ol><li>Next.js 初始化</li><li>数据注入</li><li><code>getlnitiaIProps</code></li><li><code>getServerSideProps</code></li><li><code>getStaticProps</code></li><li>CSS Modules</li><li>Layout</li><li>文件式路由</li><li>B F F 层的文件式路由</li><li>路由跳转</li><li>header 的修改</li><li>多媒体适配—— CSS 适配</li><li>多媒体适配—— JS 适配</li><li>大图优化—— webp</li></ol><h3 id="4-Next-js服务端开发"><a href="#4-Next-js服务端开发" class="headerlink" title="4. Next.js服务端开发"></a>4. Next.js服务端开发</h3><ol><li>BFF 层开发</li><li>调试方式</li><li>Strapi —— headless CMS</li></ol><h3 id="5-核心功能"><a href="#5-核心功能" class="headerlink" title="5. 核心功能"></a>5. 核心功能</h3><h4 id="首页功能实现"><a href="#首页功能实现" class="headerlink" title="首页功能实现"></a>首页功能实现</h4><ol><li>页面 &amp; 动画 &amp; 多媒体适配</li><li>BFF</li><li>Strapi</li></ol><h4 id="文章页实现"><a href="#文章页实现" class="headerlink" title="文章页实现"></a>文章页实现</h4><ol><li>页面 &amp; 动画 &amp; 多媒体适配</li><li>BFF</li><li>Strapi 分页</li><li>多媒体格式的转换<ul><li>markdown 转 html</li><li>html 转 dom</li><li>公共样式的定义</li></ul></li></ol><h4 id="主题化功能实现"><a href="#主题化功能实现" class="headerlink" title="主题化功能实现"></a>主题化功能实现</h4><ol><li>基础样式和背景的抽离</li><li>主题化 <code>context</code> 全局注入</li><li>从注入数据中取出 <code>theme</code> 和 <code>setTheme</code></li><li>多进程间的主题同步</li></ol><h2 id="三、实践练习例子："><a href="#三、实践练习例子：" class="headerlink" title="三、实践练习例子："></a>三、实践练习例子：</h2><h3 id="思考题-：-http-localhost-3000-和-http-127-0-0-1-3000-主题可以共享吗"><a href="#思考题-：-http-localhost-3000-和-http-127-0-0-1-3000-主题可以共享吗" class="headerlink" title="思考题 ： http://localhost:3000 和 http://127.0.0.1:3000 主题可以共享吗"></a>思考题 ： <a href="http://localhost:3000/">http://localhost:3000</a> 和 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 主题可以共享吗</h3><p>答案是<strong>不能</strong></p><p>如果存在<code>localstorage</code>里</p><p>那么这俩域名不是同域名</p><p>不会共享</p><h3 id="初始化-Next-js-项目"><a href="#初始化-Next-js-项目" class="headerlink" title="初始化 Next.js 项目"></a>初始化 Next.js 项目</h3><p>Next.js 提供了一个脚手架，直接就能够创建项目</p><pre><code class="bash">npx create-next-app@latest --typescript</code></pre><p>接下来就能够看到创建完成的项目目录了。可能会有下面这些文件</p><p><code>.eslintrc.json</code> - eslint 的配置文件，配置了eslint使用的语法规则</p><p><code>.gitignore</code> - git 仓库的忽略文件</p><p><code>next-env.d.ts</code> - TypeScript 的类型定义，是为了方便引入Next声明的类型</p><p><code>next.config.js</code> - Next.js 的配置文件</p><p><code>pages</code> - 页面目录</p><p><code>styles</code> - 样式目录</p><p><code>public</code> - 公共资源目录，会在构建时被原样拷贝</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>本次课程讲解了 Next.js 的基础概念、客户端开发以及服务端开发，以及核心功能的实现，让我对 Next.js 拥有了更多的了解，它的客户端和服务端的开发可以让我们更有效的实现功能，并且在项目构建的时候可以利用它的脚手架快速创建项目，实现更加高效的开发。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/02/01/NextJS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NodeJS基础 ｜ 青训营笔记.md</title>
      <link>https://xyxsw.ltd/2023/01/31/NodeJS%E5%9F%BA%E7%A1%80%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/31/NodeJS%E5%9F%BA%E7%A1%80%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 31 Jan 2023 15:00:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 15 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、本堂课重点内容：&quot;&gt;&lt;a href=&quot;#一、本堂课重点内容：&quot; class=&quot;headerlink&quot; title=&quot;一、本堂课重点内容：&quot;&gt;&lt;/a&gt;一、本</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 15 天</strong></p><h2 id="一、本堂课重点内容："><a href="#一、本堂课重点内容：" class="headerlink" title="一、本堂课重点内容："></a>一、本堂课重点内容：</h2><ol><li>NodeJS 应用场景</li><li>NodeJS 运行时结构</li><li>使用 NodeJS 编写简单的 HTTP Server</li><li>NodeJS延伸</li></ol><h2 id="二、详细知识点介绍："><a href="#二、详细知识点介绍：" class="headerlink" title="二、详细知识点介绍："></a>二、详细知识点介绍：</h2><h3 id="1-NodeJS应用场景"><a href="#1-NodeJS应用场景" class="headerlink" title="1. NodeJS应用场景"></a>1. NodeJS应用场景</h3><p>NodeJS被广泛应用于前端工程化（<code>Vue</code>、<code>React</code>、<code>AngularJS</code>等）、</p><p>Web 服务端应用（<code>Vercel</code>）和 跨端桌面应用（<code>Electron</code>等）场景</p><p>许多熟知的打包构建工具都有NodeJS参与，例如 <code>webpack</code>、<code>vite</code>、<code>esbuild</code>和<code>parcel</code>等，也有例如<code>babel</code>和<code>TS</code>等语言转换程序也由<code>nodejs</code>编写。</p><p>在前端工程化领域，<code>NodeJS</code>也有许多优势，首先是学习曲线平缓、开发效率较高、其次是运行效率较高，社区生态丰富。且由于其语言优势，和前端结合更加顺畅，例如某些服务端渲染场景。</p><p>在跨端应用方面，微软的<code>VSCode</code>、聊天工具<code>Discord</code>都由<code>Electron</code>开发，值得在项目选型时考虑。</p><p>难以替代</p><p>与前端结合的场景有很大的优势SSR</p><p>字节使用<code>NodeJS</code>，飞书就是<code>electron</code>应用  每年新增1000+<code>nodejs</code>应用</p><h3 id="2-NodeJS运行时结构"><a href="#2-NodeJS运行时结构" class="headerlink" title="2.NodeJS运行时结构"></a>2.NodeJS运行时结构</h3><ul><li>用户代码</li><li>npm</li><li>js core</li><li>cpp core</li><li>v8</li><li>openssl</li><li>…</li></ul><p>异步、单线程、跨平台</p><h3 id="3-使用-NodeJS-编写简单的-HTTP-Server"><a href="#3-使用-NodeJS-编写简单的-HTTP-Server" class="headerlink" title="3. 使用 NodeJS 编写简单的 HTTP Server"></a>3. 使用 NodeJS 编写简单的 HTTP Server</h3><p>0 ． 安装 <code>node.js</code><br>1 .    编写 Http Server + Client, 收发 GET, POST 请求<br>2 ． 编写静态文件服务器<br>3 ． 编写 React SSR 服务<br>4 ． 适用 inspector 进行调试 、 诊断<br>5 ． 部署简介</p><h3 id="4-NodeJS延伸"><a href="#4-NodeJS延伸" class="headerlink" title="4. NodeJS延伸"></a>4. NodeJS延伸</h3><ul><li>编译</li><li>诊断追踪</li><li>wasm</li><li>napi</li><li>…</li></ul><h2 id="三、实践练习例子："><a href="#三、实践练习例子：" class="headerlink" title="三、实践练习例子："></a>三、实践练习例子：</h2><h3 id="简单的-Hello-World"><a href="#简单的-Hello-World" class="headerlink" title="简单的 Hello World"></a>简单的 Hello World</h3><pre><code class="js">const http = require(&#39;http&#39;)const port = 3000const server = http.createServer((req, res) =&gt; &#123;    res.end(&#39;hello&#39;)&#125;)server.listen(port, () =&gt; &#123;    console.log(`listening port on $&#123;port&#125;`)&#125;)</code></pre><p>使用 <code>require(&#39;http&#39;)</code> 引用 NodeJS 自带的 http 模块。</p><p>使用 <code>createServer</code> 方法为请求绑定处理事件函数，</p><p>使用 <code>res.end(&#39;hello&#39;)</code> 来结束请求并返回 <code>hello</code> 字符串。</p><p>使用 <code>listen</code> 函数设置监听的端口，第一个参数是端口号，第二个参数是绑定成功的回调函数。</p><p>用浏览器访问127.0.0.1:3000 会显示hello</p><h3 id="简单的静态文件服务"><a href="#简单的静态文件服务" class="headerlink" title="简单的静态文件服务"></a>简单的静态文件服务</h3><pre><code class="js">const http = require(&#39;http&#39;)const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const url = require(&#39;url&#39;)const port = 3000const server = http.createServer((req, res) =&gt; &#123;    const info = url.parse(req.url)    const file = fs.createReadStream(path.resolve(__dirname, &#39;.&#39; + info.pathname))    file.pipe(res)&#125;)server.listen(port, () =&gt; &#123;    console.log(`listening port on $&#123;port&#125;`)&#125;)</code></pre><p>通过 NodeJS 自带的文件操作模块 <code>fs</code> 的 <code>createReadStream</code> 创建了一个文件流，</p><p>通过流内部方法pipe将其输出给res（响应对象）</p><p>能将对应路径的文件返回给浏览器</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>今天的课程主要介绍了<strong>NodeJS</strong>的应用场景以及运行时结构，并且结合实例介绍了如何使用<strong>NodeJS</strong>编写简单的HTTP Server。通过今天的学习，我更加深入地了解了<strong>NodeJS</strong>，再次感受到它的强大，它可以应用于前端工程化、Web 服务端应用以及跨端桌面应用等多种场景，它的未来也是非常可观的。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/31/NodeJS%E5%9F%BA%E7%A1%80%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Slidev 用markdown写PPT！｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/30/Slidev%20%E7%94%A8markdown%E5%86%99PPT%EF%BC%81%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/30/Slidev%20%E7%94%A8markdown%E5%86%99PPT%EF%BC%81%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 30 Jan 2023 07:40:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 14 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;欢迎使用 Slid</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 14 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>欢迎使用 Slidev!为开发者打造的演示文稿工具</code></pre><p>slidev是slidevjs开发的一款开源的使用markdown来编写ppt样式的前端应用的框架</p><p>只需要在单一 Markdown 文件中编写幻灯片就可以创建一个非常漂亮的前端ppt应用</p><p>这个项目自从<code>0.20.0</code>版本我就关注来着，当时就觉得很炫很好用</p><p>昨天看到了antfu更新说在最新版本<code>0.39.0</code>里支持了简单的动画切换效果</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130155007.png"></p><p>😋感觉动画切换是ppt最重要的东西吧，很好很圆满😎</p><p>来试试</p><p><img src="https://cn.sli.dev/screenshots/cover.png" alt="img"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p><strong>支持 Markdown 语法</strong>：Slidev 使用一种扩展的 Markdown 格式，在一个纯文本文件中存储和组织你的幻灯片。这让你专注于制作内容。而且由于内容和样式是分开的，这也使得在不同的主题之间切换变得更加容易。</p></li><li><p><strong>可定制主题</strong>：Slidev 的主题可以通过 <code>npm</code> 包的形式来分享和安装。</p></li><li><p><strong>对开发者友好</strong>：Slidev 为开发者提供了一流的代码片段支持。它同时支持 <a href="https://prismjs.com/">Prism</a> 和 <a href="https://github.com/shikijs/shiki">Shiki</a> 以获得像素级的完美语法高亮，并且能够随时修改代码。通过内置的 <a href="https://microsoft.github.io/monaco-editor/">Monaco 编辑器</a>，它还能让你在演示文稿中进行现场编码&#x2F;演示，并支持自动补全、类型悬停、甚至是 <code>TypeScript</code> 类型检查。</p></li><li><p><strong>快速</strong>：Slidev 得益于 <a href="https://vitejs.dev/">Vite</a>，<a href="https://v3.vuejs.org/">Vue 3</a> 和 <a href="https://windicss.org/">Windi CSS</a>，为你带来了最美妙的创作体验。你所做的每一个改变都会<strong>立即反映</strong>到你的幻灯片上。</p></li><li><p><strong>互动性 &amp; 直观表达</strong>：你可以编写自定义的 Vue 组件并直接在你的 MarkDown 文件中使用它们。你也可以在演示文稿中与它们互动，以更深入和直观的方式表达你的想法。</p></li><li><p><strong>支持录制</strong>：Slidev 提供了内置的录音和摄像头视图。你可以将你的演示文稿与你的相机视图一起分享，或者为你的屏幕和相机分别录制并保存。所有这些都是内置的，不需要额外的工具。</p></li><li><p><strong>可移植性</strong>：用一个命令就可以将你的幻灯片导出为 PDF 或 PNG，甚至是可托管的单页应用程序（SPA），并在任何地方分享它们。</p></li><li><p><strong>可配置</strong>：由于 Slidev 基于 Web 技术，任何可以在 Web 应用中完成的事情，Slidev 也可以做到。例如，<code>WebGL</code>、<code>API请求</code>、<code>iframes</code>，甚至是实时共享。完全取决于你的想象力!</p></li><li><p><strong>演讲者模式</strong>： 可以使用另一个窗口，甚至是你的手机来控制幻灯片。</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm init slidev</code></pre><p>在package.json里配置</p><pre><code>&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;slidev&quot;, //  启动 dev server    &quot;build&quot;: &quot;slidev build&quot;, // 构建生产环境的单页面应用    &quot;export&quot;: &quot;slidev export&quot; // 将幻灯片导出为 pdf 格式  &#125;&#125;</code></pre><p>执行 <code>npx slidev --help</code> 命令获取更多选项的详细信息。</p><p>这样就安装完成了，你只需要在<code>./slides.md</code>里编写你想要的内容就行😎</p><h2 id="推荐的目录结构"><a href="#推荐的目录结构" class="headerlink" title="推荐的目录结构"></a>推荐的目录结构</h2><pre><code>your-slidev/  ├── components/       # 自定义组件  ├── layouts/          # 自定义布局  ├── public/           # 静态资源  ├── setup/            # 自定义 setup / hooks  ├── styles/           # 自定义样式  ├── index.html        # 注入的 index.html  ├── slides.md         # 幻灯片主入口  └── vite.config.ts    # 扩展 vite 配置</code></pre><h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>使用 <code>---</code> 添加分隔符来分隔你的幻灯片。</p><p>注意 这个分隔符最好上下空两行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130162517.png"></p><p>像这样 </p><p>你可以安装一个VSCode插件 名叫slidev 来获得更好的体验，<a href="https://marketplace.visualstudio.com/items?itemName=antfu.slidev">https://marketplace.visualstudio.com/items?itemName=antfu.slidev</a></p><p>这个#2是插件告诉你这下面是第几张幻灯片</p><pre><code># SlidevHello, World!---# Page 2Directly use code blocks for highlighting```tsconsole.log(&#39;Hello, World!&#39;)```---# Page 3You can directly use Windi CSS and Vue components to style and enrich your slides.&lt;div class=&quot;p-3&quot;&gt;  &lt;Tweet id=&quot;20&quot; /&gt;&lt;/div&gt;</code></pre><p>像这样就创建了三张幻灯片</p><h4 id="扉页及布局"><a href="#扉页及布局" class="headerlink" title="扉页及布局"></a>扉页及布局</h4><p>用两个分隔符来表示一个扉页块</p><pre><code>---layout: cover---</code></pre><p>两个分隔符里是<code>yaml</code>格式的对象</p><p>具体的语法如下</p><pre><code>---# 主题id 或 主题包名称# 了解更多：https://sli.dev/themes/use.htmltheme: &#39;default&#39;# 幻灯片的总标题，如果没有指定，那么将以第一张拥有标题的幻灯片的标题作为总标题title: &#39;Slidev&#39;# titleTemplate for the webpage, `%s` will be replaced by the page&#39;s titletitleTemplate: &#39;%s - Slidev&#39;# information for your slides, can be a markdown stringinfo: false# 在单页（SPA）构建中启用 pdf 下载，也可以指定一个自定义 urldownload: false# 要导出文件的文件名称exportFilename: &#39;slidev-exported.pdf&#39;# 语法高亮设置，可以使用 &#39;prism&#39; 或 &#39;shiki&#39; 方案highlighter: &#39;prism&#39;# 在代码块中显示行号lineNumbers: false# 启用 monaco 编辑器，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;monaco: &#39;dev&#39;# 使用 vite-plugin-remote-assets 在本地下载远程资源，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;remoteAssets: false# 控制幻灯片中的文本是否可以选择selectable: true# 启用幻灯片录制，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;record: &#39;dev&#39;# 幻灯片的配色方案，可以使用 &#39;auto&#39;，&#39;light&#39; 或者 &#39;dark&#39;colorSchema: &#39;auto&#39;# vue-router 模式，可以使用 &#39;history&#39; 或 &#39;hash&#39; 模式routerMode: &#39;history&#39;# 幻灯片的长宽比aspectRatio: &#39;16/9&#39;# canvas 的真实宽度，单位为 pxcanvasWidth: 980# 用于主题定制，会将属性 `x` 注入根样式 `--slidev-theme-x`themeConfig:  primary: &#39;#5d8392&#39;# favicon 可以是本地文件路径，也可以是一个 URLfavicon: &#39;https://cdn.jsdelivr.net/gh/slidevjs/slidev/assets/favicon.png&#39;# 用于渲染图表的 PlantUML 服务器的 URLplantUmlServer: &#39;https://www.plantuml.com/plantuml&#39;# 字体将从 Google 字体自动导入# 了解更多：https://sli.dev/custom/fontsfonts:  sans: &#39;Roboto&#39;  serif: &#39;Roboto Slab&#39;  mono: &#39;Fira Code&#39;# 为所有幻灯片添加默认的 frontmatterdefaults:  layout: &#39;default&#39;  # ...# 绘制选项# 了解更多：https://sli.dev/guide/drawing.htmldrawings:  enabled: true  persist: false  presenterOnly: false  syncAll: true---</code></pre><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>可以通过&#96;&#96;&#96;来创建一个代码块</p><pre><code>```tsconsole.log(&#39;Hello, World!&#39;)```</code></pre><p>可以通过在语言名后写大括号的形式来指定特定行高亮<code>&#123;&#125;</code></p><p>注意：行号从 1 开始计算。</p><pre><code>```ts &#123;2-3|5|all&#125;function add(  a: Ref&lt;number&gt; | number,  b: Ref&lt;number&gt; | number) &#123;  return computed(() =&gt; unref(a) + unref(b))&#125;```</code></pre><p>这段代码的意思是 点进来先是2到3行高亮，再点一下2到3不亮第5行亮，再点一下整个都亮</p><h4 id="Monaco-编辑器"><a href="#Monaco-编辑器" class="headerlink" title="Monaco 编辑器"></a>Monaco 编辑器</h4><p>只需在语言 id 后添加 <code>&#123;monaco&#125;</code> 就可以启用monaco</p><p>什么是monaco呢，可以理解为网页版的vscode那样的，可以在线编辑的</p><pre><code>```ts &#123;monaco&#125;console.log(&#39;HelloWorld&#39;)```</code></pre><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>你可以在 Markdown 中直接使用 <code>&lt;style&gt;</code> 标签来覆盖<strong>当前幻灯片</strong>的样式。</p><p>Slidev支持windicss的原子化写法和指令集 例如<code>@apply</code></p><pre><code># Slidev&gt; Hello `world`&lt;style&gt;blockquote &#123;  code &#123;    @apply text-teal-500 dark:text-teal-400;  &#125;&#125;&lt;/style&gt;</code></pre><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>和编写 Markdown 的方式一样，你可以使用本地或远程的 URL 的图片。</p><p>远程资源会缓存</p><p>本地资源请放到public文件夹</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>你也可以为每张幻灯片编写备注。它们将展示在 <a href="https://cn.sli.dev/guide/presenter-mode.html">演讲者模式</a> 中，供你在演示时参考。</p><p>在每一页幻灯片内容最后</p><p>添加注释即可</p><pre><code>---layout: cover---# 第 1 页This is the cover page.&lt;!-- 这是一条备注 --&gt;---# 第 2 页&lt;!-- 这不是一条备注，因为它在幻灯片内容前 --&gt;The second page&lt;!--这是另一条备注--&gt;</code></pre><h4 id="icon图标"><a href="#icon图标" class="headerlink" title="icon图标"></a>icon图标</h4><p>很喜欢的功能</p><p>Slidev 允许你在 Markdown 中<strong>直接</strong>访问几乎所有的开源的图标集。</p><p>你可以通过 <a href="https://icones.js.org/">Icônes</a> 来浏览访问所有可用的图标。</p><p>更详细的请看<a href="https://cn.sli.dev/guide/syntax.html#icons">https://cn.sli.dev/guide/syntax.html#icons</a></p><h4 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h4><p>这个不是很熟啊</p><p><a href="https://demo.sli.dev/starter/8">https://demo.sli.dev/starter/8</a></p><p>可以看下示例 和 文档</p><p><a href="https://katex.org/">https://katex.org/</a></p><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><p>这个东西也没怎么用过，只知道github什么的支持这种语法 基于<a href="https://github.com/mermaid-js/mermaid">https://github.com/mermaid-js/mermaid</a></p><p>被标记为 <code>mermaid</code> 的代码块将被转换为图形，例如：</p><pre><code>```mermaidsequenceDiagram  Alice-&gt;John: Hello John, how are you?  Note over Alice,John: A typical interaction```</code></pre><pre><code class="mermaid">sequenceDiagram  Alice-&gt;John: Hello John, how are you?  Note over Alice,John: A typical interaction</code></pre><p>我在typora也可以创建这个图表，感觉很好用</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130170429.png"></p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130170544.png"></p><p>导航栏默认在左下角，鼠标移动上去显示</p><p>可以用<code>right / space</code>来切换下一张幻灯片</p><p>按<code>g</code>跳出一个栏，输入页码可以跳转</p><p>更多快捷键详见<a href="https://cn.sli.dev/guide/navigation.html#navigation-bar">https://cn.sli.dev/guide/navigation.html#navigation-bar</a></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>重头戏</p><p>这个版本就更新了这个</p><h4 id="点击动画"><a href="#点击动画" class="headerlink" title="点击动画"></a>点击动画</h4><p><code>v-click</code> 可以用<code>&lt;v-click&gt;&lt;/v-click&gt;</code>标签或在标签内写<code>&lt;div v-click class=&quot;text-xl p-2&quot;&gt;</code>这样的指令</p><p>以下指令写法同理</p><p><code>v-after</code> 和<code>v-click</code>绑定，这俩会一起显示</p><p><code>v-click-hide</code>点击后不可见</p><p><code>v-clicks</code> 只能使用标签写法 可以方便的展示一个列表</p><pre><code>&lt;v-clicks&gt;- Item 1- Item 2- Item 3- Item 4&lt;/v-clicks&gt;</code></pre><p>你还可以手动指定过渡动画 覆写两个类的动画</p><pre><code>// the default.slidev-vclick-target &#123;  transition: opacity 100ms ease;&#125;.slidev-vclick-hidden &#123;  opacity: 0;  pointer-events: none;&#125;</code></pre><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p><a href="https://vueuse.org/functions.html#category=%40Motion">https://vueuse.org/functions.html#category=%40Motion</a></p><p>内置了vueuse的motion功能</p><p>你可以对任何元素应用 <code>v-motion</code> 指令，以对它们施加运动效果。例如：</p><pre><code>&lt;div  v-motion  :initial=&quot;&#123; x: -80 &#125;&quot;  :enter=&quot;&#123; x: 0 &#125;&quot;&gt;  Slidev&lt;/div&gt;</code></pre><p>文本 <code>Slidev</code> 将从其初始化位置 <code>-80px</code> 移至其原始位置。</p><h4 id="页面过渡"><a href="#页面过渡" class="headerlink" title="页面过渡"></a>页面过渡</h4><p>🤩新功能！</p><p>可以在扉页中填写</p><pre><code>---transition: slide-left---</code></pre><p>这将给你一个很好的滑动效果。将其设置在首页，将适用于所有的幻灯片。您还可以为每张幻灯片设置不同的过渡。</p><p>自带的过渡效果</p><pre><code>fade - Crossfade in/outfade-out - Fade out and then fade inslide-left - Slides to the left, slide to right when going backslide-right - Slides to the right, slide to left when going backslide-top - Slides to the top, slide to bottom when going backslide-bottom - Slides to the bottom, slide to top when going back</code></pre><p>还可以自定义过渡效果</p><pre><code>---transition: my-transition---</code></pre><pre><code>.my-transition-enter-active,.my-transition-leave-active &#123;  transition: opacity 0.5s ease;&#125;.my-transition-enter-from,.my-transition-leave-to &#123;  opacity: 0;&#125;</code></pre><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>导出为pdf 依赖于微软开源的playwright框架</p><p><a href="https://playwright.dev/docs/installation#download-single-browser-binary"><code>playwright-chromium</code></a></p><p>需要先安装</p><pre><code>npm i -D playwright-chromium</code></pre><p>使用</p><pre><code>slidev export</code></pre><p>可导出pdf格式</p><pre><code>slidev export --format png</code></pre><p>可导出png格式</p><h2 id="静态部署"><a href="#静态部署" class="headerlink" title="静态部署"></a>静态部署</h2><pre><code>slidev build</code></pre><p>编译当前幻灯片生成在<code>dist/</code>目录下，可以部署到静态托管平台</p><h4 id="提供可下载的-PDF"><a href="#提供可下载的-PDF" class="headerlink" title="提供可下载的 PDF"></a>提供可下载的 PDF</h4><p>在扉页中设置</p><pre><code>---download: true---</code></pre><p>会在单页应用中展示下载按钮</p><p>也可以自定义url</p><pre><code>---download: &#39;https://myside.com/my-talk.pdf&#39;---</code></pre><h4 id="部署到netlify"><a href="#部署到netlify" class="headerlink" title="部署到netlify"></a>部署到netlify</h4><p>创建<code>netlify.toml</code>文件 配置</p><pre><code>[build.environment]  NODE_VERSION = &quot;14&quot;[build]  publish = &quot;dist&quot;  command = &quot;npm run build&quot;[[redirects]]  from = &quot;/*&quot;  to = &quot;/index.html&quot;  status = 200</code></pre><h4 id="部署到vercel"><a href="#部署到vercel" class="headerlink" title="部署到vercel"></a>部署到vercel</h4><p>创建<code>vercel.json</code>文件 配置</p><pre><code>&#123;  &quot;rewrites&quot;: [    &#123; &quot;source&quot;: &quot;/(.*)&quot;, &quot;destination&quot;: &quot;/index.html&quot; &#125;  ]&#125;</code></pre><h2 id="演讲录制"><a href="#演讲录制" class="headerlink" title="演讲录制"></a>演讲录制</h2><h4 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h4><p>导航面板的小人按钮可以开启摄像头</p><p>你可以拖动它，并使用右下角的把手来调整大小。尺寸和位置将持久化存储在 <code>localStorage</code> 中，因此，可以保证多次刷新后的展示一致，无需担心位置和大小丢失的问题。</p><h4 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h4><p>导航面板的摄像机按钮</p><p>可以录制麦克风和摄像头</p><h2 id="演讲者模式"><a href="#演讲者模式" class="headerlink" title="演讲者模式"></a>演讲者模式</h2><p>点击小人带麦克风的按钮</p><p>可以进入演讲者模式</p><p>需要双端在同一网络下</p><p>其他页面的实例会自动和演讲者的页面同步</p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>可以在页面上画画</p><p>可以在演讲者模式中启用，会实时自动同步</p><p>支持触控笔压感</p><h2 id="编辑器整合"><a href="#编辑器整合" class="headerlink" title="编辑器整合"></a>编辑器整合</h2><p>你可以在运行中在网页上更改你的源码，他会自动同步到slide.md里</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>在这里浏览主题并应用到你的实例中</p><p><a href="https://cn.sli.dev/themes/gallery.html">https://cn.sli.dev/themes/gallery.html</a></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><a href="https://cn.sli.dev/builtin/layouts.html">https://cn.sli.dev/builtin/layouts.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇写了不少，详细的写了我比较喜欢的ppt框架</p><p>我有一个部署的版本，地址在 <a href="https://botppt.netlify.app/">https://botppt.netlify.app/</a></p><p>是很久之前写的辣，版本还是很老的，有时间会更新一下</p><p>😎</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://botppt.netlify.app/1">https://botppt.netlify.app/1</a></p><p><a href="https://cn.sli.dev/showcases.html">https://cn.sli.dev/showcases.html</a></p><p><a href="https://cn.sli.dev/">https://cn.sli.dev/</a></p><p><a href="https://github.com/slidevjs/slidev">https://github.com/slidevjs/slidev</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/30/Slidev%20%E7%94%A8markdown%E5%86%99PPT%EF%BC%81%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt3与服务端渲染SSR（高级篇） ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/29/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/29/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sun, 29 Jan 2023 08:13:02 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 13 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前两篇写了一些nuxt3和SSR的</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 13 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两篇写了一些nuxt3和SSR的基础</p><p>这一篇讲讲nuxt3比较进阶的部分</p><h2 id="自动引入"><a href="#自动引入" class="headerlink" title="自动引入"></a>自动引入</h2><h4 id="nuxt3自带自动引入"><a href="#nuxt3自带自动引入" class="headerlink" title="nuxt3自带自动引入"></a>nuxt3自带自动引入</h4><p>包括一些nuxt3的api都是不用导入的直接就可以用</p><p>例如</p><ul><li><p>数据获取的函数<code>useFetch</code> <code>useAsyncData</code> </p></li><li><p>状态管理函数<code>useState</code> </p></li><li><p>运行变量获取函数 <code>useRuntimeConfig</code></p></li><li><p>运行时上下文获取函数 <code>useNuxtApp</code></p></li></ul><h4 id="还有一些Vue的api"><a href="#还有一些Vue的api" class="headerlink" title="还有一些Vue的api"></a>还有一些Vue的api</h4><p>例如</p><ul><li><p>响应式的函数<code>ref</code></p></li><li><p>计算属性 <code>computed</code></p></li></ul><h4 id="文件夹下的内容自动引入"><a href="#文件夹下的内容自动引入" class="headerlink" title="文件夹下的内容自动引入"></a>文件夹下的内容自动引入</h4><p>例如</p><ul><li><code>components/</code>文件夹下的组件</li><li><code>composables/</code>文件夹下的响应式函数</li><li><code>utils/</code>文件夹下的工具函数</li></ul><h4 id="可以使用-imports来使导入明确"><a href="#可以使用-imports来使导入明确" class="headerlink" title="可以使用#imports来使导入明确"></a>可以使用<code>#imports</code>来使导入明确</h4><pre><code>&lt;script setup&gt;  import &#123; ref, computed &#125; from &#39;#imports&#39;  const count = ref(1)  const double = computed(() =&gt; count.value * 2)&lt;/script&gt;</code></pre><h4 id="关闭自动引入"><a href="#关闭自动引入" class="headerlink" title="关闭自动引入"></a>关闭自动引入</h4><p>在<code>nuxtconfig</code>里加入</p><pre><code>export default defineNuxtConfig(&#123;  imports: &#123;    autoImport: false  &#125;&#125;)</code></pre><p>（😡谁会这么做</p><h2 id="自动引入的组件"><a href="#自动引入的组件" class="headerlink" title="自动引入的组件"></a>自动引入的组件</h2><p>假设目录如下</p><pre><code>| components/--| base/----| foo/------| Button.vue</code></pre><p>此时可以使用<code>&lt;BaseFooButton /&gt;</code>标签引入这个button组件</p><p>另外，可以使用一个Lazy前缀来懒加载组件</p><p>例如</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Mountains&lt;/h1&gt;    &lt;LazyMountainsList v-if=&quot;show&quot; /&gt;    &lt;button v-if=&quot;!show&quot; @click=&quot;show = true&quot;&gt;Show List&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      show: false    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>这样可以减少打包大小，增加性能</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>写在<code>pages/</code>里的组件会自动写入路由</p><p><code>pages/index.vue</code>会匹配路由<code>/</code></p><p>只需要在<code>app.vue</code>里添加</p><p><code>&lt;NuxtPage /&gt;</code>标签</p><p>可以通过插槽写法例如写<code>[id].vue</code>来匹配路由内的参数</p><p>例如如下文件树</p><pre><code>-| pages/---| index.vue---| users-[group]/-----| [id].vue</code></pre><p>在<code>[id].vue</code>里写下</p><pre><code>&lt;template&gt;  &lt;p&gt;&#123;&#123; $route.params.group &#125;&#125; - &#123;&#123; $route.params.id &#125;&#125;&lt;/p&gt;&lt;/template&gt;</code></pre><p>读取group参数和id参数</p><p>访问路由<code>/users-admins/123</code>会渲染成</p><pre><code>&lt;p&gt;admins - 123&lt;/p&gt;</code></pre><h2 id="渲染模式"><a href="#渲染模式" class="headerlink" title="渲染模式"></a>渲染模式</h2><h4 id="传统的Vue项目渲染方式为-客户端渲染"><a href="#传统的Vue项目渲染方式为-客户端渲染" class="headerlink" title="传统的Vue项目渲染方式为  客户端渲染"></a>传统的Vue项目渲染方式为  <code>客户端渲染</code></h4><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230129144946.png"></p><p>浏览器会先下载到空的html文件→下载js→渲染出来</p><p>这种方式的优点是：</p><ul><li><p>开发速度快：当完全在客户端上工作时，我们不必担心代码的服务器兼容性，例如，使用像windows这样的浏览器api。 </p></li><li><p>更便宜的服务器成本：运行一个服务器会增加一个基础设施的成本，因为您需要在一个支持JavaScript的平台上运行。我们可以在任何具有HTML、CSS和JavaScript文件的静态服务器上托管仅限客户端的应用程序。 </p></li><li><p>下载好后离线：因为代码完全在浏览器中运行，所以它可以很好地在互联网不可用时很好地保持工作。</p></li></ul><p>缺点为：</p><ul><li>性能不好：用户必须等待浏览器下载、解析和运行JavaScript文件。根据下载部分的网络和用户的解析和执行设备，这可能需要一些时间，并影响用户的体验。</li><li>不友好的搜索引擎优化：索引和更新通过客户端呈现交付的内容比使用服务器呈现的HTML文档需要更多的时间。</li></ul><h4 id="nuxt3的服务端渲染"><a href="#nuxt3的服务端渲染" class="headerlink" title="nuxt3的服务端渲染"></a>nuxt3的<code>服务端渲染</code></h4><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230129145732.png"></p><p>有内容的html文件会下载到浏览器→用户在此时可以点击和浏览页面上的内容（部分功能）→需要的组件渲染完成、此时的页面有全部功能</p><p>这种方式的优点是：</p><ul><li>性能好：用户可以立即访问页面的内容，因为浏览器显示静态内容的速度比<code>javascript</code>生成的静态内容要快得多。</li><li>搜索引擎优化：通用呈现将页面的整个HTML内容作为一个经典的服务器应用程序传递到浏览器。Web爬虫可以直接索引页面的内容。</li></ul><p>缺点是：</p><ul><li>开发约束：服务器和浏览器环境不提供相同的api，而且编写可以在两边无缝运行的代码可能会很棘手。幸运的是，Nuxt提供了特定的变量来同步这些。</li><li>成本高：服务器需要运行，才能动态地呈现页面。这就像任何传统服务器一样，增加了每月的成本。但是，由于浏览器接管了客户端导航的通用渲染，服务器调用大大减少了。</li></ul><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>使用 <code>TypeScript</code> 后可以使用nuxi带的语法检查</p><pre><code>yarn nuxi typecheck</code></pre><p>nuxt也会自动生成类型</p><p>在<a href="https://nuxt.com/docs/guide/concepts/typescript#nuxtnuxtdts"><code>.nuxt/nuxt.d.ts</code></a>目录下</p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>一个完整的nuxt3项目文件目录应该包含以下文件夹和文件</p><pre><code>.nuxt                      nuxt生成的文件目录里面有 运行的类型等.output                    build产物文件夹assets                     css文件、字体文件、图片文件components                 组件目录composables                响应式函数的文件夹content                    基于文件的cms的文件夹layouts                    布局组件的文件夹middleware                 中间件文件夹node_modules               依赖文件夹pages                      路由的页面plugins                    nuxt插件public                     公共文件文件夹，可以放ico图标，图片server                     服务端api文件夹utils                      工具函数文件夹.gitignore                 git忽略文件.nuxtignore                不加入nuxt编译的忽略文件app.config.ts              config文件 可以使用useAppConfig读取app.vue                    vue入口 nuxt.config.ts             nuxt配置文件package.json               依赖描述文件tsconfig.json              ts检查配置文件</code></pre><p><a href="https://nuxt.com/docs/guide/directory-structure/nuxt">https://nuxt.com/docs/guide/directory-structure/nuxt</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章介绍了nuxt3的高级用法</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><p>😎🥰</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/docs/guide/concepts/auto-imports">https://nuxt.com/docs/guide/concepts/auto-imports</a></p><p><a href="https://nuxt.com/docs/guide/directory-structure/composables">https://nuxt.com/docs/guide/directory-structure/composables</a></p><p><a href="https://nuxt.com/docs/guide/directory-structure/components">https://nuxt.com/docs/guide/directory-structure/components</a></p><p><a href="https://github.com/unjs/nitro">https://github.com/unjs/nitro</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/29/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>青训营任务-我的名片-可爱捏☺</title>
      <link>https://xyxsw.ltd/2023/01/28/%E3%80%8C%E9%9D%92%E8%AE%AD%E8%90%A5%20X%20%E7%A0%81%E4%B8%8A%E6%8E%98%E9%87%91%E3%80%8D%E4%B8%BB%E9%A2%98%201%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E5%90%8D%E7%89%87/</link>
      <guid>https://xyxsw.ltd/2023/01/28/%E3%80%8C%E9%9D%92%E8%AE%AD%E8%90%A5%20X%20%E7%A0%81%E4%B8%8A%E6%8E%98%E9%87%91%E3%80%8D%E4%B8%BB%E9%A2%98%201%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E5%90%8D%E7%89%87/</guid>
      <pubDate>Sat, 28 Jan 2023 14:57:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;当青训营遇上码上掘金&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;主题介绍&quot;&gt;&lt;a href=&quot;#主题介绍&quot; class=&quot;headerlink&quot; title=&quot;主题介绍&quot;&gt;&lt;/a&gt;主题介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;主题-1：我的名片&quot;&gt;&lt;a</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>当青训营遇上码上掘金</strong></p><h2 id="主题介绍"><a href="#主题介绍" class="headerlink" title="主题介绍"></a>主题介绍</h2><ul><li><h4 id="主题-1：我的名片"><a href="#主题-1：我的名片" class="headerlink" title="主题 1：我的名片"></a>主题 1：我的名片</h4>名片是向人介绍自我的重要工具，作为一名程序员用代码做自我介绍是一件非常酷炫的事情。请大家围绕“我的名片”这个主题进行代码创作。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然说整个酷炫的</p><p>直接上框架</p><p><a href="https://github.com/antfu/vitesse-webext">https://github.com/antfu/vitesse-webext</a></p><p>这个模板是基于Vue的webext（浏览器插件手脚架）</p><p>webext是一个可以帮助构建、运行和测试Web扩展的命令行工具。</p><p><a href="https://wiki.mozilla.org/WebExtensions">https://wiki.mozilla.org/WebExtensions</a></p><p>webext的目标是以一种标准的、可移植、跨平台的方式支持浏览器扩展。最初，它将为开发火狐扩展提供一个简化的体验。</p><p>我们的目标是实现一个浏览器扩展类型的名片</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>⚡️ Vite 快速构建</li><li>🥝 Vue 3 -组合式api 3.2+setup语法</li><li>💬<a href="https://github.com/antfu/webext-bridge"><code>webext-bridge</code></a> 的local storage 和 <a href="https://github.com/antfu/vueuse">VueUse</a> 的使用结合</li><li>🌈 <a href="https://github.com/unocss/unocss">UnoCSS</a> - 原子化CSS引擎</li><li>🦾 <a href="https://www.typescriptlang.org/">TypeScript</a> 语法支持</li><li>📦 <a href="https://github.com/antfu/vitesse-webext/blob/main/src/components">Components auto importing</a> 自动引入</li><li>🌍 WebExtension - 标准浏览器扩展手脚架 可以一键生成chromium、Firefox适配的扩展</li><li>😴 mv3 - manifest v3</li></ul><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>本身这个项目没什么坑的、只是</p><p>😡</p><p>浏览器在2023年抛弃manifest v2</p><p>所以使用manifest v2打包后的浏览器扩展浏览器不认</p><p>会显示</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128210235.png"></p><p>😱</p><p>还有一点就是本身不太会CSS</p><p>调CSS花了很长时间</p><p>但是unocss还是很方便的</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="vue">&lt;script setup&gt;import &#123; useImage &#125; from &#39;@vueuse/core&#39;const avatarUrl = &#39;https://s1.ax1x.com/2023/01/23/pSYuIYD.png&#39;const waka = &#39;https://wakatime.com/badge/user/84476697-3421-4720-bcdc-efb5c0fbc1b8.svg?style=flat-square&#39;const kita = &#39;https://www.z4a.net/images/2023/01/28/kita.gif&#39;const &#123; isLoading &#125; = useImage(&#123; src: avatarUrl &#125;)const &#123; isLoading_waka &#125; = useImage(&#123; src: waka &#125;)const &#123; isLoading_kita &#125; = useImage(&#123; src: kita &#125;)const to_left = () =&gt; &#123;  document.getElementsByClassName(&#39;img&#39;)[0].classList.remove(&#39;to_right&#39;)  document.getElementsByClassName(&#39;right_text&#39;)[0].classList.remove(&#39;to_right_text&#39;)  document.getElementsByClassName(&#39;right_block&#39;)[0].classList.remove(&#39;to_right_block&#39;)  document.getElementsByClassName(&#39;left_block&#39;)[0].classList.remove(&#39;to_left_block&#39;)  document.getElementsByClassName(&#39;left_img&#39;)[0].classList.remove(&#39;to_left_img&#39;)&#125;const to_right = () =&gt; &#123;  document.getElementsByClassName(&#39;img&#39;)[0].classList.add(&#39;to_right&#39;)  document.getElementsByClassName(&#39;right_text&#39;)[0].classList.add(&#39;to_right_text&#39;)  document.getElementsByClassName(&#39;right_block&#39;)[0].classList.add(&#39;to_right_block&#39;)  document.getElementsByClassName(&#39;left_block&#39;)[0].classList.add(&#39;to_left_block&#39;)  document.getElementsByClassName(&#39;left_img&#39;)[0].classList.add(&#39;to_left_img&#39;)&#125;&lt;/script&gt;&lt;template&gt;  &lt;main class=&quot;w-[384px] h-[256px] text-center text-light-700 bg-[#f69db2] font-sans&quot;&gt;    &lt;div class=&quot;h-100% w-100% flex flex-row justify-between p-5 items-center gap-5&quot;&gt;      &lt;div class=&quot;absolute left-0 top-0 translate-x-[-100%]&quot;&gt;        &lt;div class=&quot;flex flex-col justify-end left_block duration-700 &quot;&gt;          &lt;div class=&quot;bg-[#60c5e7] p-5&quot; /&gt;          &lt;div class=&quot;bg-[#f3d263] p-5&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;absolute left-0 top-0 translate-x-[-100%]&quot;&gt;        &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-11.5 py-16 text-center font-black&quot;&gt;Loading&lt;/span&gt;        &lt;img v-else :src=&quot;kita&quot; class=&quot;left_img duration-400&quot;&gt;      &lt;/div&gt;      &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-11.5 py-16 text-center font-black&quot;&gt;Loading&lt;/span&gt;      &lt;img v-else :src=&quot;avatarUrl&quot; class=&quot;w-35 h-35 img duration-700&quot;&gt;      &lt;div class=&quot;flex flex-col gap-5 h-119%&quot;&gt;        &lt;div class=&quot;flex flex-row justify-end translate-x-4.9 right_block duration-700 &quot;&gt;          &lt;div class=&quot;bg-[#60c5e7] p-5&quot; /&gt;          &lt;div class=&quot;bg-[#f3d263] p-5&quot; /&gt;        &lt;/div&gt;        &lt;div class=&quot;flex flex-col gap-5 pt-8 right_text duration-700 &quot;&gt;          &lt;div class=&quot;text-center font-bold text-lg text-[#df4b57]&quot;&gt;            👋  Hi, I’m  @camera-2018          &lt;/div&gt;          &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-15 text-center font-black&quot;&gt;Loading&lt;/span&gt;          &lt;a v-else href=&quot;https://wakatime.com/@84476697-3421-4720-bcdc-efb5c0fbc1b8&quot;&gt;&lt;img :src=&quot;waka&quot; alt=&quot;Total time coded since May 9 2022&quot;&gt;&lt;/a&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;footer class=&quot;bg-[#f69db2] &quot;&gt;      &lt;button class=&quot;i-carbon-caret-left hover:bg-[#1DCED1] bg-light-50&quot; @click=&quot;to_left&quot; /&gt;      &lt;button class=&quot;i-carbon-caret-right hover:bg-[#1DCED1] bg-light-50&quot; @click=&quot;to_right&quot; /&gt;    &lt;/footer&gt;  &lt;/main&gt;&lt;/template&gt;&lt;style&gt;.to_right&#123;  @apply translate-x-142% transition&#125;.to_right_text &#123;  @apply translate-x-190% transition&#125;.to_right_block &#123;  @apply translate-y-[-120%] transition&#125;.to_left_block &#123;  @apply translate-x-100% transition&#125;.to_left_img &#123;  @apply translate-x-90% transition&#125;&lt;/style&gt;</code></pre><p>主要的代码就这么多</p><h3 id="大概思路是"><a href="#大概思路是" class="headerlink" title="大概思路是"></a>大概思路是</h3><ol><li><p>通过unocss的预设添加使用@apply的样式</p></li><li><p>再通过js添加样式到元素上</p></li><li><p>使用过渡效果 添加过渡时间</p></li><li><p>图片加载部分使用vueuse的useImage 没加载出来之前是有个loading的界面</p></li><li><p>使用了一个wakatime的svg展示最近敲代码时间点击可看</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/GIF%202023-1-28%2020-45-47.gif"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128213920.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128214002.png"></p><h2 id="灵感"><a href="#灵感" class="headerlink" title="灵感"></a>灵感</h2><p><a href="https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C">https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C</a></p><p>复刻了孤独摇滚 后藤一里 的配色 右上角或左上角的方块为波奇酱的发饰</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>代码开源于</p><p><a href="https://github.com/camera-2018/business-card-mv3">https://github.com/camera-2018/business-card-mv3</a></p><p>可以在<a href="https://github.com/camera-2018/business-card-mv3/releases">Releases</a>中下载编译好的扩展 解压然后点击浏览器的扩展程序选项卡 <code>chrome://extensions/</code></p><p>记得要开右上角的开发者模式哦</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128212633.png"></p><p>然后加载已解压的扩展程序就可以了</p><h2 id="popup部分代码"><a href="#popup部分代码" class="headerlink" title="popup部分代码"></a>popup部分代码</h2><p><a href="https://github.com/camera-2018/business-card-mv3/tree/refactor/mv3/src/popup">popup</a>部分代码放在码上掘金上</p><p><a href="https://code.juejin.cn/api/raw/7193666089241772090?id=7193666089241821242">https://code.juejin.cn/api/raw/7193666089241772090?id=7193666089241821242</a></p><p>由于依赖比较多，而码上掘金拉不到cdnjsdelivr的数据</p><p>所以在码上掘金上是无法正常显示的😥 想试试的话请去<a href="https://github.com/camera-2018/business-card-mv3%E6%BA%90%E7%A0%81">https://github.com/camera-2018/business-card-mv3源码</a></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128213154.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://code.juejin.cn/pen/7193666089241772090">https://code.juejin.cn/pen/7193666089241772090</a></p><p><a href="https://juejin.cn/post/7187753682421678137">https://juejin.cn/post/7187753682421678137</a></p><p><a href="https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C">https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C</a></p><p><a href="https://github.com/antfu/vitesse-webext">https://github.com/antfu/vitesse-webext</a></p>]]></content:encoded>
      
      
      
      
      <comments>https://xyxsw.ltd/2023/01/28/%E3%80%8C%E9%9D%92%E8%AE%AD%E8%90%A5%20X%20%E7%A0%81%E4%B8%8A%E6%8E%98%E9%87%91%E3%80%8D%E4%B8%BB%E9%A2%98%201%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E5%90%8D%E7%89%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt3与服务端渲染SSR（下） ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/28/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8B%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/</link>
      <guid>https://xyxsw.ltd/2023/01/28/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8B%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/</guid>
      <pubDate>Sat, 28 Jan 2023 13:37:03 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 12 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇文章介绍了大概一半的nuxt</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 12 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章介绍了大概一半的nuxt3特性，这一篇会介绍另外一半</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>Nuxt利用Vue的 <a href="https://vuejs.org/guide/built-ins/transition.html#the-transition-component"><code>&lt;Transition&gt;</code></a>组件来应用页面和布局之间的转换。</p><p>只需要在nuxt config里设置</p><pre><code class="js">export default defineNuxtConfig(&#123;  app: &#123;    pageTransition: &#123; name: &#39;page&#39;, mode: &#39;out-in&#39; &#125;  &#125;,&#125;)</code></pre><p>然后在<code>app.vue</code>里设置你想要的过渡动画</p><pre><code class="vue">&lt;template&gt;  &lt;NuxtPage /&gt;&lt;/template&gt;&lt;style&gt;.page-enter-active,.page-leave-active &#123;  transition: all 0.4s;&#125;.page-enter-from,.page-leave-to &#123;  opacity: 0;  filter: blur(1rem);&#125;&lt;/style&gt;</code></pre><p>类名必须是这几个</p><p>就可以实现一个切换页面有虚化效果的动画</p><p>更高级的用法详见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/transitions">https://nuxt.com/docs/getting-started/transitions</a></p><h2 id="使用Api获取数据"><a href="#使用Api获取数据" class="headerlink" title="使用Api获取数据"></a>使用Api获取数据</h2><p>nuxt3自带一个<code>vueuse</code>里的 <code>useFetch</code> api</p><p>使用方法为</p><pre><code>&lt;script setup&gt;const &#123; data: count &#125; = await useFetch(&#39;/api/count&#39;)&lt;/script&gt;&lt;template&gt;  Page visits: &#123;&#123; count &#125;&#125;&lt;/template&gt;</code></pre><p>可以使用<code>useAsyncData</code>来异步获取数据</p><pre><code>&lt;script setup&gt;const &#123; data &#125; = await useAsyncData(&#39;count&#39;, () =&gt; $fetch(&#39;/api/count&#39;))&lt;/script&gt;&lt;template&gt;  Page visits: &#123;&#123; data &#125;&#125;&lt;/template&gt;</code></pre><p>更高级的用法详见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/data-fetching">https://nuxt.com/docs/getting-started/data-fetching</a></p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>nuxt3提供了<code>vueuse</code>的一个api叫<code>useState</code>来实现全局状态管理</p><p>无需创建state文件</p><p>直接使用</p><pre><code>&lt;script setup&gt;const counter = useState(&#39;counter&#39;, () =&gt; Math.round(Math.random() * 1000))&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    Counter: &#123;&#123; counter &#125;&#125;    &lt;button @click=&quot;counter++&quot;&gt;      +    &lt;/button&gt;    &lt;button @click=&quot;counter--&quot;&gt;      -    &lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>这个例子创建了一个state叫counter 里面默认记录了一个随机数</p><p>点击按钮会让随机数进行加减</p><p><code>useState</code>默认为响应式 很方便</p><p>nuxt3的auto import特性可以使state简写为</p><pre><code>const counter = useCounter() // Same as useState(&#39;counter&#39;)</code></pre><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>nuxt提供了很多高级的错误处理方式</p><p>一个最简单的api是<code>useError</code></p><pre><code>const error = useError()</code></pre><p>这句代码可以快速的抛出一条错误</p><p>也可以使用<code>createError</code>方法</p><pre><code>&lt;script setup&gt;const route = useRoute()const &#123; data &#125; = await useFetch(`/api/movies/$&#123;route.params.slug&#125;`)if (!data.value) &#123;  throw createError(&#123; statusCode: 404, statusMessage: &#39;Page Not Found&#39; &#125;)&#125;&lt;/script&gt;</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>正常的使用<code>nuxt build</code>命令会生成一个在node环境中运行的运行时</p><p><code>.mjs文件</code></p><pre><code class="sh">node .output/server/index.mjs</code></pre><p>即可运行</p><pre><code class="bash">$ node .output/server/index.mjsListening on http://localhost:3000</code></pre><p>可以设置环境变量例如</p><pre><code>PORT=3001 node .output/server/index.mjs</code></pre><p>在3001端口运行</p><p>在 <code>nuxt.config</code> 里添加</p><pre><code>export default &#123;  nitro: &#123;    preset: &#39;node-server&#39;  &#125;&#125;</code></pre><p>或者<code>NITRO_PRESET=node-server nuxt build</code></p><p>preset字段可以更改生成的代码的依赖平台</p><p>支持的平台有</p><ul><li><a href="https://nitro.unjs.io/deploy/providers/aws">AWS</a></li><li><a href="https://nitro.unjs.io/deploy/providers/azure">Azure</a></li><li><a href="https://nitro.unjs.io/deploy/providers/cleavr">Cleavr</a></li><li><a href="https://nitro.unjs.io/deploy/providers/cloudflare">CloudFlare</a></li><li><a href="https://nitro.unjs.io/deploy/providers/digitalocean">Digital Ocean</a></li><li><a href="https://nitro.unjs.io/deploy/providers/firebase">Firebase</a></li><li><a href="https://nitro.unjs.io/deploy/providers/heroku">heroku</a></li><li><a href="https://nitro.unjs.io/deploy/providers/edgio">Edgio</a></li><li><a href="https://nitro.unjs.io/deploy/providers/netlify">Netlify</a></li><li><a href="https://nitro.unjs.io/deploy/providers/render">Render</a></li><li><a href="https://nitro.unjs.io/deploy/providers/stormkit">Stormkit</a></li><li><a href="https://nitro.unjs.io/deploy/providers/vercel">Vercel</a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>可以添加vitest库来进行测试</p><pre><code>yarn add --dev @nuxt/test-utils vitest</code></pre><p>方法如下</p><p>新建test目录 创建文件 <code>demo.test.ts</code></p><pre><code class="ts">import &#123; describe, test &#125; from &#39;vitest&#39;import &#123; setup, $fetch &#125; from &#39;@nuxt/test-utils&#39;describe(&#39;My test&#39;, async () =&gt; &#123;  await setup(&#123;    // test context options  &#125;)  test(&#39;my test&#39;, () =&gt; &#123;    // ...  &#125;)&#125;)</code></pre><p>运行vitest即可获得通过或不通过提示</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到这里nuxt3基础就几乎结束了</p><p>还有一些更高级的用法没有讲，例如生命周期啊，nuxt-kit啊，自动导入啊</p><p>有机会可以写一篇高级教程</p><p>😋😎</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/docs/getting-started/state-management">https://nuxt.com/docs/getting-started/state-management</a></p><p><a href="https://nuxt.com/docs/api/composables/use-state">https://nuxt.com/docs/api/composables/use-state</a></p><p><a href="https://juejin.cn/post/7193305766692913189">https://juejin.cn/post/7193305766692913189</a></p><p><a href="https://vueuse.org/">https://vueuse.org/</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/28/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8B%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt3与服务端渲染SSR（上） ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/27/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8A%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/27/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8A%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Fri, 27 Jan 2023 10:41:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 11 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nuxt同时提供了前端和后端功能，</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 11 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nuxt同时提供了前端和后端功能，因此您可以专注于重要的事情：创建web应用程序。</p><p><a href="https://nuxt.com/docs">Nuxt3</a> 是基于 <code>Vite</code>、<code>Vue3</code> 和 <code>Nitro</code> 的 <code>Nuxt</code> 框架的重构，具有一流的 <code>Typescript</code> 支持，且这次更新对内核进行了精简，使之速度更快，体验更好。</p><h2 id="了解-SSR"><a href="#了解-SSR" class="headerlink" title="了解 SSR"></a>了解 <code>SSR</code></h2><p><code>Nuxt</code> 是一个基于 <code>Vue.js</code> 的服务端渲染应用框架</p><h3 id="什么是-SSR"><a href="#什么是-SSR" class="headerlink" title="什么是 SSR"></a>什么是 <code>SSR</code></h3><p><code>服务器端渲染</code>（Server-Side Rendering）是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p><p>简单理解就是html是由服务端写出，可以动态改变页面内容，即所谓的动态页面。早年的 php 、 asp 、 jsp  这些 Server page 都是 SSR 的。</p><h3 id="为什么使用-SSR"><a href="#为什么使用-SSR" class="headerlink" title="为什么使用 SSR"></a>为什么使用 <code>SSR</code></h3><ul><li>网页内容在服务器端渲染完成，一次性传输到浏览器，所以 <code>首屏加载速度非常快</code>；</li><li><code>有利于SEO</code>，因为服务器返回的是一个完整的 html，在浏览器可以看到完整的 dom，对于爬虫、百度搜索等引擎就比较友好；</li></ul><h2 id="Nuxt-3"><a href="#Nuxt-3" class="headerlink" title="Nuxt 3"></a>Nuxt 3</h2><p><code>Nuxt</code> 是一个基于 <code>Vue.js</code> 的服务端渲染应用框架，</p><p>刚去查了一下 nuxt3在1月23日变成了默认版本</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003129.png"></p><p>在1月25日发布了3.1.0版本</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127185726.png"></p><ul><li><p>实验组件群岛 准备就绪</p></li><li><p>新的api</p></li><li><p>Nitro v2 ，vite 4 ，rollup3</p></li><li><p>性能改进</p></li></ul><h2 id="什么是Nuxt？"><a href="#什么是Nuxt？" class="headerlink" title="什么是Nuxt？"></a>什么是Nuxt？</h2><p>要理解Nuxt是什么，我们需要了解创建一个现代应用程序需要什么：</p><ul><li>JavaScript框架： 一个带来JavaScript组件的JavaScript框架，支持Vue.js。</li><li>打包工具：支持开发中的热模块替换和生产代码，支持webpack 5和Vite。</li><li>最新JavaScript语法：在支持遗留浏览器的同时编写最新的JavaScript语法的转换器，支持esbuild。</li><li>服务器端：Nuxt是一个在开发中服务于应用程序的服务器，同时也支持服务器端呈现或API路由，它使用h3进行部署的多功能性，如serverless, workers, Node.js和无与伦比的性能。</li><li>路由：一个处理客户端导航的路由库，支持 <a href="https://router.vuejs.org/">vue-router</a>.。</li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p><a href="https://nuxt.com/docs/getting-started/installation#prerequisites">https://nuxt.com/docs/getting-started/installation#prerequisites</a></p><pre><code class="bash">pnpm dlx nuxi init &lt;project-name&gt;</code></pre><pre><code class="bash">code &lt;project-name&gt;</code></pre><pre><code class="bash"># Make sure you have `shamefully-hoist=true` in `.npmrc` before running pnpm installpnpm install</code></pre><p><strong>注意：</strong> 如果你用 <code>pnpm</code> 安装依赖，请创建一个 <code>.npmrc</code> 文件，且设置:</p><pre><code class="ini">shamefully-hoist=true</code></pre><p>安装完成😋</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code class="bash">pnpm dev -o</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127193306.png"></p><p>看一眼文件树</p><p>抛开编译结果<code>.nuxt</code>文件夹不谈 就只有一个<code>app.vue</code> 和<code>nuxt.config.ts</code></p><p>很简陋 怎么会这样呢？我们一般写的vue框架也不是这样的啊</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127193603.png"></p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>创建 <code>components/</code> <code>pages/</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127200417.png"></p><p>具体操作见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/views">https://nuxt.com/docs/getting-started/views</a></p><p>也可以新建<code>src</code>目录 把 <code>components/</code> <code>pages/</code>目录放到<code>src</code>里</p><p>在nuxt里组件是自动导入的，不用配置</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>路由是自动创建的</p><pre><code class="html">&lt;NuxtLink to=&quot;/about&quot;&gt;About&lt;/NuxtLink&gt;</code></pre><p>以上的代码点击会自动跳到<code>page/about.vue</code></p><p>也可以使用路由</p><pre><code class="vue">&lt;script setup&gt;const route = useRoute()// When accessing /posts/1, route.params.id will be 1console.log(route.params.id)&lt;/script&gt;</code></pre><p><code>/posts/1</code>是创建的<code>/posts/[id].vue</code>这样id会被当做props传入</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>nuxt服务端渲染最重要的就是搜索引擎优化</p><p>可以被拉取到带内容的html</p><p>而不是一般vue项目的空html</p><pre><code class="js">export default defineNuxtConfig(&#123;  app: &#123;    head: &#123;      charset: &#39;utf-16&#39;,      viewport: &#39;width=500, initial-scale=1&#39;,      title: &#39;My App&#39;,      meta: [        // &lt;meta name=&quot;description&quot; content=&quot;My amazing site&quot;&gt;        &#123; name: &#39;description&#39;, content: &#39;My amazing site.&#39; &#125;      ],    &#125;  &#125;&#125;)</code></pre><p>在<code>nuxt.config.ts</code>配置如上内容</p><p>或者在<code>app.vue</code>里添加</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;useHead(&#123;  title: &#39;My App&#39;,  meta: [    &#123; name: &#39;description&#39;, content: &#39;My amazing site.&#39; &#125;  ],  bodyAttrs: &#123;    class: &#39;test&#39;  &#125;,  script: [ &#123; children: &#39;console.log(\&#39;Hello world\&#39;)&#39; &#125; ]&#125;)useServerSeoMeta(&#123;  title: &#39;My Amazing Site&#39;,  ogTitle: &#39;My Amazing Site&#39;,  description: &#39;This is my amazing site, let me tell you all about it.&#39;,  ogDescription: &#39;This is my amazing site, let me tell you all about it.&#39;,  ogImage: &#39;https://example.com/image.png&#39;,  twitterCard: &#39;summary_large_image&#39;,&#125;)&lt;/script&gt;</code></pre><p>这几个函数可以添加meta头</p><p>还有一些设置可以看官方文档 <a href="https://nuxt.com/docs/getting-started/seo-meta">https://nuxt.com/docs/getting-started/seo-meta</a></p><p>也可以使用 <a href="https://nuxt.com/modules/seo-kit">https://nuxt.com/modules/seo-kit</a></p><p>这个模块来配置SEO</p><p>很方便😎</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇文章介绍了大概一半的nuxt3特性，下一篇会介绍另外一半</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><p>😎</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/modules/seo-kit">https://nuxt.com/modules/seo-kit</a></p><p><a href="https://nuxt.com/docs/getting-started/seo-meta">https://nuxt.com/docs/getting-started/seo-meta</a></p><p><a href="https://nuxt.com/docs/getting-started/views">https://nuxt.com/docs/getting-started/views</a></p><p><a href="https://nuxt.com/docs">https://nuxt.com/docs</a></p><p><a href="https://juejin.cn/post/7170746000112353293">https://juejin.cn/post/7170746000112353293</a></p><p><a href="https://juejin.cn/post/7037336504418435103">https://juejin.cn/post/7037336504418435103</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/27/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8A%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>UnoCSS实战 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/26/UnoCSS%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/26/UnoCSS%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Thu, 26 Jan 2023 15:00:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 10 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原子化css体验&lt;/p&gt;
&lt;p&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 10 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原子化css体验</p><p><a href="https://link.juejin.cn/?target=https://antfu.me/posts/reimagine-atomic-css-zh">重新构想原子化 CSS (antfu.me)</a></p><p>本篇介绍一下如何配置UnoCSS、UnoCSS怎么使用</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先创建一个vite模板   <a href="https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project">https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project</a></p><p>这里使用pnpm</p><pre><code class="bash">pnpm create vite</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126210343.png"></p><p>选择vue、typescript</p><pre><code class="bash">cd vite-projectpnpm installpnpm run dev</code></pre><p>运行一下</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126210518.png"></p><p>初始化成功了，接下来安装unocss  <a href="https://github.com/unocss/unocss/tree/main/packages/vite">https://github.com/unocss/unocss/tree/main/packages/vite</a></p><p>使用文档给的vite安装方式</p><pre><code class="bash">pnpm i -D unocss</code></pre><p>在vite config里写上</p><pre><code class="ts">// vite.config.tsimport UnoCSS from &#39;unocss/vite&#39;export default &#123;  plugins: [    UnoCSS(&#123; /* options */ &#125;),  ],&#125;</code></pre><p>配置完全的vite config是这样的</p><pre><code class="ts">// vite.config.tsimport &#123; defineConfig &#125; from &#39;vite&#39;import vue from &#39;@vitejs/plugin-vue&#39;import UnoCSS from &#39;unocss/vite&#39;import &#123; presetUno &#125; from &#39;unocss&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    UnoCSS(&#123;      presets: [        presetUno(),      ],    &#125;),  ],&#125;)</code></pre><p>然后在<code>main.ts</code>里加入</p><pre><code class="ts">// main.tsimport &#39;uno.css&#39;</code></pre><p>这里没有eslint还是很不舒服的，推荐一个antfu的eslint配置，来安装一下eslint</p><p><a href="https://github.com/antfu/eslint-config">https://github.com/antfu/eslint-config</a></p><pre><code class="bash">pnpm add -D eslint @antfu/eslint-config</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126211558.png"></p><p>创建<code>.eslintrc</code>写入</p><pre><code>&#123;  &quot;extends&quot;: &quot;@antfu&quot;&#125;</code></pre><p>在package json里加入</p><pre><code class="json">&#123;  &quot;scripts&quot;: &#123;    &quot;lint&quot;: &quot;eslint .&quot;,    &quot;lint:fix&quot;: &quot;eslint . --fix&quot;  &#125;&#125;</code></pre><p>如果你使用的是VSCode 下载 <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">VS Code ESLint extension</a> 然后编辑 <code>.vscode/settings.json</code></p><pre><code class="json">&#123;  &quot;prettier.enable&quot;: false,  &quot;editor.formatOnSave&quot;: false,  &quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true  &#125;&#125;</code></pre><p>之后重启vscode</p><p>安装完成😎</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们来写一个小demo</p><p>就把原本的默认界面改成unocss好了</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126212340.png"></p><p>先看app.vue</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;/vite.svg&quot; class=&quot;logo&quot; alt=&quot;Vite logo&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;logo vue&quot; alt=&quot;Vue logo&quot;&gt;    &lt;/a&gt;  &lt;/div&gt;  &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;.logo &#123;  height: 6em;  padding: 1.5em;  will-change: filter;&#125;.logo:hover &#123;  filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123;  filter: drop-shadow(0 0 2em #42b883aa);&#125;&lt;/style&gt;</code></pre><p>改成原子化css的形式</p><p>这里最好先配置一下vite config 多加一点预设</p><pre><code class="ts">// vite.config.tsimport &#123; defineConfig &#125; from &#39;vite&#39;import vue from &#39;@vitejs/plugin-vue&#39;import UnoCSS from &#39;unocss/vite&#39;import &#123; presetAttributify, presetIcons, presetTypography, presetUno, presetWebFonts, transformerDirectives, transformerVariantGroup &#125; from &#39;unocss&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    UnoCSS(      &#123;        presets: [          presetUno(),          presetAttributify(),          presetIcons(&#123;            scale: 1.2,          &#125;),          presetTypography(),          presetWebFonts(&#123;            fonts: &#123;              sans: &#39;DM Sans&#39;,              serif: &#39;DM Serif Display&#39;,              mono: &#39;DM Mono&#39;,            &#125;,          &#125;),        ],        transformers: [          transformerDirectives(),          transformerVariantGroup(),        ],      &#125;,    ),  ],&#125;)</code></pre><p>我们先用@apply将css改一下 <code>&lt;style scoped&gt;</code></p><pre><code class="css">.logo &#123;  height: 6em;  padding: 1.5em;  will-change: filter;&#125;.logo:hover &#123;  filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123;  filter: drop-shadow(0 0 2em #42b883aa);&#125;</code></pre><p>这里不会的语法可以看tailwindcss文档</p><p>改成</p><pre><code class="css">.logo &#123;  @apply h-6em p-1.5em&#125;.logo &#123;  @apply hover:drop-shadow-[0_0_2em_#646cffaa]&#125;.logo.vue &#123;  @apply hover:drop-shadow-[0_0_2em_#42b883aa]&#125;</code></pre><p>怎么样？是不是感觉很清晰明了</p><p>这是在tailwindcss里很受欢迎的@apply命令 通过预设导入了unocss</p><p>但是这样体现不出原子化css的方便，虽然非常好看</p><p>我们把css写入html</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;/vite.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#646cffaa]&quot; alt=&quot;Vite logo&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;hover:drop-shadow-[0_0_2em_#42b883aa]&quot; alt=&quot;Vue logo&quot;&gt;    &lt;/a&gt;  &lt;/div&gt;  &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>这样写就很方便了</p><p>再看<code>HelloWorld.vue</code></p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;card&quot;&gt;    &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;count is &#123;&#123; count &#125;&#125;&lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot;      &gt;create-vue&lt;/a    &gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;read-the-docs&quot;&gt;Click on the Vite and Vue logos to learn more&lt;/p&gt;&lt;/template&gt;&lt;style scoped&gt;.read-the-docs &#123;  color: #888;&#125;&lt;/style&gt;</code></pre><p>这个改的比较少</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;card&quot;&gt;    &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;      count is &#123;&#123; count &#125;&#125;    &lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot;&gt;create-vue&lt;/a&gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;text-[#888]&quot;&gt;    Click on the Vite and Vue logos to learn more  &lt;/p&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>改成这样就行</p><p>再看<code>style.css</code>文件 内容比较多</p><pre><code class="css">:root &#123;  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;  font-size: 16px;  line-height: 24px;  font-weight: 400;  color-scheme: light dark;  color: rgba(255, 255, 255, 0.87);  background-color: #242424;  font-synthesis: none;  text-rendering: optimizeLegibility;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  -webkit-text-size-adjust: 100%;&#125;a &#123;  font-weight: 500;  color: #646cff;  text-decoration: inherit;&#125;a:hover &#123;  color: #535bf2;&#125;body &#123;  margin: 0;  display: flex;  place-items: center;  min-width: 320px;  min-height: 100vh;&#125;h1 &#123;  font-size: 3.2em;  line-height: 1.1;&#125;button &#123;  border-radius: 8px;  border: 1px solid transparent;  padding: 0.6em 1.2em;  font-size: 1em;  font-weight: 500;  font-family: inherit;  background-color: #1a1a1a;  cursor: pointer;  transition: border-color 0.25s;&#125;button:hover &#123;  border-color: #646cff;&#125;button:focus,button:focus-visible &#123;  outline: 4px auto -webkit-focus-ring-color;&#125;.card &#123;  padding: 2em;&#125;#app &#123;  max-width: 1280px;  margin: 0 auto;  padding: 2rem;  text-align: center;&#125;@media (prefers-color-scheme: light) &#123;  :root &#123;    color: #213547;    background-color: #ffffff;  &#125;  a:hover &#123;    color: #747bff;  &#125;  button &#123;    background-color: #f9f9f9;  &#125;&#125;</code></pre><p>一点点儿改</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126221543.png"></p><p>最后改成了这样 还挺还原的是不是</p><p>有一些媒体查询不会改</p><p>根元素没改</p><p>代码如下</p><pre><code class="css">// style.css:root &#123;  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;  font-size: 16px;  line-height: 24px;  font-weight: 400;  color-scheme: light dark;  color: rgba(255, 255, 255, 0.87);  background-color: #242424;  font-synthesis: none;  text-rendering: optimizeLegibility;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  -webkit-text-size-adjust: 100%;&#125;@media (prefers-color-scheme: light) &#123;  :root &#123;    color: #213547;    background-color: #ffffff;  &#125;  a:hover &#123;    color: #747bff;  &#125;  button &#123;    background-color: #f9f9f9;  &#125;&#125;</code></pre><pre><code class="vue">// HelloWorld.vue&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1 class=&quot;text-3.2em leading-tight&quot;&gt;    &#123;&#123; msg &#125;&#125;  &lt;/h1&gt;  &lt;div class=&quot;p-2em flex flex-col place-items-center&quot;&gt;    &lt;button      type=&quot;button&quot; class=&quot;      rounded-8px border-1px border-solid border-transparent      py-0.6em px-1.2em text-1em font-medium      bg-[#1a1a1a] cursor-pointer transition duration-250      hover:border-color-[#646cff]      focus:outline-4 focus:outline-[-webkit-focus-ring-color]      focus-visible:outline-4 focus-visible:outline-[-webkit-focus-ring-color]    &quot; @click=&quot;count++&quot;    &gt;      count is &#123;&#123; count &#125;&#125;    &lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;create-vue&lt;/a&gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;text-[#888]&quot;&gt;    Click on the Vite and Vue logos to learn more  &lt;/p&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code class="vue">// App.vue&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;m-0 flex flex-col place-items-center min-w-320px min-h-100vh&quot;&gt;    &lt;div class=&quot;max-w-1280px my-0 mx-auto p-2rem text-center&quot;&gt;      &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;        &lt;img src=&quot;/vite.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#646cffaa]&quot; alt=&quot;Vite logo&quot;&gt;      &lt;/a&gt;      &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;        &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#42b883aa]&quot; alt=&quot;Vue logo&quot;&gt;      &lt;/a&gt;    &lt;/div&gt;    &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>可以看出来虽然写的简单，但是还是比较乱</p><p>这样写的好处是，不用想类名，</p><p>如果加了@apply会更美观，但是还是要写类名，和普通css的区别就是简单了一些</p><p>同时还有一些自带的样式预设</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇我们介绍了UnoCSS的特点，UnoCSS的使用，还是改了挺长时间的，主要是不会写语法，要查tailwind文档 <a href="https://tailwindcss.com/docs">https://tailwindcss.com/docs</a></p><p>还有一些好几个值的css 不知道什么意思</p><pre><code class="css">outline: green solid 3px;/* mdn:颜色 | 样式 | 宽度 */</code></pre><pre><code class="css">outline: 4px auto -webkit-focus-ring-color;/* style.css */</code></pre><p>关于这种就不知道怎么写</p><p>最后只能掰成</p><pre><code>focus:outline-4 focus:outline-[-webkit-focus-ring-color]</code></pre><p>题外话：</p><blockquote><p>Anthony Fu大佬真的是我目前的偶像，狂热的开源爱好者，人长得又帅，做的东西又好</p></blockquote><p>🤣这是我在掘金搜unocss搜到的一篇文章中的第一句话 文章在这 <a href="https://juejin.cn/post/7028841960752283656">https://juejin.cn/post/7028841960752283656</a></p><p>antfu大佬确实也是我的偶像</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125225032.png"></p><p>22年秋季 antfu大佬在b站办过几场直播写代码，我基本上是每期必看，这个人非常有意思，有很多新鲜的点子，狠活也多 比如说</p><p><a href="https://github.com/antfu/1990-script">https://github.com/antfu/1990-script</a> 这个仓库教你怎么把GitHub历史穿越回1990年🤭</p><p>他的每个star比较多的仓库我都体验过，感觉设计灵感真的让人眼前一亮，启发基于社区，创造更快的轮子，更好玩的轮子</p><p><a href="https://github.com/antfu/retypewriter">https://github.com/antfu/retypewriter</a> 这个是直播写的雏形 让写的代码在vsc里回放，便于理清思路</p><p><a href="https://github.com/antfu/vue-minesweeper">https://github.com/antfu/vue-minesweeper</a> 这个是首次直播写的扫雷，很清晰的vue代码，看他写真的开窍</p><p><a href="https://github.com/antfu/vue-starport">https://github.com/antfu/vue-starport</a> 这个也是直播写的雏形，为了使组件有更好的过渡</p><p>就说这么多，人也长得帅</p><p>🥰😘</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">https://developer.mozilla.org/zh-CN/docs/Web/CSS</a></p><p><a href="https://tailwindcss.com/docs">https://tailwindcss.com/docs</a></p><p><a href="https://www.tailwindcss.cn/docs/functions-and-directives#apply">https://www.tailwindcss.cn/docs/functions-and-directives#apply</a></p><p><a href="https://github.com/unocss/unocss">https://github.com/unocss/unocss</a></p><p><a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/26/UnoCSS%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
