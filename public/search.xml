<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DNS 与 Pdns OpenWrt DNS 递归服务器搭建与 MosDNS 分流</title>
      <link href="/2023/10/18/DNS%20%E4%B8%8E%20Pdns%20OpenWrt%20DNS%20%E9%80%92%E5%BD%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%20MosDNS%20%E5%88%86%E6%B5%81/"/>
      <url>/2023/10/18/DNS%20%E4%B8%8E%20Pdns%20OpenWrt%20DNS%20%E9%80%92%E5%BD%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%20MosDNS%20%E5%88%86%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h2><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><p>简单来说就是用域名请求服务器换回来ip地址</p><p><a href="https://www.nslookup.io/">https://www.nslookup.io/</a></p><p>这个网站可以看dns请求的结果、同理还有linux或者windows的nslookup命令</p><p><strong>DNS records for dn11.top</strong></p><blockquote><p>A records</p></blockquote><table><thead><tr><th>IPv4 address</th><th>Revalidate in</th></tr></thead><tbody><tr><td>104.21.27.178</td><td>5m</td></tr><tr><td>172.67.143.107</td><td>5m</td></tr></tbody></table><p>DNS 服务器使人们无需存储复杂记不住的ip地址，而是记住有规律的域名来方便的访问互联网</p><h2 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h2><p>DNS 记录是位于权威 DNS 服务器中的指令，提供一个域的相关信息，包括哪些 IP 地址与该域关联，以及如何处理对该域的请求。</p><h3 id="常见的-DNS-记录"><a href="#常见的-DNS-记录" class="headerlink" title="常见的 DNS 记录"></a>常见的 DNS 记录</h3><p>SOA 记录 - 存储域的管理信息。</p><pre><code class="bash">;; ANSWER SECTION:dn11.top.               1800    IN      SOA     ophelia.ns.cloudflare.com. dns.cloudflare.com. 2322082117 10000 2400 604800 1800</code></pre><p>NS 记录 - 存储 DNS 条目的名称服务器。</p><pre><code class="bash">;; ANSWER SECTION:dn11.top.               21600   IN      NS      ophelia.ns.cloudflare.com.dn11.top.               21600   IN      NS      phil.ns.cloudflare.com.</code></pre><p>A 记录 - 保存域的 IPv4 地址的记录。</p><pre><code class="bash">;; ANSWER SECTION:dn11.top.               300     IN      A       104.21.27.178dn11.top.               300     IN      A       172.67.143.107</code></pre><p>AAAA 记录 - 包含域的 IPv6 地址的记录（与 A 记录相反，A 记录列出的是 IPv4 地址）。</p><p>CNAME 记录 - 将一个域或子域转发到另一个域，不提供 IP 地址。</p><p>MX 记录 - 将邮件定向到电子邮件服务器。</p><p>TXT 记录 - 可让管理员在记录中存储文本注释。这些记录通常用于电子邮件安全。</p><h2 id="有几种DNS服务器？有几种工作方式？"><a href="#有几种DNS服务器？有几种工作方式？" class="headerlink" title="有几种DNS服务器？有几种工作方式？"></a>有几种DNS服务器？有几种工作方式？</h2><p>有两种DNS服务器：DNS递归服务器和DNS权威服务器</p><p>有两种工作方式：递归和迭代</p><p>DNS客户端设置使用的DNS服务器一般都是DNS递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。</p><h2 id="如何工作的"><a href="#如何工作的" class="headerlink" title="如何工作的"></a>如何工作的</h2><p>DNS查询 涉及 4 个 DNS 服务器：</p><ol><li>DNS 递归解析器</li></ol><p>DNS 解析器是一种服务器，旨在通过 Web 浏览器等应用程序接收客户端计算机的查询。然后，解析器一<strong>般负责发出其他请求</strong>，以便满足客户端的 DNS 查询。</p><blockquote><p>常见的 dns 递归解析器有</p><p>谷歌 8.8.8.8  8.8.4.4</p><p>阿里 223.5.5.5 223.6.6.6</p><p>百度 180.76.76.76</p><p>腾讯DNSPod 119.29.29.29</p><p>CloudFlare 1.1.1.1</p><p>更多 <a href="https://en.wikipedia.org/wiki/Public_recursive_name_server">https://en.wikipedia.org/wiki/Public_recursive_name_server</a></p></blockquote><ol start="2"><li>根域名服务器</li></ol><p>根域名服务器是将主机名转换（解析）为 IP 地址的第一步。</p><p>根域名服务器（英语：root name server，简称“根域名服务器”）是互联网域名解析系统（DNS）中最高级别的域名服务器，负责返回顶级域的权威域名服务器地址。</p><p>任意正常 linux 发行版可以运行如下命令来看到这13台根域名服务器</p><pre><code class="bash">ubuntu@ubuntu_dn11:~$ dig ns . @8.8.8.8; &lt;&lt;&gt;&gt; DiG 9.18.12-0ubuntu0.22.04.3-Ubuntu &lt;&lt;&gt;&gt; ns . @8.8.8.8;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 9453;; flags: qr rd ra ad; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 512;; QUESTION SECTION:;.                              IN      NS;; ANSWER SECTION:.                       71928   IN      NS      a.root-servers.net..                       71928   IN      NS      b.root-servers.net..                       71928   IN      NS      c.root-servers.net..                       71928   IN      NS      d.root-servers.net..                       71928   IN      NS      e.root-servers.net..                       71928   IN      NS      f.root-servers.net..                       71928   IN      NS      g.root-servers.net..                       71928   IN      NS      h.root-servers.net..                       71928   IN      NS      i.root-servers.net..                       71928   IN      NS      j.root-servers.net..                       71928   IN      NS      k.root-servers.net..                       71928   IN      NS      l.root-servers.net..                       71928   IN      NS      m.root-servers.net.;; Query time: 0 msec;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP);; WHEN: Fri Oct 06 13:22:43 UTC 2023;; MSG SIZE  rcvd: 239</code></pre><p>全球13<strong>组</strong>根域名服务器以英文字母A到M依序命名，域名格式为“字母.root-servers.net”。利用任播（anycast）技术在全球多个地点设立镜像站。</p><p>截至2023年6月，全球共有1719台根域名服务器在运行。</p><blockquote><p>Q：为什么是13组？1700组不行吗？</p><p>A：由于DNS和某些协议（未分片的用户数据报协议（UDP）数据包在IPv4内的最大有效大小为512字节）的共同限制，根域名服务器地址的数量被限制为13个。一次返回的数据放不下啦~</p><p>Q：anycast是什么？</p><p>A：我们假设有三台服务器α、β、γ和一台客户机，这三台服务器都宣告了同样的一个地址比如说172.16.255.53，客户机访问172.16.255.53时，会因为路由协议的原因，选择客户机距离服务器最近的一条路径。假设α距离客户机近，访问172.16.255.53获得的数据就是α服务器给客户机的。</p><p>Q：anycast的好处？</p><p>A：防止服务挂掉、流量会自动寻找最佳路径、假设一台服务器挂掉了，整个服务会被另一台服务器承担。</p></blockquote><blockquote><p>Q：有 . 这个服务器吗</p><p>A：存放这13个根域的是一个文件，它被内置在递归服务器内，没有权威服务器会返回 . 这个域的解析给你。<br>在这里可以下载到这个文件 <a href="https://www.iana.org/domains/root/files">https://www.iana.org/domains/root/files</a><br>运营商通常需要配置一个 “Root Hints 文件” 来管理 DNS 递归解析器。该文件包含了根区域的权威名称服务器的名称和 IP 地址，以便软件可以引导 DNS 解析过程。对于许多软件来说，这个列表已经内置在软件中。<a href="https://www.internic.net/domain/named.root">https://www.internic.net/domain/named.root</a></p></blockquote><ol start="3"><li>TLD 名称服务器</li></ol><p>顶级域名（英语：Top-level Domain, TLD）是互联网域名系统的等级中，位于根域空间的最高级域名。</p><p>顶级域名服务器这个服务器是搜索特定 IP 地址的下一步，其上托管了主机名的最后一部分（例如，在 dn11.top 中，TLD 服务器为 “top”）。</p><p><a href="https://www.iana.org/domains/root/db">https://www.iana.org/domains/root/db</a> 这里是世界上完整的顶级域列表。</p><ol start="4"><li>权威性域名服务器</li></ol><p>权威性域名服务器是域名服务器查询中的最后一站。</p><p>权威名称服务器包含特定于其服务域名的信息（例如，dn11.top）权威性域名服务器包含特定于其所服务的域名的信息（例如 dn11.top），并且它可为递归解析器提供在 DNS A 记录中找到的服务器的 IP 地址（例如找到了上文的ipv4地址 104.21.27.178）</p><h2 id="图解工作流程"><a href="#图解工作流程" class="headerlink" title="图解工作流程"></a>图解工作流程</h2><h3 id="递归工作流程"><a href="#递归工作流程" class="headerlink" title="递归工作流程"></a>递归工作流程</h3><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20231006233612.png"></p><p>我这里画了一张图：其中红色服务器为DNS递归服务器，PC上的DNS客户端只与DNS递归服务器通讯，由递归服务器完成后续查询内容。蓝色云为想要访问的网站的ip地址所在的服务器。</p><p>我会逐一讲解每个过程（箭头）都做了什么。</p><p>本图的前提是dns递归服务器中不含任何缓存。</p><p>①：PC通过浏览器输入了dn11.top这个域名、dns客户端收到了请求dn11.top这个域名的ip的任务、dns客户端去请求DNS递归服务器</p><p>②：DNS递归服务器使用内置的Root Hint文件（内有根服务器的NS解析和根服务器的IP地址）去请求根权威服务器、得到了TLD服务器的NS解析并得到了TLD服务器的ip地址</p><p>③：TLD服务器的ip地址被返回给DNS递归服务器</p><p>④：DNS递归服务器去请求TLD服务器、得到了域名权威服务器的NS解析并得到了域名权威服务器的NS记录和IP地址</p><p>⑤：域名权威服务器的ip地址被返回给DNS递归服务器</p><p>⑥：DNS递归服务器去请求域名权威服务器、得到了请求域名最终的ip</p><p>⑦：请求域名最终的ip被返回给DNS递归服务器</p><p>⑧：请求域名最终的ip被返回给PC上的DNS客户端</p><p>⑨：PC上的浏览器用请求域名最终的ip访问域名所在的云服务器</p><p>⑩：云服务器返回网页数据给PC浏览器、实现页面的访问</p><h3 id="迭代工作流程"><a href="#迭代工作流程" class="headerlink" title="迭代工作流程"></a>迭代工作流程</h3><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20231015181102.png"></p><p>我这里画了一张图：其中红色服务器为DNS递归服务器，PC上的DNS客户端只与DNS递归服务器通讯，由递归服务器和权威服务器的迭代查询完成后续查询内容。蓝色云为想要访问的网站的ip地址所在的服务器。</p><p>我会逐一讲解每个过程（箭头）都做了什么。</p><p>本图的前提是dns递归服务器中不含任何缓存。</p><p>①：PC通过浏览器输入了dn11.top这个域名、dns客户端收到了请求dn11.top这个域名的ip的任务、dns客户端去请求DNS递归服务器</p><p>②：DNS递归服务器使用内置的Root Hint文件（内有根服务器的NS解析和根服务器的IP地址）去请求根权威服务器、根权威服务器收到了请求、找到了TLD权威服务器的NS记录和ip地址</p><p>③：根权威服务器请求TLD服务器、TLD服务器收到了请求、找到了域名权威服务器的NS记录和ip地址</p><p>④：TLD服务器请求域名权威服务器、权威服务器找到了域名的ip地址</p><p>⑤：域名的ip地址从域名权威服务器返回给TLD权威服务器</p><p>⑥：域名的ip地址从TLD权威服务器返回给根权威服务器</p><p>⑦：域名的ip地址从根权威返回给DNS递归服务器</p><p>⑧：请求域名最终的ip被返回给PC上的DNS客户端</p><p>⑨：PC上的浏览器用请求域名最终的ip访问域名所在的云服务器</p><p>⑩：云服务器返回网页数据给PC浏览器、实现页面的访问</p><h2 id="配置pdns"><a href="#配置pdns" class="headerlink" title="配置pdns"></a>配置pdns</h2><h3 id="1-openwrt直接启动"><a href="#1-openwrt直接启动" class="headerlink" title="1.openwrt直接启动"></a>1.openwrt直接启动</h3><h4 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h4><pre><code>opkg updateopkg install pdns pdns-backend-sqlite3 pdns-recursor sqlite3-cli</code></pre><h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><p>创建文件</p><pre><code>mkdir -p /usr/share/doc/pdns-backend-sqlite/touch schema.sqlite3.sql</code></pre><p>然后在schema.sqlite3.sql里写入</p><pre><code>nano /usr/share/doc/pdns-backend-sqlite/schema.sqlite3.sql</code></pre><pre><code class="sql">PRAGMA foreign_keys = 1;CREATE TABLE domains (  id                    INTEGER PRIMARY KEY,  name                  VARCHAR(255) NOT NULL COLLATE NOCASE,  master                VARCHAR(128) DEFAULT NULL,  last_check            INTEGER DEFAULT NULL,  type                  VARCHAR(8) NOT NULL,  notified_serial       INTEGER DEFAULT NULL,  account               VARCHAR(40) DEFAULT NULL,  options               VARCHAR(65535) DEFAULT NULL,  catalog               VARCHAR(255) DEFAULT NULL);CREATE UNIQUE INDEX name_index ON domains(name);CREATE INDEX catalog_idx ON domains(catalog);CREATE TABLE records (  id                    INTEGER PRIMARY KEY,  domain_id             INTEGER DEFAULT NULL,  name                  VARCHAR(255) DEFAULT NULL,  type                  VARCHAR(10) DEFAULT NULL,  content               VARCHAR(65535) DEFAULT NULL,  ttl                   INTEGER DEFAULT NULL,  prio                  INTEGER DEFAULT NULL,  disabled              BOOLEAN DEFAULT 0,  ordername             VARCHAR(255),  auth                  BOOL DEFAULT 1,  FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE INDEX records_lookup_idx ON records(name, type);CREATE INDEX records_lookup_id_idx ON records(domain_id, name, type);CREATE INDEX records_order_idx ON records(domain_id, ordername);CREATE TABLE supermasters (  ip                    VARCHAR(64) NOT NULL,  nameserver            VARCHAR(255) NOT NULL COLLATE NOCASE,  account               VARCHAR(40) NOT NULL);CREATE UNIQUE INDEX ip_nameserver_pk ON supermasters(ip, nameserver);CREATE TABLE comments (  id                    INTEGER PRIMARY KEY,  domain_id             INTEGER NOT NULL,  name                  VARCHAR(255) NOT NULL,  type                  VARCHAR(10) NOT NULL,  modified_at           INT NOT NULL,  account               VARCHAR(40) DEFAULT NULL,  comment               VARCHAR(65535) NOT NULL,  FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE INDEX comments_idx ON comments(domain_id, name, type);CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);CREATE TABLE domainmetadata ( id                     INTEGER PRIMARY KEY, domain_id              INT NOT NULL, kind                   VARCHAR(32) COLLATE NOCASE, content                TEXT, FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE INDEX domainmetaidindex ON domainmetadata(domain_id);CREATE TABLE cryptokeys ( id                     INTEGER PRIMARY KEY, domain_id              INT NOT NULL, flags                  INT NOT NULL, active                 BOOL, published              BOOL DEFAULT 1, content                TEXT, FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE INDEX domainidindex ON cryptokeys(domain_id);CREATE TABLE tsigkeys ( id                     INTEGER PRIMARY KEY, name                   VARCHAR(255) COLLATE NOCASE, algorithm              VARCHAR(50) COLLATE NOCASE, secret                 VARCHAR(255));CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm);</code></pre><p>初始化sqlite3</p><pre><code>mkdir -p /etc/powerdns/sqlite3 /etc/powerdns/pdns.sqlite3 &lt; /usr/share/doc/pdns-backend-sqlite/schema.sqlite3.sqlchmod +r /etc/powerdns</code></pre><h4 id="配置pdns-1"><a href="#配置pdns-1" class="headerlink" title="配置pdns"></a>配置pdns</h4><pre><code>nano /etc/powerdns/pdns.conf</code></pre><p>写入</p><pre><code>launch=gsqlite3gsqlite3-database=/etc/powerdns/pdns.sqlite3local-address=&lt;!!你的地址!!&gt;:53allow-axfr-ips=0.0.0.0/0slave=yesallow-notify-from=0.0.0.0/0allow-dnsupdate-from=0.0.0.0/0allow-unsigned-notify=yes</code></pre><p>解释：由于我们正在配置pdns权威服务器，地址可以选一个你自己子网你喜欢的、比如说我在<code>172.16.3.53</code></p><p>当然监听这种地址需要在网卡上创建一个新ip</p><p>对于op来说 可以在web管理界面 选择网络 新建一个接口 区域lan 设备br-lan 地址为<code>172.16.3.53</code></p><p>对于监听53端口、你的本地dnsmasq可能会劫持这个端口</p><p>在此我给出的解决方案是关闭dnsmasq</p><pre><code>service dnsmasq stopservice dnsmasq disable</code></pre><p>然后由于我的dnsmasq会不知道怎么着复活 我写了一个脚本来按死他</p><pre><code>nano /root/stop_dnsmasq_if_running.sh</code></pre><pre><code class="bash">#!/bin/sh # 检查 dnsmasq 是否在运行在端口53上if netstat -tlunpa | grep &#39;:53 &#39; | grep -q &#39;dnsmasq&#39;; then    service dnsmasq stopfi</code></pre><pre><code>crontab -e</code></pre><pre><code>* * * * * /root/stop_dnsmasq_if_running.sh</code></pre><p>这个的意思是一个定时脚本 每分钟检测一下 如果他开着 就给他关掉</p><h4 id="启动pdns"><a href="#启动pdns" class="headerlink" title="启动pdns"></a>启动pdns</h4><pre><code>service pdns restart</code></pre><p>配置自己的子域</p><pre><code>pdnsutil create-zone ts.dn11 ns1.ts.dn11</code></pre><p>其中ts换成你想用的域名</p><pre><code>pdnsutil edit-zone ts.dn11</code></pre><p>edit-zone会唤醒叫editor的编辑器，如果你没有这个叫editor的编辑器 可以写一下环境变量</p><pre><code>nano /etc/profile</code></pre><p>添加一行</p><pre><code>export EDITOR=/usr/bin/nano</code></pre><p>(op的nano默认安装位置在这里、其他你想配的自由发挥)</p><pre><code>source /etc/profile</code></pre><p>打开edit-zone后 写入</p><pre><code>; Warning - every name in this file is ABSOLUTE!$ORIGIN .ts.dn11 3600    IN      SOA     ns1.ts.dn11 hostmaster.ts.dn11 2023093018 60 30 604800 60ts.dn11 3600    IN      NS      ns1.ts.dn11.ns1.ts.dn11     3600    IN      A     172.16.3.53ts.dn11 60      IN      A       172.16.3.1</code></pre><p>解释：SOA记录里第一个值是你域名权威服务器所在的NS、第二个为邮箱、第三个为流水号（格式YYYYMMDD+2位顺序号）（如果你不改的话pdns会自动帮你顺延流水号）、第四个为刷新间隔、第五个为重试间隔、第六个为过期时间长、第七个为TTL（生存时间值、意为缓存过期时间、设置为60s）</p><p>最后一行就是给你的域名加一个A解析</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><pre><code>dig a ts.dn11 @172.16.3.53 -p 53</code></pre><p>如果返回类似如下内容则成功</p><pre><code>root@OP:~# dig a ts.dn11 @172.16.3.53 -p 53; &lt;&lt;&gt;&gt; DiG 9.18.16 &lt;&lt;&gt;&gt; a ts.dn11 @172.16.3.53 -p 53;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 58804;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; WARNING: recursion requested but not available;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;ts.dn11.                       IN      A;; ANSWER SECTION:ts.dn11.                60      IN      A       172.16.3.1;; Query time: 0 msec;; SERVER: 172.16.3.53#53(172.16.3.53) (UDP);; WHEN: Sun Oct 15 18:55:04 CST 2023;; MSG SIZE  rcvd: 52</code></pre><h4 id="配置TLD域、拉取同步"><a href="#配置TLD域、拉取同步" class="headerlink" title="配置TLD域、拉取同步"></a>配置TLD域、拉取同步</h4><p>内网用户需要访问 <a href="http://172.16.7.102:8083/login">http://172.16.7.102:8083/login</a> （账号密码dn11）来配置自己的域名权威的ns指向</p><p>点击dn11域、点击 add record 、添加两条记录</p><pre><code>ns1.ts    A      172.16.3.53ts        NS     ns1.ts.dn11.</code></pre><p>之后点击 save 然后点击 apply changes</p><p>解释：ns1是你本地自己启的域名权威服务器的地址</p><p>然后回到本地 输入</p><pre><code>pdnsutil create-zone dn11</code></pre><p>创建dn11域</p><pre><code>pdnsutil edit-zone dn11</code></pre><p>修改里面的soa值为</p><pre><code>dn11    300     IN      SOA     a.root.dn11 hostmaster.dn11 1 60 60 604800 60</code></pre><p>解释：流水号填小 便于拉取上游的同步</p><p>然后写数据库启用主从同步</p><pre><code>sqlite3 /etc/powerdns/pdns.sqlite3</code></pre><p>进入sqlite命令行</p><p>先启用看头</p><pre><code>sqlite&gt; .header yes</code></pre><pre><code>sqlite&gt; select * from domains;id|name|master|last_check|type|notified_serial|account|options|catalog1|ts.dn11|||NATIVE||||2|dn11|||NATIVE||||</code></pre><p>里面大概也许是这样、然后写数据库同步上游</p><pre><code>UPDATE domainsSET master = &#39;172.16.7.53&#39;, type = &#39;SLAVE&#39;WHERE name = &#39;dn11&#39;;</code></pre><p>写完按 ctrl + D 退出sqlite命令行</p><p>然后使用</p><pre><code>pdns_control retrieve dn11</code></pre><p>强制拉取一下dn11的记录</p><p>最后看下自己的记录有没有被同步</p><pre><code>root@OP:~# pdnsutil list-zone dn11</code></pre><p>检查一下</p><pre><code>root@OP:~# dig ns ts.dn11 @172.16.3.53 -p 53; &lt;&lt;&gt;&gt; DiG 9.18.16 &lt;&lt;&gt;&gt; ns ts.dn11 @172.16.3.53 -p 53;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 7351;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; WARNING: recursion requested but not available;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;ts.dn11.                       IN      NS;; ANSWER SECTION:ts.dn11.                60      IN      NS      172.16.3.53.;; Query time: 0 msec;; SERVER: 172.16.3.53#53(172.16.3.53) (UDP);; WHEN: Sun Oct 15 19:12:09 CST 2023;; MSG SIZE  rcvd: 61</code></pre><h4 id="配置pdns-recursor"><a href="#配置pdns-recursor" class="headerlink" title="配置pdns_recursor"></a>配置pdns_recursor</h4><pre><code>nano /etc/powerdns/recursor.conf</code></pre><p>写入</p><pre><code># 接受哪些IP的查询请求，0.0.0.0/0表示全部allow-from=0.0.0.0/0# 本地监听的接口IP地址local-address=172.16.255.53:53 172.16.255.53:5300# 关闭dnssec功能，4.5版本后默认开启dnssec=offdont-query=forward-zones-recurse=dn11=172.16.3.53,.=223.5.5.5</code></pre><p>解释：</p><p>本地监听的ip地址这里使用anycast、同样的你需要在你的网卡里加一个ip为172.16.255.53（监听5300的原因是、如果路由路径上有人开了dnsmasq、那么这个53请求会被劫持）</p><p>并且宣告</p><pre><code>root@OP:~# cat /etc/bird.conf.........# 宣告 172.16.3.0/24 段protocol static &#123;    ipv4 &#123;        table BGP_table;        import all;        export none;    &#125;;    # 只是为了让BGP的路由表里出现这条路由，不要担心 reject    # 这个动作其实无所谓，reject 这个动作并不会被发到其他 AS    # 后续将在导出到 master4 的时候删除这条路由，本地也不会有这一条    # 请修改为你自己要宣告的段    route 172.16.3.0/24 reject;    route 172.16.255.53/32 reject;&#125;.........root@OP:~# service bird restart</code></pre><p>dont-query&#x3D;的意思是允许内网地址进行查询（默认是禁止的、所以这里填空）</p><p>forward-zones-recurse&#x3D;dn11&#x3D;172.16.3.53,.&#x3D;223.5.5.5</p><p>这个递归配置项的意思是：如果请求到了dn11这个TLD就去请求你自己搭的ns、如果不是这个域就当公网处理转发给公网dns 223.5.5.5</p><p>然后重启</p><pre><code>service pdns-recursor restart</code></pre><p>最后测试一下、请求一下网里存在的域名</p><pre><code>root@OP:~# dig op.iraze.dn11 @172.16.255.53 -p 53; &lt;&lt;&gt;&gt; DiG 9.18.16 &lt;&lt;&gt;&gt; op.iraze.dn11 @172.16.255.53 -p 53;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 4037;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 512;; QUESTION SECTION:;op.iraze.dn11.                 IN      A;; ANSWER SECTION:op.iraze.dn11.          60      IN      A       172.16.2.2;; Query time: 39 msec;; SERVER: 172.16.255.53#53(172.16.255.53) (UDP);; WHEN: Sun Oct 15 19:23:32 CST 2023;; MSG SIZE  rcvd: 58</code></pre><h3 id="2-docker拉镜像-装pdns-admin-web界面管理"><a href="#2-docker拉镜像-装pdns-admin-web界面管理" class="headerlink" title="2.docker拉镜像 装pdns-admin web界面管理"></a>2.docker拉镜像 装pdns-admin web界面管理</h3><pre><code>[root@gs-fedora Pdns]# cat docker-compose.yml version: &quot;3&quot;services:  pdns:    image: zhonger/pdns:latest    restart: always    ports:      - &quot;172.16.7.53:53:53/tcp&quot;      - &quot;172.16.7.53:53:53/udp&quot;    environment:      - PDNS_launch=gsqlite3      - PDNS_gsqlite3_database=/var/lib/powerdns/pdns.sqlite3      - PDNS_webserver_address=0.0.0.0      - PDNS_webserver_allow_from=0.0.0.0/0      - PDNS_allow_axfr_ips=0.0.0.0/0,::1      - PDNS_allow_dnsupdate_from=0.0.0.0/0,::1      - PDNS_allow_notify_from=0.0.0.0/0,::0      - PDNS_also_notify=172.16.3.53      - PDNS_master=yes      - PDNS_api=yes      - PDNS_api_key=0F34664B2C9CA2E1B84C5A6B4605C968    volumes:      - /etc/localtime:/etc/localtime:ro      - ./powerdns:/var/lib/powerdns    command: /bin/bash ./up.sh    privileged: true  db:    image: mysql:latest    environment:      - MYSQL_ALLOW_EMPTY_PASSWORD=yes      - MYSQL_DATABASE=powerdnsadmin      - MYSQL_USER=pdns       - MYSQL_PASSWORD=my_pdns    restart: always    volumes:      - /etc/localtime:/etc/localtime:ro      - ./pda-mysql:/var/lib/mysql    privileged: true  app:    image: zhonger/powerdns-admin:latest    restart: always    depends_on:      - db      - pdns    ports:      - &quot;8083:80&quot;    logging:      driver: json-file      options:        max-size: 50m    volumes:      - /etc/localtime:/etc/localtime:ro    environment:      - SQLALCHEMY_DATABASE_URI=mysql://pdns:my_pdns@db/powerdnsadmin      - GUNICORN_TIMEOUT=60      - GUNICORN_WORKERS=2      - GUNICORN_LOGLEVEL=DEBUG      - OFFLINE_MODE=False # True for offline, False for external resources     privileged: true</code></pre><pre><code>[root@gs-fedora Pdns]# cat up.sh service system-resolve stopip addr add 172.16.7.53 dev eno1</code></pre><p>这个key是我随便写的、你可以自己生成一个</p><p>PDNS_api_key&#x3D;0F34664B2C9CA2E1B84C5A6B4605C968</p><p>在powerdns admin settings pdns中填写这个key 填好后 在上层的PowerDNS server configuration &amp; statistics里能看到一系列pdns的字段</p><h2 id="配置dns分流-MosDNS"><a href="#配置dns分流-MosDNS" class="headerlink" title="配置dns分流 MosDNS"></a>配置dns分流 MosDNS</h2><p>装包</p><pre><code>opkg updateopkg install mosdns</code></pre><p>注意不要装 luci-app-mosdns 我感觉不好用</p><p>改配置</p><pre><code>nano /etc/mosdns/config.yaml</code></pre><pre><code>log:  level: info  file: &quot;/tmp/mosdns.log&quot;api:  http: &quot;0.0.0.0:9091&quot;include: []plugins:  - tag: main_sequence    type: sequence    args:      # hdu内网dns解析      - matches: qname hdu.edu.cn        exec: forward 192.168.0.1:53      # dn11内网dns解析      - matches: qname dn11        exec: forward 172.16.255.53:5300      # 其他dns解析      - matches: &quot;!qname hdu.edu.cn dn11&quot;        exec: forward 223.5.5.5:53  # 启动端口和ip  - tag: udp_server_2    type: udp_server    args:      entry: main_sequence      listen: &quot;172.16.3.13:53&quot;  - tag: tcp_server_2    type: tcp_server    args:      entry: main_sequence      listen: &quot;172.16.3.13:53&quot;</code></pre><p>同样的 启动需要你br-lan网卡里加一个 172.16.3.13这个ip地址</p><pre><code>service mosdns restart</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DN11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DN11 使用 EBGP 重分发 IBGP OSPF（同as内部peer）</title>
      <link href="/2023/09/20/DN11%20%E4%BD%BF%E7%94%A8%20EBGP%20%E9%87%8D%E5%88%86%E5%8F%91%20IBGP%20OSPF%EF%BC%88%E5%90%8Cas%E5%86%85%E9%83%A8peer%EF%BC%89/"/>
      <url>/2023/09/20/DN11%20%E4%BD%BF%E7%94%A8%20EBGP%20%E9%87%8D%E5%88%86%E5%8F%91%20IBGP%20OSPF%EF%BC%88%E5%90%8Cas%E5%86%85%E9%83%A8peer%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="DN11-使用-EBGP-重分发-IBGP-OSPF（同as内部peer）"><a href="#DN11-使用-EBGP-重分发-IBGP-OSPF（同as内部peer）" class="headerlink" title="DN11 使用 EBGP 重分发 IBGP OSPF（同as内部peer）"></a>DN11 使用 EBGP 重分发 IBGP OSPF（同as内部peer）</h1><h2 id="连接-wg-peer"><a href="#连接-wg-peer" class="headerlink" title="连接 wg peer"></a>连接 wg peer</h2><p>1.本地机器</p><pre><code class="nginx"># wg_aws.conf[Interface]# 你的私钥PrivateKey = &lt;PRIVATEKAY&gt;# 你开的端口号（注意防火墙）ListenPort = &lt;PORT&gt;PostUp = /sbin/ip addr add dev %i &lt;your ip&gt; peer &lt;peer ip&gt;# 不创建路由（由路由协议接管）Table = off[Peer]# 你对端的ip和端口（外网机器）Endpoint = &lt;ENDPOINT&gt;:&lt;PORT&gt;# 你对端的公钥（外网机器）PublicKey = &lt;PUBLICKEY&gt; AllowedIPs = 0.0.0.0/0</code></pre><p>2.外网机器</p><pre><code class="nginx"># wg_ts_home.conf[Interface]# 你的私钥PrivateKey = &lt;PRIVATEKAY&gt;# 你开的端口号（注意防火墙）ListenPort = &lt;PORT&gt;PostUp = /sbin/ip addr add dev %i &lt;your ip&gt; peer &lt;peer ip&gt;# 不创建路由（由路由协议接管）Table = off# wg 默认的 MTU 是 1420 （这里主要排除外网机器 MTU 异常的问题，洞里打洞不要配这个）MTU = 1420[Peer]# 你对端的ip和端口（本地机器）Endpoint = &lt;ENDPOINT&gt;:&lt;PORT&gt;# 你对端的公钥（本地机器）PublicKey = &lt;PUBLICKEY&gt; AllowedIPs = 0.0.0.0/0</code></pre><h2 id="bird配置"><a href="#bird配置" class="headerlink" title="bird配置"></a>bird配置</h2><p>创建</p><pre><code class="bash">/etc/bird.conf/etc/bird/ospf.conf/etc/bird/ibgp.conf/etc/bird/bgp.conf</code></pre><p>这四个文件</p><p>内网 openwrt 和外网机器上几乎需要相同的这四个文件（唯一不同的是 bgp neighbor 那里）</p><blockquote><p>文中的 172.16.3.254、172.16.3.91 改为你本机（你的本地机器或者外网机器）的隧道ip<br>文中的 4211112243 改为你的 asn （别整出俩 as 号就行）</p></blockquote><h3 id="x2F-etc-x2F-bird-conf"><a href="#x2F-etc-x2F-bird-conf" class="headerlink" title="&#x2F;etc&#x2F;bird.conf"></a>&#x2F;etc&#x2F;bird.conf</h3><pre><code class="nginx">log syslog all;debug protocols all;router id 172.16.3.254;ipv4 table BGP_table;ipv4 table OSPF_table;ipv4 table IBGP_table;protocol device&#123;&#125;protocol kernel&#123;    ipv4 &#123;        export all;        import none;    &#125;;&#125;include &quot;/etc/bird/ospf.conf&quot;;include &quot;/etc/bird/ibgp.conf&quot;;include &quot;/etc/bird/bgp.conf&quot;;protocol pipe PIPE_OSPF_BGP&#123;    table BGP_table;    peer table OSPF_table;    import all;    export none;&#125;protocol pipe PIPE_BGP_MASTER4&#123;    table master4;    peer table BGP_table;    import filter &#123;        if source = RTS_STATIC then reject;        krt_prefsrc = 172.16.3.254;        accept;    &#125;;    export none;&#125;protocol pipe PIPE_IBGP_BGP &#123;    table BGP_table;    peer table IBGP_table;    import filter &#123;        if source = RTS_OSPF then reject;        accept;    &#125;;    export filter &#123;        if source = RTS_STATIC then reject;        accept;    &#125;;&#125;# 宣告 172.16.3.0/24 段protocol static &#123;    ipv4 &#123;        table BGP_table;        import all;        export none;    &#125;;    # 只是为了让BGP的路由表里出现这条路由，不要担心 reject    # 这个动作其实无所谓，reject 这个动作并不会被发到其他 AS    # 后续将在导出到 master4 的时候删除这条路由，本地也不会有这一条    # 请修改为你自己要宣告的段    route 172.16.3.0/24 reject;&#125;</code></pre><h3 id="x2F-etc-x2F-bird-x2F-ibgp-conf"><a href="#x2F-etc-x2F-bird-x2F-ibgp-conf" class="headerlink" title="&#x2F;etc&#x2F;bird&#x2F;ibgp.conf"></a>&#x2F;etc&#x2F;bird&#x2F;ibgp.conf</h3><pre><code class="nginx">template bgp ibgp_peers &#123;    local as 4211112243;    source address 172.16.3.254;    multihop;    ipv4 &#123;        next hop self;        igp table OSPF_table;        table IBGP_table;        import all;        export all;    &#125;;&#125;protocol bgp ibgp_aws from ibgp_peers &#123;    neighbor 172.16.3.91 internal;&#125;</code></pre><h2 id="bgp-conf"><a href="#bgp-conf" class="headerlink" title="bgp.conf"></a>bgp.conf</h2><pre><code class="nginx">template bgp BGP_peers &#123;    local 172.16.3.254 as 4211112243;    ipv4 &#123;        table BGP_table;        import all;        export filter &#123;            if source ~ [RTS_STATIC, RTS_BGP, RTS_OSPF] then accept;            reject;        &#125;;    &#125;;&#125;# collector 配置protocol bgp collect_self &#123;    local as 4211112243;    multihop;    neighbor 172.16.255.1 as 4211110101;    ipv4 &#123;        add paths tx;        table BGP_table;        import none;        export filter &#123;            if source ~ [RTS_BGP,RTS_STATIC] then accept;        &#125;;    &#125;;&#125;# 如下的 neighbor 配置应按照 wg 实际链接数量为准# 从模板定义一个BGP邻居# protocol bgp protocol 名称 from 模板名称protocol bgp baimeow from BGP_peers &#123;   neighbor 172.16.4.254%baimeow as 4220084444;&#125;# 如下为 如果你有物理链路的 BGP 配置 （没有的别抄）# protocol bgp Meva_phy from BGP_peers &#123;#     source address 172.16.3.1;#     neighbor 172.16.3.97%&#39;br-lan&#39; as 4211111024;# #     ipv4 &#123;#     import filter &#123;#             if bgp_path ~ [= 4211111024 =] then bgp_local_pref = 120;#             bgp_next_hop = 172.16.3.97;#             accept;#         &#125;;#     &#125;;# &#125;</code></pre><h2 id="ospf-conf"><a href="#ospf-conf" class="headerlink" title="ospf.conf"></a>ospf.conf</h2><pre><code class="nginx">protocol ospf v2 ospf_aws &#123;        ipv4 &#123;                table OSPF_table;                export all;                import all;        &#125;;        area 0.0.0.0 &#123;                interface &quot;wg_aws&quot; &#123;                        cost 20;                        type ptp;                &#125;;                interface &quot;lo&quot; &#123;                        type bcast;                &#125;;        &#125;;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DN11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-zero api文件生成项目框架 ｜ 青训营笔记</title>
      <link href="/2023/08/30/go-zero%20api%E6%96%87%E4%BB%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/30/go-zero%20api%E6%96%87%E4%BB%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="go-zero-api文件生成项目框架"><a href="#go-zero-api文件生成项目框架" class="headerlink" title="go-zero api文件生成项目框架"></a>go-zero api文件生成项目框架</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>.api文件是go-zero自创的文件格式，和protobuf的语法有很大不同，但好在不难理解。具体语法介绍可看官网文档：<a href="https://link.juejin.cn/?target=https://go-zero.dev/docs/tasks/dsl/api">go-zero.dev&#x2F;docs&#x2F;tasks&#x2F;…</a></p><p>先编写接口定义，然后直接一次性使用 goctl 生成代码。</p><p>api文件支持将一个数据结构嵌入另一个结构中，便于编写统一的响应格式。</p><p>首先定义空请求结构和基础的响应结构：</p><pre><code class="api">syntax = &quot;v1&quot;    type Empty &#123;  &#125;    type BasicResponse &#123;      StatusCode int32 `json:&quot;status_code&quot;`      StatusMsg string `json:&quot;status_msg&quot;`  &#125;</code></pre><p>type关键字也支持代码块，只需要用<code>type()</code>包裹，就可以省去关键词。下面定义了注册和登录的请求和响应结构。</p><pre><code class="go">type (      RegisterRequest struct &#123;          Username string `form:&quot;username&quot;`          Password string `form:&quot;password&quot;`      &#125;      RegisterResponse struct &#123;          BasicResponse          UserId int64 `json:&quot;user_id&quot;`       &#125;  )    type (      LoginRequest struct &#123;          Username string `form:&quot;username&quot;`          Password string `form:&quot;password&quot;`      &#125;      LoginResponse struct &#123;          BasicResponse          UserId int64 `json:&quot;user_id&quot;`      &#125;  )</code></pre><p>最后还要定义一个获取用户信息的接口。因为本文不涉及创作、社交方面的业务逻辑实现，所以<code>User</code>结构其实没什么可以返回的信息。之后将其嵌入响应类型的<code>user</code>字段中：</p><pre><code class="go">type (      User &#123;          Id int64 `json:&quot;id&quot;`          Name string `json:&quot;name&quot;`      &#125;          GetUserInfoRequest struct &#123;          UserId int64 `form:&quot;user_id&quot;`       &#125;      GetUserInfoResponse struct &#123;          BasicResponse          User User `json:&quot;user&quot;`      &#125;  )</code></pre><h2 id="定义接口路由"><a href="#定义接口路由" class="headerlink" title="定义接口路由"></a>定义接口路由</h2><p>把所有api路由配置好</p><pre><code class="api">@server(      group: app  )  service app &#123;      @handler Ping      get /ping (Empty) returns (BasicResponse)  &#125;    @server(      group: user      prefix: /douyin/user  )  service app &#123;      @handler Register      post /register (RegisterRequest) returns (RegisterResponse)        @handler Login      post /login (LoginRequest) returns (LoginResponse)        @handler GetUserInfo      get / (GetUserInfoRequest) returns (GetUserInfoResponse)  &#125;</code></pre><p>以下几点需要注意：</p><ol><li>如果service代码块有多个，要求后面的名称（即“app”）相同</li><li>形如装饰器的@server代码块可以做代码分组、路由前缀、鉴权、中间件等多种配置。<ul><li>这里把路由分成app和user两组，之后生成时会分组放在文件夹里</li><li>给user组设置了<code>/douyin/user</code>的路由器前缀，就不用重复写了</li><li>鉴权和中间件配置下文会提到</li></ul></li><li>每个接口需要一个<code>handler</code>，其实就是给函数起名</li><li>接口定义的格式是 <code>&lt;HTTP方法&gt; &lt;子路径&gt; (&lt;请求数据结构&gt;) returns (&lt;响应数据结构&gt;) </code></li></ol><h2 id="创建项目模板"><a href="#创建项目模板" class="headerlink" title="创建项目模板"></a>创建项目模板</h2><p>这次不是新建示例项目，而是根据现有的api声明创建</p><p>安装 goctl</p><p><a href="https://go-zero.dev/docs/tasks/installation/goctl">https://go-zero.dev/docs/tasks/installation/goctl</a></p><pre><code class="bash">$ GO111MODULE=on go install github.com/zeromicro/go-zero/tools/goctl@latest</code></pre><p>安装 protoc</p><p><a href="https://go-zero.dev/docs/tasks/installation/protoc">https://go-zero.dev/docs/tasks/installation/protoc</a></p><pre><code class="bash">$ goctl env check --install --verbose --force</code></pre><pre><code class="shell">goctl api go --api app.api --dir=. --style=goZero </code></pre><p>这会在当前目录生成项目文件。之后进入目录安装依赖：</p><pre><code class="shell">go mod tidy</code></pre><h2 id="测试Ping接口"><a href="#测试Ping接口" class="headerlink" title="测试Ping接口"></a>测试Ping接口</h2><p>Ping接口的逻辑在<code>internal/logic/app/pingLogic.go</code>，打开文件并编辑handler函数：</p><pre><code class="go">func (l *PingLogic) Ping(req *types.Empty) (resp *types.BasicResponse, err error) &#123;      return &amp;types.BasicResponse&#123;        StatusCode: 0,        StatusMsg:  &quot;pong&quot;,    &#125;, nil&#125;</code></pre><p>这里的写法和rpc微服务有点区别。注意到传入的<code>resp</code>是一个指针，所以需要<strong>手动创建</strong>一个响应结构体并设置键值。</p><p>这样就算完成Ping接口了，可以运行服务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm 进阶 ｜ 青训营笔记</title>
      <link href="/2023/08/30/gorm%E8%BF%9B%E9%98%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/30/gorm%E8%BF%9B%E9%98%B6%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h2><p>关于简单的 gorm 总结 可以看上一篇文章  gorm 初体验 ｜ 青训营笔记</p><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p><code>Gorm</code>提供了软删除的能力，需要在结构体中定义一个<code>Deleted</code>字段，此时再调用<code>Delete</code>删除函数，则会生成<code>update</code>语句，并将<code>deleted</code>字段赋值为当前删除时间。</p><pre><code class="go">type Product struct &#123;    ID      uint    Code    string    Price   uint    Deleted gorm.DeletedAt&#125;</code></pre><p>再次执行删除操作：</p><pre><code class="go">godb.Delete(&amp;Product&#123;&#125;, 1)</code></pre><p>生成的<code>sql</code>为：</p><pre><code class="sql">UPDATE `product` SET `deleted`=&#39;2023-01-30 22:22:22.202&#39; WHERE `product`.`id` = 1 AND `product`.`deleted` IS NULL</code></pre><p>查询被软删除的操作，要使用<code>Unscoped</code>函数：</p><pre><code class="go">db.Unscoped().First(&amp;product, 2)</code></pre><p>有了<code>DeleteAt</code>字段后，删除操作已经变成了更新操作，那么想要物理删除怎么办？也是使用<code>Unscoped</code>函数：</p><pre><code class="go">db.Unscoped().Delete(&amp;Product&#123;&#125;, 1)</code></pre><h2 id="Gorm事务"><a href="#Gorm事务" class="headerlink" title="Gorm事务"></a>Gorm事务</h2><p><code>Gorm</code>提供了<code>Begin</code>、<code>Commit</code>、<code>Rollback</code>方法用于使用事务。</p><pre><code class="go">// 开启事务tx := db.Begin()if err := tx.Create(&amp;Product&#123;Code: &quot;D32&quot;, Price: 100&#125;).Error; err != nil &#123;    // 出现错误回滚    tx.Rollback()    return&#125;if err := tx.Create(&amp;Product&#123;Code: &quot;D33&quot;, Price: 100&#125;).Error; err != nil &#123;    // 出现错误回滚    tx.Rollback()    return&#125;// 提交事务tx.Commit()</code></pre><p>在开启事务后，调用增删改操作是应该使用开启事务返回的<code>tx</code>而不是<code>db</code>。</p><p><code>Gorm</code>还提供了<code>Transaction</code>函数用于自定提交事务，避免用户漏写<code>Commit</code>、<code>Rollback</code>。</p><pre><code class="go">if err = db.Transaction(func(tx *gorm.DB) error &#123;    if err := db.Create(&amp;Product&#123;Code: &quot;D55&quot;, Price: 100&#125;).Error; err != nil &#123;        return err    &#125;    if err := db.Create(&amp;Product&#123;Code: &quot;D56&quot;, Price: 100&#125;).Error; err != nil &#123;        return err    &#125;    return nil&#125;); err != nil &#123;    return&#125;</code></pre><p>这种写法，当出现错误时会自动进行<code>Rollback</code>，当正常执行时会自动<code>Commit</code>。</p><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>当我们想在执行增删改查操作前后做一些额外的操作时，可以使用<code>Gorm</code>提供的<code>Hook</code>能力。</p><p><code>Hook</code>是在创建、查询、更新、删除等操作之前、之后自动调用的函数，如果任何<code>Hook</code>返回错误，<code>Gorm</code>将停止后续的操作并回滚事务。</p><p><code>Hook</code>会开启默认事务，所以会带来了一些性能损失。</p><h3 id="性能提高"><a href="#性能提高" class="headerlink" title="性能提高"></a>性能提高</h3><p>对于写操作（创建、更新、删除），为了确保数据的完整性，<code>Gorm</code>会将他们封装在事务内运行，但是这样会降低性能，可以使用<code>SkipDefaultTransaction</code>关闭默认事务。</p><p>使用<code>PrepareStmt</code>缓存预编译语句可以提高后续调用的速度。</p><pre><code class="go">db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  SkipDefaultTransaction: true,  PrepareStmt: true,&#125;)</code></pre><h2 id="Gorm生态"><a href="#Gorm生态" class="headerlink" title="Gorm生态"></a>Gorm生态</h2><p>Gorm拥有非常丰富的扩展生态，下面列举一些常用的扩展。</p><ul><li>代码生成工具:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/gen">github.com&#x2F;go-gorm&#x2F;gen</a></li><li>分片分库方案:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/sharding">github.com&#x2F;go-gorm&#x2F;sha…</a></li><li>手动索引:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/hints">github.com&#x2F;go-gorm&#x2F;hin…</a></li><li>乐观锁:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/optimisticlock">github.com&#x2F;go-gorm&#x2F;opt…</a></li><li>读写分离:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/dbresolver">github.com&#x2F;go-gorm&#x2F;dbr…</a></li><li>OpenTelemetry扩展:<a href="https://link.juejin.cn/?target=https://github.com/go-gorm/opentelemetry">github.com&#x2F;go-gorm&#x2F;ope…</a></li></ul><h2 id="GORM-配置"><a href="#GORM-配置" class="headerlink" title="GORM 配置"></a>GORM 配置</h2><p>GORM 提供的配置可以在初始化时使用</p><pre><code class="go">type Config struct &#123;  SkipDefaultTransaction   bool  NamingStrategy           schema.Namer  Logger                   logger.Interface  NowFunc                  func() time.Time  DryRun                   bool  PrepareStmt              bool  DisableNestedTransaction bool  AllowGlobalUpdate        bool  DisableAutomaticPing     bool  DisableForeignKeyConstraintWhenMigrating bool&#125;</code></pre><h3 id="跳过默认事务"><a href="#跳过默认事务" class="headerlink" title="跳过默认事务"></a>跳过默认事务</h3><p>为了确保数据一致性，GORM 会在事务里执行写入操作（创建、更新、删除）。如果没有这方面的要求，您可以在初始化时禁用它。</p><pre><code class="go">db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  SkipDefaultTransaction: true,&#125;)</code></pre><h3 id="命名策略"><a href="#命名策略" class="headerlink" title="命名策略"></a>命名策略</h3><p>GORM 允许用户通过覆盖默认的<code>NamingStrategy</code>来更改命名约定，这需要实现接口 <code>Namer</code></p><pre><code class="go">type Namer interface &#123;    TableName(table string) string    SchemaName(table string) string    ColumnName(table, column string) string    JoinTableName(table string) string    RelationshipFKName(Relationship) string    CheckerName(table, column string) string    IndexName(table, column string) string&#125;</code></pre><p>默认 <code>NamingStrategy</code> 也提供了几个选项，如：</p><pre><code class="go">db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  NamingStrategy: schema.NamingStrategy&#123;    TablePrefix: &quot;t_&quot;,   // table name prefix, table for `User` would be `t_users`    SingularTable: true, // use singular table name, table for `User` would be `user` with this option enabled    NoLowerCase: true, // skip the snake_casing of names    NameReplacer: strings.NewReplacer(&quot;CID&quot;, &quot;Cid&quot;), // use name replacer to change struct/field name before convert it to db name  &#125;,&#125;)</code></pre><h3 id="NowFunc"><a href="#NowFunc" class="headerlink" title="NowFunc"></a>NowFunc</h3><p>更改创建时间使用的函数</p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  NowFunc: func() time.Time &#123;    return time.Now().Local()  &#125;,&#125;)</code></pre><h3 id="DryRun"><a href="#DryRun" class="headerlink" title="DryRun"></a>DryRun</h3><p>生成 <code>SQL</code> 但不执行，可以用于准备或测试生成的 SQL</p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  DryRun: false,&#125;)</code></pre><h3 id="PrepareStmt"><a href="#PrepareStmt" class="headerlink" title="PrepareStmt"></a>PrepareStmt</h3><p><code>PreparedStmt</code> 在执行任何 SQL 时都会创建一个 prepared statement 并将其缓存，以提高后续的效率</p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  PrepareStmt: false,&#125;)</code></pre><h3 id="禁用嵌套事务"><a href="#禁用嵌套事务" class="headerlink" title="禁用嵌套事务"></a>禁用嵌套事务</h3><p>在一个事务中使用 <code>Transaction</code> 方法，GORM 会使用 <code>SavePoint(savedPointName)</code>，<code>RollbackTo(savedPointName)</code> 为你提供嵌套事务支持，你可以通过 <code>DisableNestedTransaction</code> 选项关闭它</p><h3 id="DisableAutomaticPing"><a href="#DisableAutomaticPing" class="headerlink" title="DisableAutomaticPing"></a>DisableAutomaticPing</h3><p>在完成初始化后，GORM 会自动 ping 数据库以检查数据库的可用性，若要禁用该特性，可将其设置为 <code>true</code></p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  DisableAutomaticPing: true,&#125;)</code></pre><h3 id="DisableForeignKeyConstraintWhenMigrating"><a href="#DisableForeignKeyConstraintWhenMigrating" class="headerlink" title="DisableForeignKeyConstraintWhenMigrating"></a>DisableForeignKeyConstraintWhenMigrating</h3><p>在 <code>AutoMigrate</code> 或 <code>CreateTable</code> 时，GORM 会自动创建外键约束，若要禁用该特性，可将其设置为 <code>true</code></p><pre><code>db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  DisableForeignKeyConstraintWhenMigrating: true,&#125;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go字节三件套 ｜ 青训营笔记</title>
      <link href="/2023/08/28/go%E5%AD%97%E8%8A%82%E4%B8%89%E4%BB%B6%E5%A5%97%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/28/go%E5%AD%97%E8%8A%82%E4%B8%89%E4%BB%B6%E5%A5%97%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Gorm、Kitex、Hertz：三件套介绍与基本用法"><a href="#Gorm、Kitex、Hertz：三件套介绍与基本用法" class="headerlink" title="Gorm、Kitex、Hertz：三件套介绍与基本用法"></a>Gorm、Kitex、Hertz：三件套介绍与基本用法</h2><h3 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h3><p>Gorm是Golang中广受欢迎的ORM（对象关系映射）框架，已经发展数十年，具有强大的功能和出色的性能。</p><p>ORM框架用于将面向对象的概念与数据库中的表相对应，简化数据操作过程。在Golang中，自定义的结构体与数据库表一一对应，结构体的实例对应表中的一条记录。</p><p>基本用法</p><p>定义结构体：在Gorm中，定义结构体来映射数据库表。</p><pre><code class="go">type User struct &#123;  ID    uint   `gorm:&quot;primary_key&quot;`  Name  string `gorm:&quot;type:varchar(100)&quot;`  Email string `gorm:&quot;type:varchar(100);uniqueIndex&quot;`&#125;</code></pre><p>增加数据：使用Create方法来新增数据条目。</p><pre><code class="go">db.Create(&amp;User&#123;Name: &quot;John&quot;, Email: &quot;john@example.com&quot;&#125;)</code></pre><p>查询数据：使用Find进行数据查找，可以通过Where和Or条件构建查询条件。</p><pre><code class="go">var user Userdb.Where(&quot;name = ?&quot;, &quot;John&quot;).First(&amp;user)</code></pre><p>更新数据：使用Update进行数据更新，可以使用Model结合Update或Updates方法来更新列。</p><pre><code class="go">db.Model(&amp;user).Update(&quot;Name&quot;, &quot;John Updated&quot;)</code></pre><p>删除数据：使用Delete进行数据删除操作，根据是否包含gorm.deletedat字段执行物理或逻辑删除。</p><pre><code class="go">db.Delete(&amp;user)</code></pre><h3 id="Kitex"><a href="#Kitex" class="headerlink" title="Kitex"></a>Kitex</h3><p><a href="https://www.cloudwego.io/zh/docs/kitex/overview/">https://www.cloudwego.io/zh/docs/kitex/overview/</a></p><p>Kitex是字节开发的高性能Golang微服务RPC框架，具备出色的可扩展性和高性能。<br>服务端</p><pre><code class="go">func main() &#123;  srv := kitex.NewServer(new(YourServiceImpl),                           kitex.WithServiceAddr(&quot;:8888&quot;))  srv.Run()&#125;</code></pre><p>客户端</p><pre><code class="go">func main() &#123;  client := NewYourServiceClient(&quot;127.0.0.1:8888&quot;, kitex.WithTransportProtocol(protocol.TRPC))  // 调用RPC方法&#125;</code></pre><p>高性能：Kitex具有优异的性能表现，适用于高负载的微服务场景。<br>可扩展：支持多协议，并且有丰富的开源扩展库，可以满足各种需求。</p><h3 id="Hertz"><a href="#Hertz" class="headerlink" title="Hertz"></a>Hertz</h3><p><a href="https://www.cloudwego.io/zh/docs/hertz/overview/">https://www.cloudwego.io/zh/docs/hertz/overview/</a></p><p>Hertz是字节开发的HTTP框架，结合了其他开源框架的优点，同时满足字节跳动内部的需求，具有高可用性、高性能和高扩展性。</p><pre><code class="go">package mainimport (    &quot;context&quot;    &quot;github.com/cloudwego/hertz/pkg/app&quot;    &quot;github.com/cloudwego/hertz/pkg/app/server&quot;    &quot;github.com/cloudwego/hertz/pkg/common/utils&quot;    &quot;github.com/cloudwego/hertz/pkg/protocol/consts&quot;)func main() &#123;    h := server.Default()    h.GET(&quot;/ping&quot;, func(c context.Context, ctx *app.RequestContext) &#123;            ctx.JSON(consts.StatusOK, utils.H&#123;&quot;message&quot;: &quot;pong&quot;&#125;)    &#125;)    h.Spin()&#125;</code></pre><p>高可用性：Hertz框架被设计为具有高度的稳定性和可用性，适用于大规模的应用场景。<br>高性能：框架在性能方面表现出色，适合处理高并发请求。<br>高扩展性：Hertz框架允许根据业务需求进行定制和扩展，以满足复杂应用的要求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站安全漏洞 ｜ 青训营笔记</title>
      <link href="/2023/08/26/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/26/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是漏洞"><a href="#什么是漏洞" class="headerlink" title="什么是漏洞"></a>什么是漏洞</h2><p>漏洞是指在网站或网络应用中存在的安全弱点，它们可能由于各种原因而产生，包括编码错误、配置不当或第三方组件的安全性不足。了解一个网站的基本构成是理解漏洞的第一步。网站通常由以下几个关键组成部分构成，而攻击者通常会尝试从这些部分找出弱点进行攻击：</p><ul><li><strong>前端</strong>：使用的技术可能包括HTML、CSS、JavaScript、Vue.js、React.js等。</li><li><strong>网关</strong>：例如nginx或Apache，负责处理进出的网络流量。</li><li><strong>后端</strong>：可能是用Go、Java、Node.js、Python等语言编写的。</li><li><strong>前后端交互</strong>：通常通过HTTP或WebSocket进行。</li></ul><h2 id="常见的安全事件"><a href="#常见的安全事件" class="headerlink" title="常见的安全事件"></a>常见的安全事件</h2><p>由安全漏洞引发的攻击事件不仅可能导致数据泄露、服务瘫痪、成果失窃和系统劫持，还可能带来以下更为严重的后果：</p><ul><li><strong>法律责任</strong>：泄露用户数据可能导致法律诉讼和巨额罚款。</li><li><strong>品牌声誉受损</strong>：一次严重的安全事件可能永久性地影响公司的声誉。</li><li><strong>业务中断</strong>：服务中断可能导致用户流失和收入减少。</li><li><strong>内外部信任度下降</strong>：员工和合作伙伴也可能因为安全事件而对企业失去信任。</li></ul><h2 id="网站攻击者的意图"><a href="#网站攻击者的意图" class="headerlink" title="网站攻击者的意图"></a>网站攻击者的意图</h2><p>确切地知道攻击者的意图可以帮助企业更有效地防御威胁。除了政治、经济和竞争等原因外，还有以下可能的攻击动机：</p><ul><li><strong>社会工程攻击</strong>：通过人为操作或欺骗，使内部人员泄露敏感信息。</li><li><strong>黑帽SEO</strong>：通过各种手段来操纵搜索引擎排名。</li><li><strong>资源占用</strong>：攻击者可能只是为了消耗目标网站的资源。</li><li><strong>纯粹的破坏欲</strong>：有些攻击者可能只是出于破坏的乐趣。</li></ul><h3 id="红蓝对抗"><a href="#红蓝对抗" class="headerlink" title="红蓝对抗"></a>红蓝对抗</h3><p>红蓝对抗是一种模拟现实世界网络攻防场景的方法，通常用于评估和提升组织的安全防护能力。在这一模式中，红军（Red Team）模拟攻击者，寻找系统的弱点和漏洞；蓝军（Blue Team）则扮演防御方，负责检测和阻止这些攻击。除此之外，还有所谓的“紫军”（Purple Team），负责协调红蓝两方，以确保双方都从对抗中获得最大的学习价值。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>网站攻击通常可以分为两大类：针对客户端的攻击和针对服务端的攻击。</p><ul><li><strong>针对客户端的攻击</strong>：这类攻击直接影响网站的终端用户，例如通过XSS（跨站脚本）或CSRF（跨站请求伪造）等方式。</li><li><strong>针对服务端的攻击</strong>：这类攻击目标是网站后端的服务器或数据库，例如通过SQL注入或命令执行等方式。 每一种攻击都有其自己的防护机制和修补方案，因此对这些攻击手段有深入的了解是非常重要的。</li></ul><h3 id="服务端漏洞"><a href="#服务端漏洞" class="headerlink" title="服务端漏洞"></a>服务端漏洞</h3><p>服务端漏洞通常比客户端漏洞更为严重，因为它们直接影响到整个系统的安全性。其中，第三方组件漏洞是一个常见但经常被忽视的问题。例如，一些流行的开源库或框架可能存在已知的安全问题，如果开发人员没有及时更新这些组件，就可能导致整个系统的安全性受到威胁。</p><h3 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h3><p>SQL注入是一种常见但危险的攻击手段，它出现在应用程序未能正确地处理用户输入的场合。更准确地说，攻击者通过输入特定的SQL代码片段，使得原SQL查询逻辑被改变，从而达到非法获取数据或执行特定操作的目的。防范SQL注入的基础是编码规范，包括但不限于使用预编译SQL语句、参数化查询，以及进行严格的输入验证。</p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>命令执行漏洞通常发生在应用需要与操作系统进行交互时。与SQL注入类似，这一漏洞也常常是由于不正确的输入处理引起的。攻击者可能会尝试插入恶意命令或参数，以此来控制或破坏目标系统。防护措施包括使用安全的API进行命令调用、对用户输入进行严格的验证和过滤，以及使用最小权限原则来限制应用程序对系统资源的访问。</p><h3 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h3><p>越权漏洞是授权控制不当导致的一类安全问题，它们通常分为三类：</p><ul><li><strong>未授权</strong>：用户无需任何授权即可访问受限制的资源。</li><li><strong>水平越权</strong>：用户访问同一权限级别但不属于自己的资源。</li><li><strong>垂直越权</strong>：低权限用户访问高权限用户的资源。 越权问题的根本在于不恰当的权限控制和会话管理，因此相应的防护措施应从这两方面入手。</li></ul><h3 id="SSRF攻击"><a href="#SSRF攻击" class="headerlink" title="SSRF攻击"></a>SSRF攻击</h3><p>服务端请求伪造（SSRF）是一种利用目标服务器作为中间人来发起请求的攻击。这样做可能会暴露原本不可达的内部网络资源。SSRF通常利用的是应用程序或服务器配置中的不当输入验证或URL解析缺陷。防范措施包括限制从服务器发出的请求类型和目标，以及对所有外部输入进行严格的验证。</p><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>文件上传漏洞是一种常见的安全风险，尤其是在允许用户上传文件的应用中。如果没有适当的安全措施，攻击者可能会上传含有恶意代码的文件，这些文件一旦被执行，可能会导致严重的安全后果。因此，除了基本的文件类型检测和大小限制外，更高级的防护措施，如内容扫描和安全存储策略，也是非常必要的。</p><h3 id="客户端漏洞"><a href="#客户端漏洞" class="headerlink" title="客户端漏洞"></a>客户端漏洞</h3><p>客户端漏洞主要影响网站的最终用户，而不是服务器或数据库。这些漏洞通常涉及到如何处理从客户端（通常是Web浏览器）发来的数据和请求。例如，开放重定向是一种常见的客户端漏洞，攻击者通过这种漏洞可以将用户重定向到恶意网站。修复这类问题通常需要在客户端和服务器端都进行适当的输入验证。</p><h3 id="跨站脚本（XSS）攻击"><a href="#跨站脚本（XSS）攻击" class="headerlink" title="跨站脚本（XSS）攻击"></a>跨站脚本（XSS）攻击</h3><p>跨站脚本（XSS）是一种在目标网站上执行恶意脚本的攻击方式。它利用的是网站没有对用户提交的数据进行适当的过滤和转义。根据攻击的具体形式，XSS攻击可以进一步分为存储型、反射型和DOM型三类。每种类型的XSS攻击都有其独特的防御方法，如输入过滤、输出编码和内容安全策略（CSP）。</p><h3 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h3><p>跨站请求伪造（CSRF）是一种攻击手法，攻击者通过某种方式诱导用户点击一个链接或按钮，从而在用户不知情的情况下，以该用户的身份执行非预期的操作。防御CSRF攻击的常见方法包括使用CSRF令牌、设置SameSite属性等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们列举了网站安全漏洞的多个方面，从基础概念到各种类型的安全漏洞，以及如何防范这些漏洞。重要的是，无论是服务端还是客户端，安全漏洞都可能存在，并且都需要得到妥善的处理。</p><p>网站安全是一个涉及多个层面的复杂问题，需要开发者、运维人员、以及安全团队共同努力来维护。只有全方位、多层次的安全防护措施，才能有效地减少安全风险，保护网站和用户数据的安全。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go架构 ｜ 青训营笔记</title>
      <link href="/2023/08/24/go%E6%9E%B6%E6%9E%84%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/24/go%E6%9E%B6%E6%9E%84%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h2><p>主要针对互联网服server系统（类似网站）来定义架构：架构是系统的骨架，支撑和链接各个部分，包括组件、连接件、约束规范，以及指导这些内容设计与演化的原理。</p><ul><li><p>组件：类似应用服务，独立模块、数据库、nginx等等、</p></li><li><p>连接件：分布式调用、进程间调用、调用使用http协议还是tcp协议、组件之间的交互关系、</p></li><li><p>约束规范： 定规则做限制：例如设计原则、编码规范等等。</p></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是架构的构建块，包括独立模块、数据库、Nginx等。</p><p>例如，Go语言中可以定义一个组件，如一个HTTP服务器：</p><pre><code class="go">package mainimport (    &quot;net/http&quot;)func main() &#123;    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;        w.Write([]byte(&quot;Hello, World!&quot;))    &#125;)    http.ListenAndServe(&quot;:8080&quot;, nil)&#125;</code></pre><h3 id="连接件"><a href="#连接件" class="headerlink" title="连接件"></a>连接件</h3><p>连接件处理组件之间的交互关系，例如分布式调用、进程间调用、使用的协议等。</p><h3 id="约束规范"><a href="#约束规范" class="headerlink" title="约束规范"></a>约束规范</h3><p>约束规范定义了架构中的规则和限制，例如设计原则和编码规范。</p><h2 id="几种典型架构"><a href="#几种典型架构" class="headerlink" title="几种典型架构"></a>几种典型架构</h2><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><p>单机架构就是把所有功能都实现在一个进程中，并部署在一台机器上。</p><p>单机架构的<strong>优点</strong>是非常简单，<strong>缺点</strong>是会遇到并发处理的难题，而且运维需要停服。</p><p>当时计算机软硬件性能比较基础，这个问题引起人们对网络套接字优化和服务端调度的关注，这个词语也随着时代的发展逐渐变化，如<code>C10M</code>代表的是处理1000万个并发连接。现在的计算机已经有足够的性能和优秀的软件来支撑单机数百万连接了，然而并发问题仍然是后端架构设计中不能略过的关键问题。</p><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>单体架构是对单机架构的改进。既然单机处理能力有限，就可以采用分布式部署的模式设置多台单机，再设置一个分流环节，将请求转发给各个单体服务器来处理。</p><p>单体架构的优点是可以实现水平扩容，处理能力不够时只需要简单添加新的单机即可；运维不需要停服，可以逐个对单机维护不影响其他单机的运行。单体架构下，每台机器的功能是一致的，因此它没有解决这两个缺点：</p><ol><li>职责太多，开发效率低：每台机器都要实现系统的完整功能，不能专注于某个功能的开发。</li><li><strong>爆炸半径大</strong>： 爆炸半径是指爆炸可能造成损害的区域范围。在生产环境中指的就是部署的服务故障时可能影响的软件功能范围。单体架构下每一个单机下线，都会造成所有功能的处理承载量下降，因此爆炸半径覆盖了软件多数功能。</li></ol><h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>为了解决单体架构的问题，垂直应用架构提供了一种思路，将系统按照服务拆分任务，分配给不同的服务器，从而实现职责的简单划分，一定程度上提高开发和运维的效率。不过在实践中一个服务往往是大量功能点的集合，仍然存在功能琐碎的问题</p><h2 id="更加高级的架构"><a href="#更加高级的架构" class="headerlink" title="更加高级的架构"></a>更加高级的架构</h2><h3 id="SOA、微服务架构"><a href="#SOA、微服务架构" class="headerlink" title="SOA、微服务架构"></a>SOA、微服务架构</h3><p>SOA（Service-Oriented Architecture）架构具有两个特性：</p><ol><li>将应用的不同功能单元抽象为服务，从而细分职责</li><li>定义服务之间的通信标准，确保服务之间的数据流通</li></ol><p>微服务架构则是SOA架构去中心化的演进方向，旨在减少服务之间的沟通消耗，避免SOA服务内部集中沟通导致的过度中心化问题，他实现了水平切分，减少了跨级别调用链，让每个服务直接负责的上下级减少。</p><p>这类架构在解决之前的弊端时，也会引入新的问题：</p><ul><li>数据一致性问题：不同服务如何确保数据同步</li><li>高可用问题：服务之间如何进行可靠合作</li><li>治理问题：一个服务出现问题时，要如何容灾</li><li>解耦和过微问题：过度细分会导致运维成本提高，要如何权衡？</li></ul><h3 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h3><p>事件驱动架构（EDA）是一种异步架构，其中生产者生成事件，并由一个或多个消费者消费。这允许解耦生产者和消费者，并实现高度可扩展和灵活的系统。</p><p>Apache Kafka<br>Apache Kafka是一种流行的事件流平台。您可以使用Go编写Kafka的生产者和消费者。</p><p>如下是示例代码 </p><pre><code class="go">package mainimport (    &quot;github.com/confluentinc/confluent-kafka-go/kafka&quot;)func main() &#123;    producer, err := kafka.NewProducer(&amp;kafka.ConfigMap&#123;&quot;bootstrap.servers&quot;: &quot;localhost&quot;&#125;)    if err != nil &#123;        panic(err)    &#125;    // 生产消息    producer.Produce(&amp;kafka.Message&#123;        TopicPartition: kafka.TopicPartition&#123;Topic: &amp;topic, Partition: kafka.PartitionAny&#125;,        Value:          []byte(&quot;Message Value&quot;),    &#125;, nil)    // 消费消息    consumer, err := kafka.NewConsumer(&amp;kafka.ConfigMap&#123;        &quot;bootstrap.servers&quot;: &quot;localhost&quot;,        &quot;group.id&quot;:          &quot;myGroup&quot;,        &quot;auto.offset.reset&quot;: &quot;earliest&quot;,    &#125;)    consumer.SubscribeTopics([]string&#123;&quot;myTopic&quot;&#125;, nil)    msg, err := consumer.ReadMessage(-1)    if err == nil &#123;        fmt.Printf(&quot;Message on %s: %s\n&quot;, msg.TopicPartition, string(msg.Value))    &#125;&#125;</code></pre><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>云计算是指通过软件自动化管理，提供计算资源的服务网络，是现在互联网大规模数据分析和存储的基石。</p><p>云计算的基础是虚拟化技术和编排方式，关系到资源的分配和调度。</p><p>云计算提供一系列特有的架构：</p><ul><li>基础设施即服务IaaS（Infrastructure as a Service）：服务商提供互联网基础设施，比如用户只需要获得服务器、云硬盘、宽带网络，而不用关心物理的机房、数据中心、网络怎么建设。但是，用户需要自己进行服务器系统安装、环境部署和软件配置。</li><li>平台即服务PaaS（Platform as a Service）：服务商提供底层软件设施，比如为用户准备安装了指定操作系统、数据库软件、环境套件的主机。用户需要自己控制上层应用的部署和托管。</li><li>软件即服务Saas（Software as a Service）：服务商及提供基于软件的解决方案来满足客户的需求，比如用户想要一套OA办公系统，CMS内容管理系统，HRM人事管理系统等，而不用自行搭建和维护这样的服务，能够简化用户的工作。</li><li>函数即服务FaaS（Function as a service）：服务商提供一个平台，允许客户开发、运行和管理应用程序功能，而不用关心如何启动和部署这样的程序。这个模式是“无服务器”体系架构的方式，具有灵活性，适合构建微服务应用程序。</li></ul><h3 id="云原生架构"><a href="#云原生架构" class="headerlink" title="云原生架构"></a>云原生架构</h3><p>云原生技术为公司在公有云、私有云、混合云等新型动态环境中，构建和运行可弹性拓展的应用提供了可能。</p><p>云原生为公司提供了以下关键能力：</p><h3 id="弹性资源调度"><a href="#弹性资源调度" class="headerlink" title="弹性资源调度"></a>弹性资源调度</h3><ul><li>服务资源调度：分配微服务、大服务使用的资源。</li><li>计算资源调度：分配在线计算、离线计算使用的资源</li><li>消息队列：和计算资源调度类似，提供海量的数据吞吐和大数据分析能力。</li></ul><h3 id="弹性存储资源"><a href="#弹性存储资源" class="headerlink" title="弹性存储资源"></a>弹性存储资源</h3><p>云原生让用户可以将存储资源看作服务，寻找对应的服务来满足自己的存储需求。</p><ul><li>经典存储：对象存储、大数据记录存储。</li><li>关系型数据库：业务记录存储。</li><li>元数据：提供服务发现能力</li><li>NoSQL：key-value存储，实现缓存和分布式事务。</li></ul><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>DevOps贯穿整个软件开发周期，使用一系列自动化流程，提高软件开发、交付的效率。DevOps提供了敏捷开发、持续集成&#x2F;交付（CI&#x2F;CD）的能力。</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构实现业务功能单元的解耦，同时提供一套统一的通信标准确保服务之间的数据流通。</p><p>微服务常见的通信标准是HTTP（RESTful API）和RPC（Thrift, gRPC），需要结合性能、服务治理、协议可解释性来选择。实际场景下，常常使用微服务框架提供的通信能力，而不用自己从头实现一套。</p><h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>服务网格实现业务与治理的结构以及异构系统治理的统一化，从而提供复杂的治理能力。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务注册与发现 Eureka或Consul等服务可以用于服务发现。</p><p>服务注册与发现使服务可以动态地找到其他服务的位置。</p><pre><code class="go">// 使用Consul进行服务注册consulConfig := consulapi.DefaultConfig()consulConfig.Address = &quot;localhost:8500&quot;client, err := consulapi.NewClient(consulConfig)if err != nil &#123;    log.Fatal(err)&#125;// 创建新的服务registration := new(consulapi.AgentServiceRegistration)registration.ID = &quot;my-service-id&quot;registration.Name = &quot;my-service&quot;registration.Port = 8080registration.Tags = []string&#123;&quot;my-service&quot;&#125;// 注册服务agent := client.Agent()if err := agent.ServiceRegister(registration); err != nil &#123;    log.Fatal(err)&#125;// 服务发现逻辑...</code></pre><h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>分布式锁</p><p>在分布式环境中，协调多个节点的访问资源可能会变得复杂。分布式锁是一种解决方案，可以在多个节点之间同步访问。</p><p>可以使用Go语言和Redis创建分布式锁：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;github.com/go-redis/redis/v8&quot;    &quot;golang.org/x/net/context&quot;)func main() &#123;    rdb := redis.NewClient(&amp;redis.Options&#123;        Addr: &quot;localhost:6379&quot;,    &#125;)    ctx := context.Background()    lockKey := &quot;lock_key&quot;    // 尝试获取锁    locked, err := rdb.SetNX(ctx, lockKey, &quot;lock_value&quot;, 0).Result()    if err != nil || !locked &#123;        fmt.Println(&quot;获取锁失败&quot;)        return    &#125;    // 执行业务逻辑...    // 释放锁    rdb.Del(ctx, lockKey)    fmt.Println(&quot;业务逻辑执行完毕，锁已释放&quot;)&#125;</code></pre><h2 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h2><h3 id="离在线资源并池"><a href="#离在线资源并池" class="headerlink" title="离在线资源并池"></a>离在线资源并池</h3><p>在线业务以<strong>IO密集型</strong>为主，要求计算的<strong>实时性</strong>，但是具有<strong>潮汐性</strong>，不同时间段的压力不同。离线业务以<strong>计算密集型</strong>为主，对计算实时性不高。</p><p>把在线和离线资源放入同一个资源池进行调度，利用在线业务的潮汐性自动扩缩容，能够有效降低物理资源成本，提供更多的弹性资源，增加收益。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>简单的http负载均衡 轮询算法</p><pre><code class="go">package mainimport (    &quot;net/http&quot;    &quot;net/http/httputil&quot;    &quot;net/url&quot;)var servers = []string&#123;    &quot;http://localhost:8081&quot;,    &quot;http://localhost:8082&quot;,&#125;var currentServer = 0func nextServer() string &#123;    server := servers[currentServer]    currentServer = (currentServer + 1) % len(servers)    return server&#125;func main() &#123;    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;        server := nextServer()        target, _ := url.Parse(server)        proxy := httputil.NewSingleHostReverseProxy(target)        proxy.ServeHTTP(w, r)    &#125;)    http.ListenAndServe(&quot;:8080&quot;, nil)&#125;</code></pre><h3 id="亲和性部署"><a href="#亲和性部署" class="headerlink" title="亲和性部署"></a>亲和性部署</h3><p>如果两个微服务之间通信密切，则这两个服务的亲和性较高。将满足亲和性条件的容器调度到一台宿主机，让微服务中间件与服务网格通过共享内存通信，能够有效降低通信成本，提高服务可用性。</p><h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><p>基于微服务中间件和服务网格的流量治理，赋予微服务熔断、重试的能力，提供复杂环境下的流量调度，可以提高微服务调用容错性，增强容灾能力，还能进一步提高开发效率。</p><h3 id="CPU水位负载均衡"><a href="#CPU水位负载均衡" class="headerlink" title="CPU水位负载均衡"></a>CPU水位负载均衡</h3><p>结合IaaS提供的资源探针和服务网格的负载均衡能力，能够为自动扩缩容提供反馈，打平异构环境下算力的差异。</p><h3 id="容器化与服务编排"><a href="#容器化与服务编排" class="headerlink" title="容器化与服务编排"></a>容器化与服务编排</h3><p>Docker</p><p>可以使用Docker将Go应用程序打包到容器中，并确保它在任何支持Docker的平台上以相同的方式运行。</p><p>Kubernetes</p><p>Kubernetes是一种强大的容器编排工具，用于自动部署、扩展和管理容器化应用程序。Go语言是Kubernetes的主要实现语言。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现代软件架构的复杂性和灵活性要求了解许多概念和技术。从单机到分布式，从单体到微服务，架构演化为满足不断增长的需求。</p><p>通过使用强大和灵活的编程语言，如Go，您可以构建符合这些需求的解决方案。从分布式锁到服务发现，从负载均衡到微服务通信，Go为构建现代、可扩展和高性能的系统提供了强大的工具和库。</p><p>不断学习和实践这些概念和技术将使您更好地设计和构建复杂的系统，满足业务目标，并应对未来的挑战。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm 初体验 ｜ 青训营笔记</title>
      <link href="/2023/08/23/gorm%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/23/gorm%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h2><p><img src="https://gorm.io/gorm.svg"></p><p>gorm是Golang语言中一款性能极好的ORM库，对开发人员相对是比较友好的。接下来主要学习下gorm库的一些基本使用。</p><p>功能概览</p><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 Preload、Joins 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context、预编译模式、DryRun 模式</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询<br>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装</p><pre><code class="bash">go get -u gorm.io/gormgo get -u gorm.io/driver/sqlite</code></pre><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>因为orm可以自动创建数据库，创建表，所以我们要用一个约定的形式来描述一个schema，便于他创建表，也便于代码中调用</p><p>例如</p><pre><code class="go">type User struct &#123;  Name         string  Email        string  Age          uint8&#125;</code></pre><p>这样的一个结构体就可以描述user这个表</p><h4 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h4><pre><code class="go">// gorm.Model 的定义type Model struct &#123;  ID        uint           `gorm:&quot;primaryKey&quot;`  CreatedAt time.Time  UpdatedAt time.Time  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`&#125;</code></pre><p>这个约定了一些gorm的标准配置，相当于implement了这个结构体</p><p>例如</p><pre><code class="go">type User struct &#123;  gorm.Model  Name         string  Email        string  Age          uint8&#125;</code></pre><p>这样这个gorm.Model相当于在user表里添加了一些基础的字段</p><p>这个user最终会变成 相当于</p><pre><code class="go">type User struct &#123;  ID        uint           `gorm:&quot;primaryKey&quot;`  CreatedAt time.Time  UpdatedAt time.Time  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`  Name         string  Email        string  Age          uint8&#125;</code></pre><h4 id="嵌入结构体"><a href="#嵌入结构体" class="headerlink" title="嵌入结构体"></a>嵌入结构体</h4><p>如上的gorm.Model就是一种嵌入结构体</p><p>官网的解释是：对于匿名字段，GORM 会将其字段包含在父结构体中</p><p>其他嵌入方法为：</p><p>对于正常的结构体字段，你也可以通过标签 embedded 将其嵌入，例如：</p><pre><code class="go">type Author struct &#123;    Name  string    Email string&#125;type Blog struct &#123;  ID      int  Author  Author `gorm:&quot;embedded&quot;`  Upvotes int32&#125;</code></pre><pre><code class="go">// 它等效于type Blog struct &#123;  ID    int64  Name  string  Email string  Upvotes  int32&#125;</code></pre><blockquote><p>可以使用标签 embeddedPrefix 来为 db 中的字段名添加前缀<br>Author  Author &#96;gorm:”embedded;embeddedPrefix:author_”</p></blockquote><h4 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h4><p>声明 model 时，tag 是可选的，gorm 支持以下这些 tag： tag 名大小写不敏感，但我们写的时候最好用驼峰命名法。</p><p>写法为 在字段后面添加飘号和gorm:</p><p>例如</p><pre>ID        uint           `gorm:"primaryKey"`</pre><table><thead><tr><th align="left">标签名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 database 的列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td align="left">serializer</td><td align="left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td align="left">size</td><td align="left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td align="left">primaryKey</td><td align="left">将列定义为主键</td></tr><tr><td align="left">unique</td><td align="left">将列定义为唯一键</td></tr><tr><td align="left">default</td><td align="left">定义列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">scale</td><td align="left">指定列大小</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">autoIncrementIncrement</td><td align="left">自动步长，控制连续记录之间的间隔</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌入字段的列名前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">创建&#x2F;更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td align="left">-</td><td align="left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td align="left">comment</td><td align="left">迁移时为字段添加注释</td></tr></tbody></table><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>官方提供的代码</p><pre><code class="go">import (  &quot;gorm.io/driver/mysql&quot;  &quot;gorm.io/gorm&quot;)func main() &#123;  // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情  dsn := &quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)&#125;</code></pre><p>这里我提供一种封装方案，因为一般数据库配置写在配置文件里，防止泄露与主代码分离‘</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;gorm.io/driver/mysql&quot;    &quot;gorm.io/gorm&quot;    &quot;gorm.io/gorm/schema&quot;)type Config struct &#123;    // 数据库配置    DBList DBListConf&#125;type DBListConf struct &#123;    Mysql MysqlConf&#125;type MysqlConf struct &#123;    Address     string    Username    string    Password    string    DBName      string    TablePrefix string&#125;type ServiceContext struct &#123;    Config Config    DBList *DBList&#125;type DBList struct &#123;    Mysql *gorm.DB&#125;func NewServiceContext(c Config) *ServiceContext &#123;    return &amp;ServiceContext&#123;        Config: c,        DBList: initDB(c),    &#125;&#125;func initDB(c Config) *DBList &#123;    dbList := new(DBList)    dbList.Mysql = initMysql(c)    return dbList&#125;func initMysql(c Config) *gorm.DB &#123;    dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;,        c.DBList.Mysql.Username,        c.DBList.Mysql.Password,        c.DBList.Mysql.Address,        c.DBList.Mysql.DBName,    )    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;        NamingStrategy: schema.NamingStrategy&#123;            TablePrefix:   c.DBList.Mysql.TablePrefix, // 表名前缀            SingularTable: true,                       // 使用单数表名        &#125;,        DisableForeignKeyConstraintWhenMigrating: true,    &#125;)    if err != nil &#123;        panic(err)    &#125;    // 自动建表    err = db.AutoMigrate(&amp;model.Video&#123;&#125;, &amp;model.Favorite&#123;&#125;, &amp;model.Comment&#123;&#125;)    if err != nil &#123;        panic(err)    &#125;    return db&#125;func main() &#123;    // 创建配置实例    config := Config&#123;        DBList: DBListConf&#123;            Mysql: MysqlConf&#123;                Address:     &quot;Address&quot;,                Username:    &quot;root&quot;,                Password:    &quot;1111111111111&quot;,                DBName:      &quot;dbname&quot;,                TablePrefix: &quot;Prefix&quot;,            &#125;,        &#125;,    &#125;    // 创建服务上下文    serviceContext := NewServiceContext(config)        // 在这里你可以使用 serviceContext 进行操作    // ...    fmt.Println(&quot;Database initialization and configuration completed.&quot;)&#125;</code></pre><p>这里出现了自动建表的操作AutoMigrate 你需要把你想要创建的模型传进来自动建表</p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="1-C"><a href="#1-C" class="headerlink" title="1. C"></a>1. C</h3><p>接下来开始 crud,</p><p>假如你有一个user表，可以使用create创建多个数据</p><pre><code class="go">users := []*User&#123;    User&#123;Name: &quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;,    User&#123;Name: &quot;Jackson&quot;, Age: 19, Birthday: time.Now()&#125;,&#125;result := db.Create(users) // pass a slice to insert multiple rowresult.Error        // returns errorresult.RowsAffected // returns inserted records count</code></pre><p>Error相信你会接</p><pre><code class="go">if result.Error != nil &#123;    return exit&#125;</code></pre><p>或者可以直接在create里</p><pre><code class="go">err := db.create().Errorif err != nil &#123;    return exit&#125;</code></pre><h3 id="2-R"><a href="#2-R" class="headerlink" title="2.R"></a>2.R</h3><p>根据主键检索</p><pre><code class="go">db.First(&amp;user, 10)// SELECT * FROM users WHERE id = 10;db.First(&amp;user, &quot;10&quot;)// SELECT * FROM users WHERE id = 10;db.Find(&amp;users, []int&#123;1,2,3&#125;)// SELECT * FROM users WHERE id IN (1,2,3);</code></pre><p>这里的first为检索第一个 limit为1</p><p>检索全部对象</p><pre><code class="go">// Get all recordsresult := db.Find(&amp;users)// SELECT * FROM users;result.RowsAffected // returns found records count, equals `len(users)`result.Error        // returns error</code></pre><p>条件检索</p><p>这样相当于拼sql语句</p><pre><code class="go">// Get first matched recorddb.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user)// SELECT * FROM users WHERE name = &#39;jinzhu&#39; ORDER BY id LIMIT 1;// Get all matched recordsdb.Where(&quot;name &lt;&gt; ?&quot;, &quot;jinzhu&quot;).Find(&amp;users)// SELECT * FROM users WHERE name &lt;&gt; &#39;jinzhu&#39;;// INdb.Where(&quot;name IN ?&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;).Find(&amp;users)// SELECT * FROM users WHERE name IN (&#39;jinzhu&#39;,&#39;jinzhu 2&#39;);// LIKEdb.Where(&quot;name LIKE ?&quot;, &quot;%jin%&quot;).Find(&amp;users)// SELECT * FROM users WHERE name LIKE &#39;%jin%&#39;;// ANDdb.Where(&quot;name = ? AND age &gt;= ?&quot;, &quot;jinzhu&quot;, &quot;22&quot;).Find(&amp;users)// SELECT * FROM users WHERE name = &#39;jinzhu&#39; AND age &gt;= 22;// Timedb.Where(&quot;updated_at &gt; ?&quot;, lastWeek).Find(&amp;users)// SELECT * FROM users WHERE updated_at &gt; &#39;2000-01-01 00:00:00&#39;;// BETWEENdb.Where(&quot;created_at BETWEEN ? AND ?&quot;, lastWeek, today).Find(&amp;users)// SELECT * FROM users WHERE created_at BETWEEN &#39;2000-01-01 00:00:00&#39; AND &#39;2000-01-08 00:00:00&#39;;</code></pre><p>高级查询 <a href="https://gorm.io/zh_CN/docs/advanced_query.html">https://gorm.io/zh_CN/docs/advanced_query.html</a></p><h3 id="3-U"><a href="#3-U" class="headerlink" title="3.U"></a>3.U</h3><p>更新 所有字段</p><pre><code class="go">db.Save(&amp;User&#123;Name: &quot;jinzhu&quot;, Age: 100&#125;)// INSERT INTO `users` (`name`,`age`,`birthday`,`update_at`) VALUES (&quot;jinzhu&quot;,100,&quot;0000-00-00 00:00:00&quot;,&quot;0000-00-00 00:00:00&quot;)db.Save(&amp;User&#123;ID: 1, Name: &quot;jinzhu&quot;, Age: 100&#125;)// UPDATE `users` SET `name`=&quot;jinzhu&quot;,`age`=100,`birthday`=&quot;0000-00-00 00:00:00&quot;,`update_at`=&quot;0000-00-00 00:00:00&quot; WHERE `id` = 1</code></pre><p>更多更新方法 <a href="https://gorm.io/zh_CN/docs/update.html">https://gorm.io/zh_CN/docs/update.html</a></p><h3 id="4-D"><a href="#4-D" class="headerlink" title="4.D"></a>4.D</h3><p>删除一条记录 </p><pre><code class="go">// Email 的 ID 是 `10`db.Delete(&amp;email)// DELETE from emails where id = 10;// 带额外条件的删除db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Delete(&amp;email)// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</code></pre><p>更多删除方法 <a href="https://gorm.io/zh_CN/docs/delete.html">https://gorm.io/zh_CN/docs/delete.html</a></p><p>其中的软删除感觉很有用</p><blockquote><p>当调用Delete时，GORM并不会从数据库中删除该记录，而是将该记录的DeleteAt设置为当前时间，而后的一般查询方法将无法查找到此条记录。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>gorm是个很好用的go的orm框架，对很多数据库都兼容</p><p>性能也很好，操作起来也很简单。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言三个小项目 ｜ 青训营笔记</title>
      <link href="/2023/07/25/go%E8%AF%AD%E8%A8%80%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/25/go%E8%AF%AD%E8%A8%80%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><ol><li>猜数字<br>这个项目非常简单，它涉及到随机数的生成和用户输入操作。<br>我们使用了bufio库来处理输入数据。</li></ol><pre><code class="go">reader := bufio.NewReader(os.Stdin)input, _ := reader.ReadString(&#39;\n&#39;)</code></pre><h2 id="简单字典"><a href="#简单字典" class="headerlink" title="简单字典"></a>简单字典</h2><ol start="2"><li>标准库strconv<br>它主要用于字符和其他类型之间的转换。</li></ol><pre><code class="go">strconv.Atoi(s string) int </code></pre><ol start="3"><li>标准库strings</li></ol><pre><code class="go">strings.TrimSuffix(s string ,  suffix string) string</code></pre><p>删除末尾字符，如果没有就正常返回</p><ol start="4"><li>网络库</li></ol><pre><code class="go">client := &amp;http.Client&#123;&#125;</code></pre><p>初始化请求客户端</p><pre><code class="go">req,  err := http.NewRequest(&quot;POST&quot;, &quot;https://api.interpreter.caiyunai.com/v1/dict&quot;,  data)</code></pre><p>构造头</p><pre><code class="go">req.Header.Set(&quot;authority&quot;,  &quot;api.interpreter.caiyunai.com&quot;)</code></pre><p>请求</p><pre><code class="go">bodyText,  err := io.ReadAll(resp.Body)err = json.Unmarshal(bodyText,  &amp;dictResponse)</code></pre><ol start="5"><li>os库</li></ol><pre><code class="go">word := os.Args[1]</code></pre><p>获取环境参数</p><h2 id="socks5代理"><a href="#socks5代理" class="headerlink" title="socks5代理"></a>socks5代理</h2><pre><code class="go">package mainimport (    &quot;context&quot;    &quot;encoding/binary&quot;    &quot;fmt&quot;    &quot;io&quot;    &quot;net&quot;)const (    socks5Ver  = 0x05    atypeIPV4  = 0x01    atypeHOST  = 0x03    cmdConnect = 0x01)func main() &#123;    // 假设在这里建立一个 net.Listener 监听 Socks5 代理请求    for &#123;        client, err := acceptConnection()        if err != nil &#123;            continue        &#125;        // 开启一个 goroutine 处理客户端请求        go handleSocks5Client(client)    &#125;&#125;func acceptConnection() (net.Conn, error) &#123;    // 实现接收连接请求的逻辑&#125;func handleSocks5Client(conn net.Conn) &#123;    defer conn.Close()    // 鉴权阶段    if err := auth(conn); err != nil &#123;        fmt.Println(&quot;Authentication error:&quot;, err)        return    &#125;    // 通讯阶段    addr, err := connect(conn)    if err != nil &#123;        fmt.Println(&quot;Connection error:&quot;, err)        return    &#125;    // 给客户端回包，表示连接成功    _, _ = conn.Write([]byte&#123;socks5Ver, 0x00, 0x00, atypeIPV4, 0, 0, 0, 0, 0, 0&#125;)    // 开始进行数据转发    dest, err := net.Dial(&quot;tcp&quot;, addr)    if err != nil &#123;        fmt.Println(&quot;Failed to connect to destination:&quot;, err)        return    &#125;    defer dest.Close()    ctx, cancel := context.WithCancel(context.Background())    defer cancel()    // 从客户端到目标地址的数据拷贝    go func() &#123;        _, _ = io.Copy(dest, conn)        cancel()    &#125;()    // 从目标地址到客户端的数据拷贝    go func() &#123;        _, _ = io.Copy(conn, dest)        cancel()    &#125;()    &lt;-ctx.Done()&#125;func auth(conn net.Conn) error &#123;    buf := make([]byte, 2)    _, err := io.ReadFull(conn, buf)    if err != nil &#123;        return err    &#125;    ver, nmethods := buf[0], buf[1]    methods := make([]byte, nmethods)    _, err = io.ReadFull(conn, methods)    if err != nil &#123;        return err    &#125;    // 在这里根据收到的 methods 进行认证处理    // 假设这里选择不需要认证，回包告知客户端不需要认证    _, err = conn.Write([]byte&#123;socks5Ver, 0x00&#125;)    if err != nil &#123;        return err    &#125;    return nil&#125;func connect(conn net.Conn) (string, error) &#123;    buf := make([]byte, 4)    _, err := io.ReadFull(conn, buf)    if err != nil &#123;        return &quot;&quot;, err    &#125;    ver, cmd, _, atyp := buf[0], buf[1], buf[2], buf[3]    if ver != socks5Ver || cmd != cmdConnect &#123;        return &quot;&quot;, fmt.Errorf(&quot;Unsupported SOCKS5 command&quot;)    &#125;    var addr string    switch atyp &#123;    case atypeIPV4:        buf := make([]byte, 4)        _, err := io.ReadFull(conn, buf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        addr = fmt.Sprintf(&quot;%d.%d.%d.%d&quot;, buf[0], buf[1], buf[2], buf[3])    case atypeHOST:        hostSizeBuf := make([]byte, 1)        _, err := io.ReadFull(conn, hostSizeBuf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        hostSize := int(hostSizeBuf[0])        hostBuf := make([]byte, hostSize)        _, err = io.ReadFull(conn, hostBuf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        addr = string(hostBuf)    &#125;    portBuf := make([]byte, 2)    _, err = io.ReadFull(conn, portBuf)    if err != nil &#123;        return &quot;&quot;, err    &#125;    port := binary.BigEndian.Uint16(portBuf)    return fmt.Sprintf(&quot;%v:%v&quot;, addr, port), nil&#125;</code></pre><p>使用 SOCKS5 代理的实现，涵盖了以下主要步骤：</p><p>鉴权阶段：</p><p>解析客户端发送的版本号、支持的认证方法数量和认证方法列表。<br>针对支持的认证方法进行验证，返回认证成功的回包。<br>通讯阶段：</p><p>解析客户端发送的连接请求，包括版本号、命令类型、目标地址类型、目标地址、目标端口等信息。<br>根据目标地址类型和地址解析方式，获取目标地址和端口号。<br>向目标地址发起连接请求，并返回连接成功的回包。<br>进程管理：</p><p>使用 goroutine 后台开启两个服务器交互进程。<br>通过 context 库进行进程管理，确保进程在必要时可以被关闭。<br>将客户端和目标之间的数据互相拷贝，使得数据能够在两者之间传递。</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>在这节课学习的内容中，我收获了很多关于Go语言编程的知识和技能。以下是我的感想：</p><p>Go语言的简洁和高效：通过学习这些基础标准库和相关功能，我深刻感受到Go语言的简洁和高效。标准库提供了丰富的功能，让编程变得更加简单和高效。</p><p>数据类型转换和字符串处理：学习了strconv和strings包，对于数据类型转换和字符串处理有了更深入的了解。这些工具使得在处理用户输入和数据转换时更加方便。</p><p>网络编程和HTTP库：了解了Go语言中的网络编程和net&#x2F;http包，我现在能够编写简单的HTTP服务器和客户端，这对于开发网络应用和服务端程序非常有用。</p><p>文件操作和系统交互：通过os包的学习，我学会了如何在Go语言中进行文件操作和与操作系统进行交互，这对于处理文件和系统配置十分重要。</p><p>代理和鉴权：学习了socks5代理和鉴权机制，我对网络代理和安全认证有了更深刻的理解，这对于开发安全性较高的应用非常重要。</p><p>上下文处理：context包的学习使我了解了在Go语言中如何优雅地处理请求上下文，更好地控制请求的流程和生命周期。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINUX 挑战：用户和组管理</title>
      <link href="/2023/05/08/%E6%8C%91%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/"/>
      <url>/2023/05/08/%E6%8C%91%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="LINUX-挑战：用户和组管理"><a href="#LINUX-挑战：用户和组管理" class="headerlink" title="LINUX 挑战：用户和组管理"></a>LINUX 挑战：用户和组管理</h1><ol><li></li></ol><pre><code>wget https://labfile.oss.aliyuncs.com/courses/2585/06.tar.gztar -xzf 06.tar.gzchmod 700 ./06.sh./06.sh</code></pre><ol start="2"><li></li></ol><pre><code>sudo userdel guest2sudo userdel guest3sudo userdel guest4sudo userdel guest5sudo rm -rf /home/guest2sudo rm -rf /home/guest3sudo rm -rf /home/guest4sudo rm -rf /home/guest5sudo groupadd guestmkdir /tmp/tempusersudo usermod -u 2000 -g guest -d /tmp/tempuser guest1 </code></pre><ol start="3"><li></li></ol><pre><code>sudo mkdir /home/vsftpdusersudo useradd vsftpduser -d /home/vsftpduser -s /usr/sbin/nologin sudo chown vsftpduser /home/vsftpdusersudo chgrp vsftpduser /home/vsftpdusersudo chmod 744 /home/vsftpduser</code></pre><ol start="4"><li></li></ol><pre><code>sudo useradd magsudo useradd devsudo useradd testsudo mkdir /srv/projectx/magsudo mkdir /srv/projectx/devsudo mkdir /srv/projectx/testsudo usermod -G dev magsudo chown dev:dev /srv/projectxsudo chmod 751 /srv/projectxsudo chmod o+rx /srv/projectx/devsudo chmod o+rx /srv/projectx/test</code></pre><ol start="5"><li></li></ol><pre><code>cat /etc/passwd | grep bash | cut -d &#39;:&#39; -f 1,3 &gt; users.txt</code></pre><ol start="6"><li></li></ol><pre><code>sudo useradd stusudo passwd stu123456123456sudo visudo:21# 按i往里写stu ALL=(shiyanlou:shiyanlou) /bin/touch# 退出按:wq</code></pre><ol start="7"><li></li></ol><pre><code>sudo passwd dev123456123456sudo touch /etc/sudoers.d/devsudo chmod 777 /etc/sudoers.d/devvim /etc/sudoers.d/dev# 按i往里写dev  ALL=(root:root) /usr/sbin/useradd# 退出按:wq</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 开发安全 ｜ 青训营笔记</title>
      <link href="/2023/02/08/Web%20%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/08/Web%20%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 17 天</strong></p><h2 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h2><ul><li><p>Web 相关的攻击介绍</p></li><li><p>Web 相关的防御介绍</p></li></ul><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="XSS-Cross-Site-Scripting"><a href="#XSS-Cross-Site-Scripting" class="headerlink" title="XSS (Cross-Site Scripting)"></a>XSS (Cross-Site Scripting)</h3><p>主要是由于盲目信任用户输入，直接将用户输入渲染出来，导致了攻击脚本的植入</p><p>特点：</p><ol><li>通常难以从 UI 上感知</li><li>窃取用户信息，例如 cookie 和 token</li></ol><p>常见的会导致XSS的代码：</p><pre><code>document.writeel.innerHTML = anyString</code></pre><p>总结来说，所有能够渲染dom结构的函数，都有可能导致XSS攻击。</p><p>比如论坛场景中，<strong>用户提交的内容包含恶意script标签</strong></p><pre><code class="js">fetch(&quot;/submit&quot;, &#123;    body: JSON.stringify(&#123;        id: &quot;1&quot;,        content: `&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;`    &#125;)&#125;)</code></pre><p>导致代码被插入到帖子中，所有用户访问页面都会执行恶意脚本</p><p>XSS 能够分成下面四类</p><p><code>Stored XSS</code> 直接将恶意脚本储存到了数据库中，导致之后的所有访问均会携带恶意脚本，危害很大</p><pre><code>Reflected XSS` 反射型，不储存数据，仅仅从URL传入脚本导致攻击，例如 `/path?param=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p><code>DOM-based XSS</code> 不由服务器参与，攻击的发起和执行都在浏览器，常见于前端框架中</p><p><code>Mutation-based XSS</code> 利用浏览器的特性，不同浏览器会有区别，例如</p><pre><code>&lt;noscript&gt;&lt;p title=&quot;&lt;/noscript&gt;&lt;img src=x onerror=alert(1)&gt;&quot;&gt;</code></pre><h3 id="CSRF-Cross-site-request-forgery"><a href="#CSRF-Cross-site-request-forgery" class="headerlink" title="CSRF (Cross-site request forgery)"></a>CSRF (Cross-site request forgery)</h3><p>特点：</p><ol><li>在用户不知情的前提下</li><li>利用用户权限（cookie）</li><li>构造指定HTTP请求，窃取或修改用户敏感信息</li></ol><p>例子：</p><p>用户没有访问银行网页，但是访问了一个带有攻击内容的网页，该网页尝试请求银行接口，由于用户登录过银行，接口携带cookie，导致请求成功，使得用户受到损失。</p><h3 id="SQL-注入-SQL-Injection"><a href="#SQL-注入-SQL-Injection" class="headerlink" title="SQL 注入 (SQL Injection)"></a>SQL 注入 (SQL Injection)</h3><p>在请求参数中构造恶意字符串，拼接SQL语句，导致服务器执行了特定的SQL语句，造成数据库内容泄露</p><p>例子：</p><pre><code class="js">sql.query(`    SELECT a, b, c FROM table    WHERE username = $&#123;username&#125;    AND form_id = $&#123;form_id&#125;`)</code></pre><p>上面的这段后端代码，攻击者就能够通过构造特殊的 username 或 form_id，使得SQL语句的意义被改变</p><p>例如传入 form_id &#x3D; <code>any; DROP TABLE table;</code></p><p>SQL 语句拼接后变成 <code>SELECT a,b,c FROM table WHERE xxxx AND form_id = any; DROP TABLE table;</code></p><p>将导致数据库被删除</p><h3 id="SSRF-Server-Side-Request-Forgery"><a href="#SSRF-Server-Side-Request-Forgery" class="headerlink" title="SSRF (Server-Side Request Forgery)"></a>SSRF (Server-Side Request Forgery)</h3><p>服务端伪造请求</p><p>例子：</p><pre><code>ctx.body = await fetch(ctx.query.callback)</code></pre><p>导致能够通过传入的参数访问到服务器内网的相关服务</p><h3 id="DoS-Denial-of-Service"><a href="#DoS-Denial-of-Service" class="headerlink" title="DoS (Denial of Service)"></a>DoS (Denial of Service)</h3><p><code>「 不搞复杂的 ， 量大就完事儿了 」</code></p><p>通过构造特定请求，导致服务器资源被消耗，来不及响应更多请求，引发雪崩效应</p><p>例如：</p><ol><li>耗时的同步操作</li><li>文件备份</li><li>数据库写入</li><li>SQL join</li><li>循环执行逻辑</li></ol><h4 id="DDoS-Distributed-DoS"><a href="#DDoS-Distributed-DoS" class="headerlink" title="DDoS (Distributed DoS)"></a>DDoS (Distributed DoS)</h4><p>攻击特点</p><ul><li>直接访问 IP</li><li>任意 API</li><li>消耗大量带宽 （ 耗尽 ）</li></ul><p>SYN Flood</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>安全无小事<br>使用的依赖 npm package，甚至是 NodeJS 可能成为最薄弱的一环</p><ul><li>保持学习心态<br>npm install 除了带来了果洞 ， 还可以带来漏洞</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://bytedance.feishu.cn/file/boxcn9L4YzmTK3mwE3tIBL2UVme">https://bytedance.feishu.cn/file/boxcn9L4YzmTK3mwE3tIBL2UVme</a></p><p><a href="https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065">https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NextJs ｜ 青训营笔记</title>
      <link href="/2023/02/01/NextJS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/01/NextJS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 16 天</strong></p><h2 id="一、本堂课重点内容："><a href="#一、本堂课重点内容：" class="headerlink" title="一、本堂课重点内容："></a>一、本堂课重点内容：</h2><ol><li>CSR, SSR, SSG</li><li>什么是 Next.js</li><li>Next.js 客户端开发</li><li>Next.js服务端开发</li><li>核心功能</li></ol><h2 id="二、详细知识点介绍："><a href="#二、详细知识点介绍：" class="headerlink" title="二、详细知识点介绍："></a>二、详细知识点介绍：</h2><h3 id="1-CSR-SSR-SSG"><a href="#1-CSR-SSR-SSG" class="headerlink" title="1. CSR, SSR, SSG"></a>1. CSR, SSR, SSG</h3><h4 id="1-CSR（客户端渲染-Client-Side-Render）"><a href="#1-CSR（客户端渲染-Client-Side-Render）" class="headerlink" title="1. CSR（客户端渲染 Client Side Render）"></a>1. CSR（客户端渲染 Client Side Render）</h4><p>即在客户端渲染网页结构，一般情况下我们所熟知的 Vue、React 均采用这种模式。在构建时并不会生成HTML结构，仅仅包含js代码的引用。在浏览器端将HTML结构渲染出来。客户端渲染会在项目体积较大的时候可能会导致较长的首屏加载时间，用户体验不好，且对于SSO来说并不友好。</p><h4 id="2-SSR（服务端渲染-Server-Side-Render）"><a href="#2-SSR（服务端渲染-Server-Side-Render）" class="headerlink" title="2. SSR（服务端渲染 Server Side Render）"></a>2. SSR（服务端渲染 Server Side Render）</h4><p>浏览器请求时，服务器直接生成HTML结构并返回，这种模式其实并不少见，曾经的<code>php</code>和<code>jsp</code>都是这种模式。<code>Vue</code> 和 <code>React</code> 也对这种模式进行了支持，例如 React 下有 <code>Vercel</code> 主导的 <code>Next.js</code> 框架支持服务端渲染，Vue 下也有类似的框架 Nuxt.js。与前者的区别是，<code>php</code>和<code>jsp</code>的前后端代码实际上仍是分离的，需要动态交互的部分还是需要<code>js</code>介入。而<code>React</code>和<code>Vue</code>在服务端和客户端都是同一套代码，这也就导致其比前者多了一步水合 <code>hydrate</code> (也称注水) 的操作。</p><p>在这种模式下，服务端在生成HTML的同时对其进行“脱水”，即将渲染结构的初始数据分离出来，单独储存，以便让前端读取。在浏览器收到页面后，相关的代码读取这部分内容，再对html结构进行“注水”（水合），使得服务端和客户端的数据同步，且浏览器端的元素能够正常交互。</p><p>比起CSR，SSR能够大幅缩短首屏加载的时间，且对于SSO友好，但是需要服务器支持。</p><h4 id="3-SSG（静态网页生成-Static-Site-Generation）"><a href="#3-SSG（静态网页生成-Static-Site-Generation）" class="headerlink" title="3. SSG（静态网页生成 Static Site Generation）"></a>3. SSG（静态网页生成 Static Site Generation）</h4><p>这种形式实际上和SSR类似，但是无需运行一个服务端，HTML结构在构建时就已经创建完了，用户访问时，仍然是个静态页，却具有SSR首屏加载时间短的优势，适合那些修改不频繁的站点，例如一些开发文档。</p><h3 id="2-什么是-Next-js"><a href="#2-什么是-Next-js" class="headerlink" title="2.什么是 Next.js"></a>2.什么是 Next.js</h3><p>基于 React 提供的相关服务器端渲染 API 实现 ， 整个过程实现比较繁琐重复 ， 从零实现对新上手同学很不友好迫切需要一个封装好的集合来快速上手服务器端渲染。</p><p>Next.js是一个构建于 Node.js之上的开源 we b 开发框架 ，支持基于 React 的 web 应用程序功能 ， 例如服务端渲染和生成静态网站 。上手快 ， 能力集全 ， 覆盖了足够多的性能优化。</p><p>对于新同学掌握前后端一体化的开发模式很友好 。</p><h3 id="3-Next-js-客户端开发"><a href="#3-Next-js-客户端开发" class="headerlink" title="3. Next.js 客户端开发"></a>3. Next.js 客户端开发</h3><ol><li>Next.js 初始化</li><li>数据注入</li><li><code>getlnitiaIProps</code></li><li><code>getServerSideProps</code></li><li><code>getStaticProps</code></li><li>CSS Modules</li><li>Layout</li><li>文件式路由</li><li>B F F 层的文件式路由</li><li>路由跳转</li><li>header 的修改</li><li>多媒体适配—— CSS 适配</li><li>多媒体适配—— JS 适配</li><li>大图优化—— webp</li></ol><h3 id="4-Next-js服务端开发"><a href="#4-Next-js服务端开发" class="headerlink" title="4. Next.js服务端开发"></a>4. Next.js服务端开发</h3><ol><li>BFF 层开发</li><li>调试方式</li><li>Strapi —— headless CMS</li></ol><h3 id="5-核心功能"><a href="#5-核心功能" class="headerlink" title="5. 核心功能"></a>5. 核心功能</h3><h4 id="首页功能实现"><a href="#首页功能实现" class="headerlink" title="首页功能实现"></a>首页功能实现</h4><ol><li>页面 &amp; 动画 &amp; 多媒体适配</li><li>BFF</li><li>Strapi</li></ol><h4 id="文章页实现"><a href="#文章页实现" class="headerlink" title="文章页实现"></a>文章页实现</h4><ol><li>页面 &amp; 动画 &amp; 多媒体适配</li><li>BFF</li><li>Strapi 分页</li><li>多媒体格式的转换<ul><li>markdown 转 html</li><li>html 转 dom</li><li>公共样式的定义</li></ul></li></ol><h4 id="主题化功能实现"><a href="#主题化功能实现" class="headerlink" title="主题化功能实现"></a>主题化功能实现</h4><ol><li>基础样式和背景的抽离</li><li>主题化 <code>context</code> 全局注入</li><li>从注入数据中取出 <code>theme</code> 和 <code>setTheme</code></li><li>多进程间的主题同步</li></ol><h2 id="三、实践练习例子："><a href="#三、实践练习例子：" class="headerlink" title="三、实践练习例子："></a>三、实践练习例子：</h2><h3 id="思考题-：-http-localhost-3000-和-http-127-0-0-1-3000-主题可以共享吗"><a href="#思考题-：-http-localhost-3000-和-http-127-0-0-1-3000-主题可以共享吗" class="headerlink" title="思考题 ： http://localhost:3000 和 http://127.0.0.1:3000 主题可以共享吗"></a>思考题 ： <a href="http://localhost:3000/">http://localhost:3000</a> 和 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 主题可以共享吗</h3><p>答案是<strong>不能</strong></p><p>如果存在<code>localstorage</code>里</p><p>那么这俩域名不是同域名</p><p>不会共享</p><h3 id="初始化-Next-js-项目"><a href="#初始化-Next-js-项目" class="headerlink" title="初始化 Next.js 项目"></a>初始化 Next.js 项目</h3><p>Next.js 提供了一个脚手架，直接就能够创建项目</p><pre><code class="bash">npx create-next-app@latest --typescript</code></pre><p>接下来就能够看到创建完成的项目目录了。可能会有下面这些文件</p><p><code>.eslintrc.json</code> - eslint 的配置文件，配置了eslint使用的语法规则</p><p><code>.gitignore</code> - git 仓库的忽略文件</p><p><code>next-env.d.ts</code> - TypeScript 的类型定义，是为了方便引入Next声明的类型</p><p><code>next.config.js</code> - Next.js 的配置文件</p><p><code>pages</code> - 页面目录</p><p><code>styles</code> - 样式目录</p><p><code>public</code> - 公共资源目录，会在构建时被原样拷贝</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>本次课程讲解了 Next.js 的基础概念、客户端开发以及服务端开发，以及核心功能的实现，让我对 Next.js 拥有了更多的了解，它的客户端和服务端的开发可以让我们更有效的实现功能，并且在项目构建的时候可以利用它的脚手架快速创建项目，实现更加高效的开发。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS基础 ｜ 青训营笔记.md</title>
      <link href="/2023/01/31/NodeJS%E5%9F%BA%E7%A1%80%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/31/NodeJS%E5%9F%BA%E7%A1%80%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 15 天</strong></p><h2 id="一、本堂课重点内容："><a href="#一、本堂课重点内容：" class="headerlink" title="一、本堂课重点内容："></a>一、本堂课重点内容：</h2><ol><li>NodeJS 应用场景</li><li>NodeJS 运行时结构</li><li>使用 NodeJS 编写简单的 HTTP Server</li><li>NodeJS延伸</li></ol><h2 id="二、详细知识点介绍："><a href="#二、详细知识点介绍：" class="headerlink" title="二、详细知识点介绍："></a>二、详细知识点介绍：</h2><h3 id="1-NodeJS应用场景"><a href="#1-NodeJS应用场景" class="headerlink" title="1. NodeJS应用场景"></a>1. NodeJS应用场景</h3><p>NodeJS被广泛应用于前端工程化（<code>Vue</code>、<code>React</code>、<code>AngularJS</code>等）、</p><p>Web 服务端应用（<code>Vercel</code>）和 跨端桌面应用（<code>Electron</code>等）场景</p><p>许多熟知的打包构建工具都有NodeJS参与，例如 <code>webpack</code>、<code>vite</code>、<code>esbuild</code>和<code>parcel</code>等，也有例如<code>babel</code>和<code>TS</code>等语言转换程序也由<code>nodejs</code>编写。</p><p>在前端工程化领域，<code>NodeJS</code>也有许多优势，首先是学习曲线平缓、开发效率较高、其次是运行效率较高，社区生态丰富。且由于其语言优势，和前端结合更加顺畅，例如某些服务端渲染场景。</p><p>在跨端应用方面，微软的<code>VSCode</code>、聊天工具<code>Discord</code>都由<code>Electron</code>开发，值得在项目选型时考虑。</p><p>难以替代</p><p>与前端结合的场景有很大的优势SSR</p><p>字节使用<code>NodeJS</code>，飞书就是<code>electron</code>应用  每年新增1000+<code>nodejs</code>应用</p><h3 id="2-NodeJS运行时结构"><a href="#2-NodeJS运行时结构" class="headerlink" title="2.NodeJS运行时结构"></a>2.NodeJS运行时结构</h3><ul><li>用户代码</li><li>npm</li><li>js core</li><li>cpp core</li><li>v8</li><li>openssl</li><li>…</li></ul><p>异步、单线程、跨平台</p><h3 id="3-使用-NodeJS-编写简单的-HTTP-Server"><a href="#3-使用-NodeJS-编写简单的-HTTP-Server" class="headerlink" title="3. 使用 NodeJS 编写简单的 HTTP Server"></a>3. 使用 NodeJS 编写简单的 HTTP Server</h3><p>0 ． 安装 <code>node.js</code><br>1 .    编写 Http Server + Client, 收发 GET, POST 请求<br>2 ． 编写静态文件服务器<br>3 ． 编写 React SSR 服务<br>4 ． 适用 inspector 进行调试 、 诊断<br>5 ． 部署简介</p><h3 id="4-NodeJS延伸"><a href="#4-NodeJS延伸" class="headerlink" title="4. NodeJS延伸"></a>4. NodeJS延伸</h3><ul><li>编译</li><li>诊断追踪</li><li>wasm</li><li>napi</li><li>…</li></ul><h2 id="三、实践练习例子："><a href="#三、实践练习例子：" class="headerlink" title="三、实践练习例子："></a>三、实践练习例子：</h2><h3 id="简单的-Hello-World"><a href="#简单的-Hello-World" class="headerlink" title="简单的 Hello World"></a>简单的 Hello World</h3><pre><code class="js">const http = require(&#39;http&#39;)const port = 3000const server = http.createServer((req, res) =&gt; &#123;    res.end(&#39;hello&#39;)&#125;)server.listen(port, () =&gt; &#123;    console.log(`listening port on $&#123;port&#125;`)&#125;)</code></pre><p>使用 <code>require(&#39;http&#39;)</code> 引用 NodeJS 自带的 http 模块。</p><p>使用 <code>createServer</code> 方法为请求绑定处理事件函数，</p><p>使用 <code>res.end(&#39;hello&#39;)</code> 来结束请求并返回 <code>hello</code> 字符串。</p><p>使用 <code>listen</code> 函数设置监听的端口，第一个参数是端口号，第二个参数是绑定成功的回调函数。</p><p>用浏览器访问127.0.0.1:3000 会显示hello</p><h3 id="简单的静态文件服务"><a href="#简单的静态文件服务" class="headerlink" title="简单的静态文件服务"></a>简单的静态文件服务</h3><pre><code class="js">const http = require(&#39;http&#39;)const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const url = require(&#39;url&#39;)const port = 3000const server = http.createServer((req, res) =&gt; &#123;    const info = url.parse(req.url)    const file = fs.createReadStream(path.resolve(__dirname, &#39;.&#39; + info.pathname))    file.pipe(res)&#125;)server.listen(port, () =&gt; &#123;    console.log(`listening port on $&#123;port&#125;`)&#125;)</code></pre><p>通过 NodeJS 自带的文件操作模块 <code>fs</code> 的 <code>createReadStream</code> 创建了一个文件流，</p><p>通过流内部方法pipe将其输出给res（响应对象）</p><p>能将对应路径的文件返回给浏览器</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>今天的课程主要介绍了<strong>NodeJS</strong>的应用场景以及运行时结构，并且结合实例介绍了如何使用<strong>NodeJS</strong>编写简单的HTTP Server。通过今天的学习，我更加深入地了解了<strong>NodeJS</strong>，再次感受到它的强大，它可以应用于前端工程化、Web 服务端应用以及跨端桌面应用等多种场景，它的未来也是非常可观的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slidev 用markdown写PPT！｜ 青训营笔记</title>
      <link href="/2023/01/30/Slidev%20%E7%94%A8markdown%E5%86%99PPT%EF%BC%81%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/30/Slidev%20%E7%94%A8markdown%E5%86%99PPT%EF%BC%81%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 14 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>欢迎使用 Slidev!为开发者打造的演示文稿工具</code></pre><p>slidev是slidevjs开发的一款开源的使用markdown来编写ppt样式的前端应用的框架</p><p>只需要在单一 Markdown 文件中编写幻灯片就可以创建一个非常漂亮的前端ppt应用</p><p>这个项目自从<code>0.20.0</code>版本我就关注来着，当时就觉得很炫很好用</p><p>昨天看到了antfu更新说在最新版本<code>0.39.0</code>里支持了简单的动画切换效果</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130155007.png"></p><p>😋感觉动画切换是ppt最重要的东西吧，很好很圆满😎</p><p>来试试</p><p><img src="https://cn.sli.dev/screenshots/cover.png" alt="img"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p><strong>支持 Markdown 语法</strong>：Slidev 使用一种扩展的 Markdown 格式，在一个纯文本文件中存储和组织你的幻灯片。这让你专注于制作内容。而且由于内容和样式是分开的，这也使得在不同的主题之间切换变得更加容易。</p></li><li><p><strong>可定制主题</strong>：Slidev 的主题可以通过 <code>npm</code> 包的形式来分享和安装。</p></li><li><p><strong>对开发者友好</strong>：Slidev 为开发者提供了一流的代码片段支持。它同时支持 <a href="https://prismjs.com/">Prism</a> 和 <a href="https://github.com/shikijs/shiki">Shiki</a> 以获得像素级的完美语法高亮，并且能够随时修改代码。通过内置的 <a href="https://microsoft.github.io/monaco-editor/">Monaco 编辑器</a>，它还能让你在演示文稿中进行现场编码&#x2F;演示，并支持自动补全、类型悬停、甚至是 <code>TypeScript</code> 类型检查。</p></li><li><p><strong>快速</strong>：Slidev 得益于 <a href="https://vitejs.dev/">Vite</a>，<a href="https://v3.vuejs.org/">Vue 3</a> 和 <a href="https://windicss.org/">Windi CSS</a>，为你带来了最美妙的创作体验。你所做的每一个改变都会<strong>立即反映</strong>到你的幻灯片上。</p></li><li><p><strong>互动性 &amp; 直观表达</strong>：你可以编写自定义的 Vue 组件并直接在你的 MarkDown 文件中使用它们。你也可以在演示文稿中与它们互动，以更深入和直观的方式表达你的想法。</p></li><li><p><strong>支持录制</strong>：Slidev 提供了内置的录音和摄像头视图。你可以将你的演示文稿与你的相机视图一起分享，或者为你的屏幕和相机分别录制并保存。所有这些都是内置的，不需要额外的工具。</p></li><li><p><strong>可移植性</strong>：用一个命令就可以将你的幻灯片导出为 PDF 或 PNG，甚至是可托管的单页应用程序（SPA），并在任何地方分享它们。</p></li><li><p><strong>可配置</strong>：由于 Slidev 基于 Web 技术，任何可以在 Web 应用中完成的事情，Slidev 也可以做到。例如，<code>WebGL</code>、<code>API请求</code>、<code>iframes</code>，甚至是实时共享。完全取决于你的想象力!</p></li><li><p><strong>演讲者模式</strong>： 可以使用另一个窗口，甚至是你的手机来控制幻灯片。</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm init slidev</code></pre><p>在package.json里配置</p><pre><code>&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;slidev&quot;, //  启动 dev server    &quot;build&quot;: &quot;slidev build&quot;, // 构建生产环境的单页面应用    &quot;export&quot;: &quot;slidev export&quot; // 将幻灯片导出为 pdf 格式  &#125;&#125;</code></pre><p>执行 <code>npx slidev --help</code> 命令获取更多选项的详细信息。</p><p>这样就安装完成了，你只需要在<code>./slides.md</code>里编写你想要的内容就行😎</p><h2 id="推荐的目录结构"><a href="#推荐的目录结构" class="headerlink" title="推荐的目录结构"></a>推荐的目录结构</h2><pre><code>your-slidev/  ├── components/       # 自定义组件  ├── layouts/          # 自定义布局  ├── public/           # 静态资源  ├── setup/            # 自定义 setup / hooks  ├── styles/           # 自定义样式  ├── index.html        # 注入的 index.html  ├── slides.md         # 幻灯片主入口  └── vite.config.ts    # 扩展 vite 配置</code></pre><h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>使用 <code>---</code> 添加分隔符来分隔你的幻灯片。</p><p>注意 这个分隔符最好上下空两行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130162517.png"></p><p>像这样 </p><p>你可以安装一个VSCode插件 名叫slidev 来获得更好的体验，<a href="https://marketplace.visualstudio.com/items?itemName=antfu.slidev">https://marketplace.visualstudio.com/items?itemName=antfu.slidev</a></p><p>这个#2是插件告诉你这下面是第几张幻灯片</p><pre><code># SlidevHello, World!---# Page 2Directly use code blocks for highlighting```tsconsole.log(&#39;Hello, World!&#39;)```---# Page 3You can directly use Windi CSS and Vue components to style and enrich your slides.&lt;div class=&quot;p-3&quot;&gt;  &lt;Tweet id=&quot;20&quot; /&gt;&lt;/div&gt;</code></pre><p>像这样就创建了三张幻灯片</p><h4 id="扉页及布局"><a href="#扉页及布局" class="headerlink" title="扉页及布局"></a>扉页及布局</h4><p>用两个分隔符来表示一个扉页块</p><pre><code>---layout: cover---</code></pre><p>两个分隔符里是<code>yaml</code>格式的对象</p><p>具体的语法如下</p><pre><code>---# 主题id 或 主题包名称# 了解更多：https://sli.dev/themes/use.htmltheme: &#39;default&#39;# 幻灯片的总标题，如果没有指定，那么将以第一张拥有标题的幻灯片的标题作为总标题title: &#39;Slidev&#39;# titleTemplate for the webpage, `%s` will be replaced by the page&#39;s titletitleTemplate: &#39;%s - Slidev&#39;# information for your slides, can be a markdown stringinfo: false# 在单页（SPA）构建中启用 pdf 下载，也可以指定一个自定义 urldownload: false# 要导出文件的文件名称exportFilename: &#39;slidev-exported.pdf&#39;# 语法高亮设置，可以使用 &#39;prism&#39; 或 &#39;shiki&#39; 方案highlighter: &#39;prism&#39;# 在代码块中显示行号lineNumbers: false# 启用 monaco 编辑器，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;monaco: &#39;dev&#39;# 使用 vite-plugin-remote-assets 在本地下载远程资源，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;remoteAssets: false# 控制幻灯片中的文本是否可以选择selectable: true# 启用幻灯片录制，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;record: &#39;dev&#39;# 幻灯片的配色方案，可以使用 &#39;auto&#39;，&#39;light&#39; 或者 &#39;dark&#39;colorSchema: &#39;auto&#39;# vue-router 模式，可以使用 &#39;history&#39; 或 &#39;hash&#39; 模式routerMode: &#39;history&#39;# 幻灯片的长宽比aspectRatio: &#39;16/9&#39;# canvas 的真实宽度，单位为 pxcanvasWidth: 980# 用于主题定制，会将属性 `x` 注入根样式 `--slidev-theme-x`themeConfig:  primary: &#39;#5d8392&#39;# favicon 可以是本地文件路径，也可以是一个 URLfavicon: &#39;https://cdn.jsdelivr.net/gh/slidevjs/slidev/assets/favicon.png&#39;# 用于渲染图表的 PlantUML 服务器的 URLplantUmlServer: &#39;https://www.plantuml.com/plantuml&#39;# 字体将从 Google 字体自动导入# 了解更多：https://sli.dev/custom/fontsfonts:  sans: &#39;Roboto&#39;  serif: &#39;Roboto Slab&#39;  mono: &#39;Fira Code&#39;# 为所有幻灯片添加默认的 frontmatterdefaults:  layout: &#39;default&#39;  # ...# 绘制选项# 了解更多：https://sli.dev/guide/drawing.htmldrawings:  enabled: true  persist: false  presenterOnly: false  syncAll: true---</code></pre><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>可以通过&#96;&#96;&#96;来创建一个代码块</p><pre><code>```tsconsole.log(&#39;Hello, World!&#39;)```</code></pre><p>可以通过在语言名后写大括号的形式来指定特定行高亮<code>&#123;&#125;</code></p><p>注意：行号从 1 开始计算。</p><pre><code>```ts &#123;2-3|5|all&#125;function add(  a: Ref&lt;number&gt; | number,  b: Ref&lt;number&gt; | number) &#123;  return computed(() =&gt; unref(a) + unref(b))&#125;```</code></pre><p>这段代码的意思是 点进来先是2到3行高亮，再点一下2到3不亮第5行亮，再点一下整个都亮</p><h4 id="Monaco-编辑器"><a href="#Monaco-编辑器" class="headerlink" title="Monaco 编辑器"></a>Monaco 编辑器</h4><p>只需在语言 id 后添加 <code>&#123;monaco&#125;</code> 就可以启用monaco</p><p>什么是monaco呢，可以理解为网页版的vscode那样的，可以在线编辑的</p><pre><code>```ts &#123;monaco&#125;console.log(&#39;HelloWorld&#39;)```</code></pre><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>你可以在 Markdown 中直接使用 <code>&lt;style&gt;</code> 标签来覆盖<strong>当前幻灯片</strong>的样式。</p><p>Slidev支持windicss的原子化写法和指令集 例如<code>@apply</code></p><pre><code># Slidev&gt; Hello `world`&lt;style&gt;blockquote &#123;  code &#123;    @apply text-teal-500 dark:text-teal-400;  &#125;&#125;&lt;/style&gt;</code></pre><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>和编写 Markdown 的方式一样，你可以使用本地或远程的 URL 的图片。</p><p>远程资源会缓存</p><p>本地资源请放到public文件夹</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>你也可以为每张幻灯片编写备注。它们将展示在 <a href="https://cn.sli.dev/guide/presenter-mode.html">演讲者模式</a> 中，供你在演示时参考。</p><p>在每一页幻灯片内容最后</p><p>添加注释即可</p><pre><code>---layout: cover---# 第 1 页This is the cover page.&lt;!-- 这是一条备注 --&gt;---# 第 2 页&lt;!-- 这不是一条备注，因为它在幻灯片内容前 --&gt;The second page&lt;!--这是另一条备注--&gt;</code></pre><h4 id="icon图标"><a href="#icon图标" class="headerlink" title="icon图标"></a>icon图标</h4><p>很喜欢的功能</p><p>Slidev 允许你在 Markdown 中<strong>直接</strong>访问几乎所有的开源的图标集。</p><p>你可以通过 <a href="https://icones.js.org/">Icônes</a> 来浏览访问所有可用的图标。</p><p>更详细的请看<a href="https://cn.sli.dev/guide/syntax.html#icons">https://cn.sli.dev/guide/syntax.html#icons</a></p><h4 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h4><p>这个不是很熟啊</p><p><a href="https://demo.sli.dev/starter/8">https://demo.sli.dev/starter/8</a></p><p>可以看下示例 和 文档</p><p><a href="https://katex.org/">https://katex.org/</a></p><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><p>这个东西也没怎么用过，只知道github什么的支持这种语法 基于<a href="https://github.com/mermaid-js/mermaid">https://github.com/mermaid-js/mermaid</a></p><p>被标记为 <code>mermaid</code> 的代码块将被转换为图形，例如：</p><pre><code>```mermaidsequenceDiagram  Alice-&gt;John: Hello John, how are you?  Note over Alice,John: A typical interaction```</code></pre><pre><code class="mermaid">sequenceDiagram  Alice-&gt;John: Hello John, how are you?  Note over Alice,John: A typical interaction</code></pre><p>我在typora也可以创建这个图表，感觉很好用</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130170429.png"></p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130170544.png"></p><p>导航栏默认在左下角，鼠标移动上去显示</p><p>可以用<code>right / space</code>来切换下一张幻灯片</p><p>按<code>g</code>跳出一个栏，输入页码可以跳转</p><p>更多快捷键详见<a href="https://cn.sli.dev/guide/navigation.html#navigation-bar">https://cn.sli.dev/guide/navigation.html#navigation-bar</a></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>重头戏</p><p>这个版本就更新了这个</p><h4 id="点击动画"><a href="#点击动画" class="headerlink" title="点击动画"></a>点击动画</h4><p><code>v-click</code> 可以用<code>&lt;v-click&gt;&lt;/v-click&gt;</code>标签或在标签内写<code>&lt;div v-click class=&quot;text-xl p-2&quot;&gt;</code>这样的指令</p><p>以下指令写法同理</p><p><code>v-after</code> 和<code>v-click</code>绑定，这俩会一起显示</p><p><code>v-click-hide</code>点击后不可见</p><p><code>v-clicks</code> 只能使用标签写法 可以方便的展示一个列表</p><pre><code>&lt;v-clicks&gt;- Item 1- Item 2- Item 3- Item 4&lt;/v-clicks&gt;</code></pre><p>你还可以手动指定过渡动画 覆写两个类的动画</p><pre><code>// the default.slidev-vclick-target &#123;  transition: opacity 100ms ease;&#125;.slidev-vclick-hidden &#123;  opacity: 0;  pointer-events: none;&#125;</code></pre><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p><a href="https://vueuse.org/functions.html#category=%40Motion">https://vueuse.org/functions.html#category=%40Motion</a></p><p>内置了vueuse的motion功能</p><p>你可以对任何元素应用 <code>v-motion</code> 指令，以对它们施加运动效果。例如：</p><pre><code>&lt;div  v-motion  :initial=&quot;&#123; x: -80 &#125;&quot;  :enter=&quot;&#123; x: 0 &#125;&quot;&gt;  Slidev&lt;/div&gt;</code></pre><p>文本 <code>Slidev</code> 将从其初始化位置 <code>-80px</code> 移至其原始位置。</p><h4 id="页面过渡"><a href="#页面过渡" class="headerlink" title="页面过渡"></a>页面过渡</h4><p>🤩新功能！</p><p>可以在扉页中填写</p><pre><code>---transition: slide-left---</code></pre><p>这将给你一个很好的滑动效果。将其设置在首页，将适用于所有的幻灯片。您还可以为每张幻灯片设置不同的过渡。</p><p>自带的过渡效果</p><pre><code>fade - Crossfade in/outfade-out - Fade out and then fade inslide-left - Slides to the left, slide to right when going backslide-right - Slides to the right, slide to left when going backslide-top - Slides to the top, slide to bottom when going backslide-bottom - Slides to the bottom, slide to top when going back</code></pre><p>还可以自定义过渡效果</p><pre><code>---transition: my-transition---</code></pre><pre><code>.my-transition-enter-active,.my-transition-leave-active &#123;  transition: opacity 0.5s ease;&#125;.my-transition-enter-from,.my-transition-leave-to &#123;  opacity: 0;&#125;</code></pre><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>导出为pdf 依赖于微软开源的playwright框架</p><p><a href="https://playwright.dev/docs/installation#download-single-browser-binary"><code>playwright-chromium</code></a></p><p>需要先安装</p><pre><code>npm i -D playwright-chromium</code></pre><p>使用</p><pre><code>slidev export</code></pre><p>可导出pdf格式</p><pre><code>slidev export --format png</code></pre><p>可导出png格式</p><h2 id="静态部署"><a href="#静态部署" class="headerlink" title="静态部署"></a>静态部署</h2><pre><code>slidev build</code></pre><p>编译当前幻灯片生成在<code>dist/</code>目录下，可以部署到静态托管平台</p><h4 id="提供可下载的-PDF"><a href="#提供可下载的-PDF" class="headerlink" title="提供可下载的 PDF"></a>提供可下载的 PDF</h4><p>在扉页中设置</p><pre><code>---download: true---</code></pre><p>会在单页应用中展示下载按钮</p><p>也可以自定义url</p><pre><code>---download: &#39;https://myside.com/my-talk.pdf&#39;---</code></pre><h4 id="部署到netlify"><a href="#部署到netlify" class="headerlink" title="部署到netlify"></a>部署到netlify</h4><p>创建<code>netlify.toml</code>文件 配置</p><pre><code>[build.environment]  NODE_VERSION = &quot;14&quot;[build]  publish = &quot;dist&quot;  command = &quot;npm run build&quot;[[redirects]]  from = &quot;/*&quot;  to = &quot;/index.html&quot;  status = 200</code></pre><h4 id="部署到vercel"><a href="#部署到vercel" class="headerlink" title="部署到vercel"></a>部署到vercel</h4><p>创建<code>vercel.json</code>文件 配置</p><pre><code>&#123;  &quot;rewrites&quot;: [    &#123; &quot;source&quot;: &quot;/(.*)&quot;, &quot;destination&quot;: &quot;/index.html&quot; &#125;  ]&#125;</code></pre><h2 id="演讲录制"><a href="#演讲录制" class="headerlink" title="演讲录制"></a>演讲录制</h2><h4 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h4><p>导航面板的小人按钮可以开启摄像头</p><p>你可以拖动它，并使用右下角的把手来调整大小。尺寸和位置将持久化存储在 <code>localStorage</code> 中，因此，可以保证多次刷新后的展示一致，无需担心位置和大小丢失的问题。</p><h4 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h4><p>导航面板的摄像机按钮</p><p>可以录制麦克风和摄像头</p><h2 id="演讲者模式"><a href="#演讲者模式" class="headerlink" title="演讲者模式"></a>演讲者模式</h2><p>点击小人带麦克风的按钮</p><p>可以进入演讲者模式</p><p>需要双端在同一网络下</p><p>其他页面的实例会自动和演讲者的页面同步</p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>可以在页面上画画</p><p>可以在演讲者模式中启用，会实时自动同步</p><p>支持触控笔压感</p><h2 id="编辑器整合"><a href="#编辑器整合" class="headerlink" title="编辑器整合"></a>编辑器整合</h2><p>你可以在运行中在网页上更改你的源码，他会自动同步到slide.md里</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>在这里浏览主题并应用到你的实例中</p><p><a href="https://cn.sli.dev/themes/gallery.html">https://cn.sli.dev/themes/gallery.html</a></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><a href="https://cn.sli.dev/builtin/layouts.html">https://cn.sli.dev/builtin/layouts.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇写了不少，详细的写了我比较喜欢的ppt框架</p><p>我有一个部署的版本，地址在 <a href="https://botppt.netlify.app/">https://botppt.netlify.app/</a></p><p>是很久之前写的辣，版本还是很老的，有时间会更新一下</p><p>😎</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://botppt.netlify.app/1">https://botppt.netlify.app/1</a></p><p><a href="https://cn.sli.dev/showcases.html">https://cn.sli.dev/showcases.html</a></p><p><a href="https://cn.sli.dev/">https://cn.sli.dev/</a></p><p><a href="https://github.com/slidevjs/slidev">https://github.com/slidevjs/slidev</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt3与服务端渲染SSR（高级篇） ｜ 青训营笔记</title>
      <link href="/2023/01/29/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/29/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 13 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两篇写了一些nuxt3和SSR的基础</p><p>这一篇讲讲nuxt3比较进阶的部分</p><h2 id="自动引入"><a href="#自动引入" class="headerlink" title="自动引入"></a>自动引入</h2><h4 id="nuxt3自带自动引入"><a href="#nuxt3自带自动引入" class="headerlink" title="nuxt3自带自动引入"></a>nuxt3自带自动引入</h4><p>包括一些nuxt3的api都是不用导入的直接就可以用</p><p>例如</p><ul><li><p>数据获取的函数<code>useFetch</code> <code>useAsyncData</code> </p></li><li><p>状态管理函数<code>useState</code> </p></li><li><p>运行变量获取函数 <code>useRuntimeConfig</code></p></li><li><p>运行时上下文获取函数 <code>useNuxtApp</code></p></li></ul><h4 id="还有一些Vue的api"><a href="#还有一些Vue的api" class="headerlink" title="还有一些Vue的api"></a>还有一些Vue的api</h4><p>例如</p><ul><li><p>响应式的函数<code>ref</code></p></li><li><p>计算属性 <code>computed</code></p></li></ul><h4 id="文件夹下的内容自动引入"><a href="#文件夹下的内容自动引入" class="headerlink" title="文件夹下的内容自动引入"></a>文件夹下的内容自动引入</h4><p>例如</p><ul><li><code>components/</code>文件夹下的组件</li><li><code>composables/</code>文件夹下的响应式函数</li><li><code>utils/</code>文件夹下的工具函数</li></ul><h4 id="可以使用-imports来使导入明确"><a href="#可以使用-imports来使导入明确" class="headerlink" title="可以使用#imports来使导入明确"></a>可以使用<code>#imports</code>来使导入明确</h4><pre><code>&lt;script setup&gt;  import &#123; ref, computed &#125; from &#39;#imports&#39;  const count = ref(1)  const double = computed(() =&gt; count.value * 2)&lt;/script&gt;</code></pre><h4 id="关闭自动引入"><a href="#关闭自动引入" class="headerlink" title="关闭自动引入"></a>关闭自动引入</h4><p>在<code>nuxtconfig</code>里加入</p><pre><code>export default defineNuxtConfig(&#123;  imports: &#123;    autoImport: false  &#125;&#125;)</code></pre><p>（😡谁会这么做</p><h2 id="自动引入的组件"><a href="#自动引入的组件" class="headerlink" title="自动引入的组件"></a>自动引入的组件</h2><p>假设目录如下</p><pre><code>| components/--| base/----| foo/------| Button.vue</code></pre><p>此时可以使用<code>&lt;BaseFooButton /&gt;</code>标签引入这个button组件</p><p>另外，可以使用一个Lazy前缀来懒加载组件</p><p>例如</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Mountains&lt;/h1&gt;    &lt;LazyMountainsList v-if=&quot;show&quot; /&gt;    &lt;button v-if=&quot;!show&quot; @click=&quot;show = true&quot;&gt;Show List&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      show: false    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>这样可以减少打包大小，增加性能</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>写在<code>pages/</code>里的组件会自动写入路由</p><p><code>pages/index.vue</code>会匹配路由<code>/</code></p><p>只需要在<code>app.vue</code>里添加</p><p><code>&lt;NuxtPage /&gt;</code>标签</p><p>可以通过插槽写法例如写<code>[id].vue</code>来匹配路由内的参数</p><p>例如如下文件树</p><pre><code>-| pages/---| index.vue---| users-[group]/-----| [id].vue</code></pre><p>在<code>[id].vue</code>里写下</p><pre><code>&lt;template&gt;  &lt;p&gt;&#123;&#123; $route.params.group &#125;&#125; - &#123;&#123; $route.params.id &#125;&#125;&lt;/p&gt;&lt;/template&gt;</code></pre><p>读取group参数和id参数</p><p>访问路由<code>/users-admins/123</code>会渲染成</p><pre><code>&lt;p&gt;admins - 123&lt;/p&gt;</code></pre><h2 id="渲染模式"><a href="#渲染模式" class="headerlink" title="渲染模式"></a>渲染模式</h2><h4 id="传统的Vue项目渲染方式为-客户端渲染"><a href="#传统的Vue项目渲染方式为-客户端渲染" class="headerlink" title="传统的Vue项目渲染方式为  客户端渲染"></a>传统的Vue项目渲染方式为  <code>客户端渲染</code></h4><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230129144946.png"></p><p>浏览器会先下载到空的html文件→下载js→渲染出来</p><p>这种方式的优点是：</p><ul><li><p>开发速度快：当完全在客户端上工作时，我们不必担心代码的服务器兼容性，例如，使用像windows这样的浏览器api。 </p></li><li><p>更便宜的服务器成本：运行一个服务器会增加一个基础设施的成本，因为您需要在一个支持JavaScript的平台上运行。我们可以在任何具有HTML、CSS和JavaScript文件的静态服务器上托管仅限客户端的应用程序。 </p></li><li><p>下载好后离线：因为代码完全在浏览器中运行，所以它可以很好地在互联网不可用时很好地保持工作。</p></li></ul><p>缺点为：</p><ul><li>性能不好：用户必须等待浏览器下载、解析和运行JavaScript文件。根据下载部分的网络和用户的解析和执行设备，这可能需要一些时间，并影响用户的体验。</li><li>不友好的搜索引擎优化：索引和更新通过客户端呈现交付的内容比使用服务器呈现的HTML文档需要更多的时间。</li></ul><h4 id="nuxt3的服务端渲染"><a href="#nuxt3的服务端渲染" class="headerlink" title="nuxt3的服务端渲染"></a>nuxt3的<code>服务端渲染</code></h4><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230129145732.png"></p><p>有内容的html文件会下载到浏览器→用户在此时可以点击和浏览页面上的内容（部分功能）→需要的组件渲染完成、此时的页面有全部功能</p><p>这种方式的优点是：</p><ul><li>性能好：用户可以立即访问页面的内容，因为浏览器显示静态内容的速度比<code>javascript</code>生成的静态内容要快得多。</li><li>搜索引擎优化：通用呈现将页面的整个HTML内容作为一个经典的服务器应用程序传递到浏览器。Web爬虫可以直接索引页面的内容。</li></ul><p>缺点是：</p><ul><li>开发约束：服务器和浏览器环境不提供相同的api，而且编写可以在两边无缝运行的代码可能会很棘手。幸运的是，Nuxt提供了特定的变量来同步这些。</li><li>成本高：服务器需要运行，才能动态地呈现页面。这就像任何传统服务器一样，增加了每月的成本。但是，由于浏览器接管了客户端导航的通用渲染，服务器调用大大减少了。</li></ul><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>使用 <code>TypeScript</code> 后可以使用nuxi带的语法检查</p><pre><code>yarn nuxi typecheck</code></pre><p>nuxt也会自动生成类型</p><p>在<a href="https://nuxt.com/docs/guide/concepts/typescript#nuxtnuxtdts"><code>.nuxt/nuxt.d.ts</code></a>目录下</p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>一个完整的nuxt3项目文件目录应该包含以下文件夹和文件</p><pre><code>.nuxt                      nuxt生成的文件目录里面有 运行的类型等.output                    build产物文件夹assets                     css文件、字体文件、图片文件components                 组件目录composables                响应式函数的文件夹content                    基于文件的cms的文件夹layouts                    布局组件的文件夹middleware                 中间件文件夹node_modules               依赖文件夹pages                      路由的页面plugins                    nuxt插件public                     公共文件文件夹，可以放ico图标，图片server                     服务端api文件夹utils                      工具函数文件夹.gitignore                 git忽略文件.nuxtignore                不加入nuxt编译的忽略文件app.config.ts              config文件 可以使用useAppConfig读取app.vue                    vue入口 nuxt.config.ts             nuxt配置文件package.json               依赖描述文件tsconfig.json              ts检查配置文件</code></pre><p><a href="https://nuxt.com/docs/guide/directory-structure/nuxt">https://nuxt.com/docs/guide/directory-structure/nuxt</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章介绍了nuxt3的高级用法</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><p>😎🥰</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/docs/guide/concepts/auto-imports">https://nuxt.com/docs/guide/concepts/auto-imports</a></p><p><a href="https://nuxt.com/docs/guide/directory-structure/composables">https://nuxt.com/docs/guide/directory-structure/composables</a></p><p><a href="https://nuxt.com/docs/guide/directory-structure/components">https://nuxt.com/docs/guide/directory-structure/components</a></p><p><a href="https://github.com/unjs/nitro">https://github.com/unjs/nitro</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青训营任务-我的名片-可爱捏☺</title>
      <link href="/2023/01/28/%E3%80%8C%E9%9D%92%E8%AE%AD%E8%90%A5%20X%20%E7%A0%81%E4%B8%8A%E6%8E%98%E9%87%91%E3%80%8D%E4%B8%BB%E9%A2%98%201%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E5%90%8D%E7%89%87/"/>
      <url>/2023/01/28/%E3%80%8C%E9%9D%92%E8%AE%AD%E8%90%A5%20X%20%E7%A0%81%E4%B8%8A%E6%8E%98%E9%87%91%E3%80%8D%E4%B8%BB%E9%A2%98%201%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E5%90%8D%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p><strong>当青训营遇上码上掘金</strong></p><h2 id="主题介绍"><a href="#主题介绍" class="headerlink" title="主题介绍"></a>主题介绍</h2><ul><li><h4 id="主题-1：我的名片"><a href="#主题-1：我的名片" class="headerlink" title="主题 1：我的名片"></a>主题 1：我的名片</h4>名片是向人介绍自我的重要工具，作为一名程序员用代码做自我介绍是一件非常酷炫的事情。请大家围绕“我的名片”这个主题进行代码创作。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然说整个酷炫的</p><p>直接上框架</p><p><a href="https://github.com/antfu/vitesse-webext">https://github.com/antfu/vitesse-webext</a></p><p>这个模板是基于Vue的webext（浏览器插件手脚架）</p><p>webext是一个可以帮助构建、运行和测试Web扩展的命令行工具。</p><p><a href="https://wiki.mozilla.org/WebExtensions">https://wiki.mozilla.org/WebExtensions</a></p><p>webext的目标是以一种标准的、可移植、跨平台的方式支持浏览器扩展。最初，它将为开发火狐扩展提供一个简化的体验。</p><p>我们的目标是实现一个浏览器扩展类型的名片</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>⚡️ Vite 快速构建</li><li>🥝 Vue 3 -组合式api 3.2+setup语法</li><li>💬<a href="https://github.com/antfu/webext-bridge"><code>webext-bridge</code></a> 的local storage 和 <a href="https://github.com/antfu/vueuse">VueUse</a> 的使用结合</li><li>🌈 <a href="https://github.com/unocss/unocss">UnoCSS</a> - 原子化CSS引擎</li><li>🦾 <a href="https://www.typescriptlang.org/">TypeScript</a> 语法支持</li><li>📦 <a href="https://github.com/antfu/vitesse-webext/blob/main/src/components">Components auto importing</a> 自动引入</li><li>🌍 WebExtension - 标准浏览器扩展手脚架 可以一键生成chromium、Firefox适配的扩展</li><li>😴 mv3 - manifest v3</li></ul><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>本身这个项目没什么坑的、只是</p><p>😡</p><p>浏览器在2023年抛弃manifest v2</p><p>所以使用manifest v2打包后的浏览器扩展浏览器不认</p><p>会显示</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128210235.png"></p><p>😱</p><p>还有一点就是本身不太会CSS</p><p>调CSS花了很长时间</p><p>但是unocss还是很方便的</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="vue">&lt;script setup&gt;import &#123; useImage &#125; from &#39;@vueuse/core&#39;const avatarUrl = &#39;https://s1.ax1x.com/2023/01/23/pSYuIYD.png&#39;const waka = &#39;https://wakatime.com/badge/user/84476697-3421-4720-bcdc-efb5c0fbc1b8.svg?style=flat-square&#39;const kita = &#39;https://www.z4a.net/images/2023/01/28/kita.gif&#39;const &#123; isLoading &#125; = useImage(&#123; src: avatarUrl &#125;)const &#123; isLoading_waka &#125; = useImage(&#123; src: waka &#125;)const &#123; isLoading_kita &#125; = useImage(&#123; src: kita &#125;)const to_left = () =&gt; &#123;  document.getElementsByClassName(&#39;img&#39;)[0].classList.remove(&#39;to_right&#39;)  document.getElementsByClassName(&#39;right_text&#39;)[0].classList.remove(&#39;to_right_text&#39;)  document.getElementsByClassName(&#39;right_block&#39;)[0].classList.remove(&#39;to_right_block&#39;)  document.getElementsByClassName(&#39;left_block&#39;)[0].classList.remove(&#39;to_left_block&#39;)  document.getElementsByClassName(&#39;left_img&#39;)[0].classList.remove(&#39;to_left_img&#39;)&#125;const to_right = () =&gt; &#123;  document.getElementsByClassName(&#39;img&#39;)[0].classList.add(&#39;to_right&#39;)  document.getElementsByClassName(&#39;right_text&#39;)[0].classList.add(&#39;to_right_text&#39;)  document.getElementsByClassName(&#39;right_block&#39;)[0].classList.add(&#39;to_right_block&#39;)  document.getElementsByClassName(&#39;left_block&#39;)[0].classList.add(&#39;to_left_block&#39;)  document.getElementsByClassName(&#39;left_img&#39;)[0].classList.add(&#39;to_left_img&#39;)&#125;&lt;/script&gt;&lt;template&gt;  &lt;main class=&quot;w-[384px] h-[256px] text-center text-light-700 bg-[#f69db2] font-sans&quot;&gt;    &lt;div class=&quot;h-100% w-100% flex flex-row justify-between p-5 items-center gap-5&quot;&gt;      &lt;div class=&quot;absolute left-0 top-0 translate-x-[-100%]&quot;&gt;        &lt;div class=&quot;flex flex-col justify-end left_block duration-700 &quot;&gt;          &lt;div class=&quot;bg-[#60c5e7] p-5&quot; /&gt;          &lt;div class=&quot;bg-[#f3d263] p-5&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;absolute left-0 top-0 translate-x-[-100%]&quot;&gt;        &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-11.5 py-16 text-center font-black&quot;&gt;Loading&lt;/span&gt;        &lt;img v-else :src=&quot;kita&quot; class=&quot;left_img duration-400&quot;&gt;      &lt;/div&gt;      &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-11.5 py-16 text-center font-black&quot;&gt;Loading&lt;/span&gt;      &lt;img v-else :src=&quot;avatarUrl&quot; class=&quot;w-35 h-35 img duration-700&quot;&gt;      &lt;div class=&quot;flex flex-col gap-5 h-119%&quot;&gt;        &lt;div class=&quot;flex flex-row justify-end translate-x-4.9 right_block duration-700 &quot;&gt;          &lt;div class=&quot;bg-[#60c5e7] p-5&quot; /&gt;          &lt;div class=&quot;bg-[#f3d263] p-5&quot; /&gt;        &lt;/div&gt;        &lt;div class=&quot;flex flex-col gap-5 pt-8 right_text duration-700 &quot;&gt;          &lt;div class=&quot;text-center font-bold text-lg text-[#df4b57]&quot;&gt;            👋  Hi, I’m  @camera-2018          &lt;/div&gt;          &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-15 text-center font-black&quot;&gt;Loading&lt;/span&gt;          &lt;a v-else href=&quot;https://wakatime.com/@84476697-3421-4720-bcdc-efb5c0fbc1b8&quot;&gt;&lt;img :src=&quot;waka&quot; alt=&quot;Total time coded since May 9 2022&quot;&gt;&lt;/a&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;footer class=&quot;bg-[#f69db2] &quot;&gt;      &lt;button class=&quot;i-carbon-caret-left hover:bg-[#1DCED1] bg-light-50&quot; @click=&quot;to_left&quot; /&gt;      &lt;button class=&quot;i-carbon-caret-right hover:bg-[#1DCED1] bg-light-50&quot; @click=&quot;to_right&quot; /&gt;    &lt;/footer&gt;  &lt;/main&gt;&lt;/template&gt;&lt;style&gt;.to_right&#123;  @apply translate-x-142% transition&#125;.to_right_text &#123;  @apply translate-x-190% transition&#125;.to_right_block &#123;  @apply translate-y-[-120%] transition&#125;.to_left_block &#123;  @apply translate-x-100% transition&#125;.to_left_img &#123;  @apply translate-x-90% transition&#125;&lt;/style&gt;</code></pre><p>主要的代码就这么多</p><h3 id="大概思路是"><a href="#大概思路是" class="headerlink" title="大概思路是"></a>大概思路是</h3><ol><li><p>通过unocss的预设添加使用@apply的样式</p></li><li><p>再通过js添加样式到元素上</p></li><li><p>使用过渡效果 添加过渡时间</p></li><li><p>图片加载部分使用vueuse的useImage 没加载出来之前是有个loading的界面</p></li><li><p>使用了一个wakatime的svg展示最近敲代码时间点击可看</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/GIF%202023-1-28%2020-45-47.gif"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128213920.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128214002.png"></p><h2 id="灵感"><a href="#灵感" class="headerlink" title="灵感"></a>灵感</h2><p><a href="https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C">https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C</a></p><p>复刻了孤独摇滚 后藤一里 的配色 右上角或左上角的方块为波奇酱的发饰</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>代码开源于</p><p><a href="https://github.com/camera-2018/business-card-mv3">https://github.com/camera-2018/business-card-mv3</a></p><p>可以在<a href="https://github.com/camera-2018/business-card-mv3/releases">Releases</a>中下载编译好的扩展 解压然后点击浏览器的扩展程序选项卡 <code>chrome://extensions/</code></p><p>记得要开右上角的开发者模式哦</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128212633.png"></p><p>然后加载已解压的扩展程序就可以了</p><h2 id="popup部分代码"><a href="#popup部分代码" class="headerlink" title="popup部分代码"></a>popup部分代码</h2><p><a href="https://github.com/camera-2018/business-card-mv3/tree/refactor/mv3/src/popup">popup</a>部分代码放在码上掘金上</p><p><a href="https://code.juejin.cn/api/raw/7193666089241772090?id=7193666089241821242">https://code.juejin.cn/api/raw/7193666089241772090?id=7193666089241821242</a></p><p>由于依赖比较多，而码上掘金拉不到cdnjsdelivr的数据</p><p>所以在码上掘金上是无法正常显示的😥 想试试的话请去<a href="https://github.com/camera-2018/business-card-mv3%E6%BA%90%E7%A0%81">https://github.com/camera-2018/business-card-mv3源码</a></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128213154.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://code.juejin.cn/pen/7193666089241772090">https://code.juejin.cn/pen/7193666089241772090</a></p><p><a href="https://juejin.cn/post/7187753682421678137">https://juejin.cn/post/7187753682421678137</a></p><p><a href="https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C">https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C</a></p><p><a href="https://github.com/antfu/vitesse-webext">https://github.com/antfu/vitesse-webext</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt3与服务端渲染SSR（下） ｜ 青训营笔记</title>
      <link href="/2023/01/28/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8B%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/2023/01/28/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8B%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 12 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章介绍了大概一半的nuxt3特性，这一篇会介绍另外一半</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>Nuxt利用Vue的 <a href="https://vuejs.org/guide/built-ins/transition.html#the-transition-component"><code>&lt;Transition&gt;</code></a>组件来应用页面和布局之间的转换。</p><p>只需要在nuxt config里设置</p><pre><code class="js">export default defineNuxtConfig(&#123;  app: &#123;    pageTransition: &#123; name: &#39;page&#39;, mode: &#39;out-in&#39; &#125;  &#125;,&#125;)</code></pre><p>然后在<code>app.vue</code>里设置你想要的过渡动画</p><pre><code class="vue">&lt;template&gt;  &lt;NuxtPage /&gt;&lt;/template&gt;&lt;style&gt;.page-enter-active,.page-leave-active &#123;  transition: all 0.4s;&#125;.page-enter-from,.page-leave-to &#123;  opacity: 0;  filter: blur(1rem);&#125;&lt;/style&gt;</code></pre><p>类名必须是这几个</p><p>就可以实现一个切换页面有虚化效果的动画</p><p>更高级的用法详见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/transitions">https://nuxt.com/docs/getting-started/transitions</a></p><h2 id="使用Api获取数据"><a href="#使用Api获取数据" class="headerlink" title="使用Api获取数据"></a>使用Api获取数据</h2><p>nuxt3自带一个<code>vueuse</code>里的 <code>useFetch</code> api</p><p>使用方法为</p><pre><code>&lt;script setup&gt;const &#123; data: count &#125; = await useFetch(&#39;/api/count&#39;)&lt;/script&gt;&lt;template&gt;  Page visits: &#123;&#123; count &#125;&#125;&lt;/template&gt;</code></pre><p>可以使用<code>useAsyncData</code>来异步获取数据</p><pre><code>&lt;script setup&gt;const &#123; data &#125; = await useAsyncData(&#39;count&#39;, () =&gt; $fetch(&#39;/api/count&#39;))&lt;/script&gt;&lt;template&gt;  Page visits: &#123;&#123; data &#125;&#125;&lt;/template&gt;</code></pre><p>更高级的用法详见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/data-fetching">https://nuxt.com/docs/getting-started/data-fetching</a></p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>nuxt3提供了<code>vueuse</code>的一个api叫<code>useState</code>来实现全局状态管理</p><p>无需创建state文件</p><p>直接使用</p><pre><code>&lt;script setup&gt;const counter = useState(&#39;counter&#39;, () =&gt; Math.round(Math.random() * 1000))&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    Counter: &#123;&#123; counter &#125;&#125;    &lt;button @click=&quot;counter++&quot;&gt;      +    &lt;/button&gt;    &lt;button @click=&quot;counter--&quot;&gt;      -    &lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>这个例子创建了一个state叫counter 里面默认记录了一个随机数</p><p>点击按钮会让随机数进行加减</p><p><code>useState</code>默认为响应式 很方便</p><p>nuxt3的auto import特性可以使state简写为</p><pre><code>const counter = useCounter() // Same as useState(&#39;counter&#39;)</code></pre><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>nuxt提供了很多高级的错误处理方式</p><p>一个最简单的api是<code>useError</code></p><pre><code>const error = useError()</code></pre><p>这句代码可以快速的抛出一条错误</p><p>也可以使用<code>createError</code>方法</p><pre><code>&lt;script setup&gt;const route = useRoute()const &#123; data &#125; = await useFetch(`/api/movies/$&#123;route.params.slug&#125;`)if (!data.value) &#123;  throw createError(&#123; statusCode: 404, statusMessage: &#39;Page Not Found&#39; &#125;)&#125;&lt;/script&gt;</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>正常的使用<code>nuxt build</code>命令会生成一个在node环境中运行的运行时</p><p><code>.mjs文件</code></p><pre><code class="sh">node .output/server/index.mjs</code></pre><p>即可运行</p><pre><code class="bash">$ node .output/server/index.mjsListening on http://localhost:3000</code></pre><p>可以设置环境变量例如</p><pre><code>PORT=3001 node .output/server/index.mjs</code></pre><p>在3001端口运行</p><p>在 <code>nuxt.config</code> 里添加</p><pre><code>export default &#123;  nitro: &#123;    preset: &#39;node-server&#39;  &#125;&#125;</code></pre><p>或者<code>NITRO_PRESET=node-server nuxt build</code></p><p>preset字段可以更改生成的代码的依赖平台</p><p>支持的平台有</p><ul><li><a href="https://nitro.unjs.io/deploy/providers/aws">AWS</a></li><li><a href="https://nitro.unjs.io/deploy/providers/azure">Azure</a></li><li><a href="https://nitro.unjs.io/deploy/providers/cleavr">Cleavr</a></li><li><a href="https://nitro.unjs.io/deploy/providers/cloudflare">CloudFlare</a></li><li><a href="https://nitro.unjs.io/deploy/providers/digitalocean">Digital Ocean</a></li><li><a href="https://nitro.unjs.io/deploy/providers/firebase">Firebase</a></li><li><a href="https://nitro.unjs.io/deploy/providers/heroku">heroku</a></li><li><a href="https://nitro.unjs.io/deploy/providers/edgio">Edgio</a></li><li><a href="https://nitro.unjs.io/deploy/providers/netlify">Netlify</a></li><li><a href="https://nitro.unjs.io/deploy/providers/render">Render</a></li><li><a href="https://nitro.unjs.io/deploy/providers/stormkit">Stormkit</a></li><li><a href="https://nitro.unjs.io/deploy/providers/vercel">Vercel</a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>可以添加vitest库来进行测试</p><pre><code>yarn add --dev @nuxt/test-utils vitest</code></pre><p>方法如下</p><p>新建test目录 创建文件 <code>demo.test.ts</code></p><pre><code class="ts">import &#123; describe, test &#125; from &#39;vitest&#39;import &#123; setup, $fetch &#125; from &#39;@nuxt/test-utils&#39;describe(&#39;My test&#39;, async () =&gt; &#123;  await setup(&#123;    // test context options  &#125;)  test(&#39;my test&#39;, () =&gt; &#123;    // ...  &#125;)&#125;)</code></pre><p>运行vitest即可获得通过或不通过提示</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到这里nuxt3基础就几乎结束了</p><p>还有一些更高级的用法没有讲，例如生命周期啊，nuxt-kit啊，自动导入啊</p><p>有机会可以写一篇高级教程</p><p>😋😎</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/docs/getting-started/state-management">https://nuxt.com/docs/getting-started/state-management</a></p><p><a href="https://nuxt.com/docs/api/composables/use-state">https://nuxt.com/docs/api/composables/use-state</a></p><p><a href="https://juejin.cn/post/7193305766692913189">https://juejin.cn/post/7193305766692913189</a></p><p><a href="https://vueuse.org/">https://vueuse.org/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt3与服务端渲染SSR（上） ｜ 青训营笔记</title>
      <link href="/2023/01/27/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8A%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/27/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8A%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 11 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nuxt同时提供了前端和后端功能，因此您可以专注于重要的事情：创建web应用程序。</p><p><a href="https://nuxt.com/docs">Nuxt3</a> 是基于 <code>Vite</code>、<code>Vue3</code> 和 <code>Nitro</code> 的 <code>Nuxt</code> 框架的重构，具有一流的 <code>Typescript</code> 支持，且这次更新对内核进行了精简，使之速度更快，体验更好。</p><h2 id="了解-SSR"><a href="#了解-SSR" class="headerlink" title="了解 SSR"></a>了解 <code>SSR</code></h2><p><code>Nuxt</code> 是一个基于 <code>Vue.js</code> 的服务端渲染应用框架</p><h3 id="什么是-SSR"><a href="#什么是-SSR" class="headerlink" title="什么是 SSR"></a>什么是 <code>SSR</code></h3><p><code>服务器端渲染</code>（Server-Side Rendering）是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p><p>简单理解就是html是由服务端写出，可以动态改变页面内容，即所谓的动态页面。早年的 php 、 asp 、 jsp  这些 Server page 都是 SSR 的。</p><h3 id="为什么使用-SSR"><a href="#为什么使用-SSR" class="headerlink" title="为什么使用 SSR"></a>为什么使用 <code>SSR</code></h3><ul><li>网页内容在服务器端渲染完成，一次性传输到浏览器，所以 <code>首屏加载速度非常快</code>；</li><li><code>有利于SEO</code>，因为服务器返回的是一个完整的 html，在浏览器可以看到完整的 dom，对于爬虫、百度搜索等引擎就比较友好；</li></ul><h2 id="Nuxt-3"><a href="#Nuxt-3" class="headerlink" title="Nuxt 3"></a>Nuxt 3</h2><p><code>Nuxt</code> 是一个基于 <code>Vue.js</code> 的服务端渲染应用框架，</p><p>刚去查了一下 nuxt3在1月23日变成了默认版本</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003129.png"></p><p>在1月25日发布了3.1.0版本</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127185726.png"></p><ul><li><p>实验组件群岛 准备就绪</p></li><li><p>新的api</p></li><li><p>Nitro v2 ，vite 4 ，rollup3</p></li><li><p>性能改进</p></li></ul><h2 id="什么是Nuxt？"><a href="#什么是Nuxt？" class="headerlink" title="什么是Nuxt？"></a>什么是Nuxt？</h2><p>要理解Nuxt是什么，我们需要了解创建一个现代应用程序需要什么：</p><ul><li>JavaScript框架： 一个带来JavaScript组件的JavaScript框架，支持Vue.js。</li><li>打包工具：支持开发中的热模块替换和生产代码，支持webpack 5和Vite。</li><li>最新JavaScript语法：在支持遗留浏览器的同时编写最新的JavaScript语法的转换器，支持esbuild。</li><li>服务器端：Nuxt是一个在开发中服务于应用程序的服务器，同时也支持服务器端呈现或API路由，它使用h3进行部署的多功能性，如serverless, workers, Node.js和无与伦比的性能。</li><li>路由：一个处理客户端导航的路由库，支持 <a href="https://router.vuejs.org/">vue-router</a>.。</li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p><a href="https://nuxt.com/docs/getting-started/installation#prerequisites">https://nuxt.com/docs/getting-started/installation#prerequisites</a></p><pre><code class="bash">pnpm dlx nuxi init &lt;project-name&gt;</code></pre><pre><code class="bash">code &lt;project-name&gt;</code></pre><pre><code class="bash"># Make sure you have `shamefully-hoist=true` in `.npmrc` before running pnpm installpnpm install</code></pre><p><strong>注意：</strong> 如果你用 <code>pnpm</code> 安装依赖，请创建一个 <code>.npmrc</code> 文件，且设置:</p><pre><code class="ini">shamefully-hoist=true</code></pre><p>安装完成😋</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code class="bash">pnpm dev -o</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127193306.png"></p><p>看一眼文件树</p><p>抛开编译结果<code>.nuxt</code>文件夹不谈 就只有一个<code>app.vue</code> 和<code>nuxt.config.ts</code></p><p>很简陋 怎么会这样呢？我们一般写的vue框架也不是这样的啊</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127193603.png"></p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>创建 <code>components/</code> <code>pages/</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127200417.png"></p><p>具体操作见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/views">https://nuxt.com/docs/getting-started/views</a></p><p>也可以新建<code>src</code>目录 把 <code>components/</code> <code>pages/</code>目录放到<code>src</code>里</p><p>在nuxt里组件是自动导入的，不用配置</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>路由是自动创建的</p><pre><code class="html">&lt;NuxtLink to=&quot;/about&quot;&gt;About&lt;/NuxtLink&gt;</code></pre><p>以上的代码点击会自动跳到<code>page/about.vue</code></p><p>也可以使用路由</p><pre><code class="vue">&lt;script setup&gt;const route = useRoute()// When accessing /posts/1, route.params.id will be 1console.log(route.params.id)&lt;/script&gt;</code></pre><p><code>/posts/1</code>是创建的<code>/posts/[id].vue</code>这样id会被当做props传入</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>nuxt服务端渲染最重要的就是搜索引擎优化</p><p>可以被拉取到带内容的html</p><p>而不是一般vue项目的空html</p><pre><code class="js">export default defineNuxtConfig(&#123;  app: &#123;    head: &#123;      charset: &#39;utf-16&#39;,      viewport: &#39;width=500, initial-scale=1&#39;,      title: &#39;My App&#39;,      meta: [        // &lt;meta name=&quot;description&quot; content=&quot;My amazing site&quot;&gt;        &#123; name: &#39;description&#39;, content: &#39;My amazing site.&#39; &#125;      ],    &#125;  &#125;&#125;)</code></pre><p>在<code>nuxt.config.ts</code>配置如上内容</p><p>或者在<code>app.vue</code>里添加</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;useHead(&#123;  title: &#39;My App&#39;,  meta: [    &#123; name: &#39;description&#39;, content: &#39;My amazing site.&#39; &#125;  ],  bodyAttrs: &#123;    class: &#39;test&#39;  &#125;,  script: [ &#123; children: &#39;console.log(\&#39;Hello world\&#39;)&#39; &#125; ]&#125;)useServerSeoMeta(&#123;  title: &#39;My Amazing Site&#39;,  ogTitle: &#39;My Amazing Site&#39;,  description: &#39;This is my amazing site, let me tell you all about it.&#39;,  ogDescription: &#39;This is my amazing site, let me tell you all about it.&#39;,  ogImage: &#39;https://example.com/image.png&#39;,  twitterCard: &#39;summary_large_image&#39;,&#125;)&lt;/script&gt;</code></pre><p>这几个函数可以添加meta头</p><p>还有一些设置可以看官方文档 <a href="https://nuxt.com/docs/getting-started/seo-meta">https://nuxt.com/docs/getting-started/seo-meta</a></p><p>也可以使用 <a href="https://nuxt.com/modules/seo-kit">https://nuxt.com/modules/seo-kit</a></p><p>这个模块来配置SEO</p><p>很方便😎</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇文章介绍了大概一半的nuxt3特性，下一篇会介绍另外一半</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><p>😎</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/modules/seo-kit">https://nuxt.com/modules/seo-kit</a></p><p><a href="https://nuxt.com/docs/getting-started/seo-meta">https://nuxt.com/docs/getting-started/seo-meta</a></p><p><a href="https://nuxt.com/docs/getting-started/views">https://nuxt.com/docs/getting-started/views</a></p><p><a href="https://nuxt.com/docs">https://nuxt.com/docs</a></p><p><a href="https://juejin.cn/post/7170746000112353293">https://juejin.cn/post/7170746000112353293</a></p><p><a href="https://juejin.cn/post/7037336504418435103">https://juejin.cn/post/7037336504418435103</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnoCSS实战 ｜ 青训营笔记</title>
      <link href="/2023/01/26/UnoCSS%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/26/UnoCSS%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 10 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原子化css体验</p><p><a href="https://link.juejin.cn/?target=https://antfu.me/posts/reimagine-atomic-css-zh">重新构想原子化 CSS (antfu.me)</a></p><p>本篇介绍一下如何配置UnoCSS、UnoCSS怎么使用</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先创建一个vite模板   <a href="https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project">https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project</a></p><p>这里使用pnpm</p><pre><code class="bash">pnpm create vite</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126210343.png"></p><p>选择vue、typescript</p><pre><code class="bash">cd vite-projectpnpm installpnpm run dev</code></pre><p>运行一下</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126210518.png"></p><p>初始化成功了，接下来安装unocss  <a href="https://github.com/unocss/unocss/tree/main/packages/vite">https://github.com/unocss/unocss/tree/main/packages/vite</a></p><p>使用文档给的vite安装方式</p><pre><code class="bash">pnpm i -D unocss</code></pre><p>在vite config里写上</p><pre><code class="ts">// vite.config.tsimport UnoCSS from &#39;unocss/vite&#39;export default &#123;  plugins: [    UnoCSS(&#123; /* options */ &#125;),  ],&#125;</code></pre><p>配置完全的vite config是这样的</p><pre><code class="ts">// vite.config.tsimport &#123; defineConfig &#125; from &#39;vite&#39;import vue from &#39;@vitejs/plugin-vue&#39;import UnoCSS from &#39;unocss/vite&#39;import &#123; presetUno &#125; from &#39;unocss&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    UnoCSS(&#123;      presets: [        presetUno(),      ],    &#125;),  ],&#125;)</code></pre><p>然后在<code>main.ts</code>里加入</p><pre><code class="ts">// main.tsimport &#39;uno.css&#39;</code></pre><p>这里没有eslint还是很不舒服的，推荐一个antfu的eslint配置，来安装一下eslint</p><p><a href="https://github.com/antfu/eslint-config">https://github.com/antfu/eslint-config</a></p><pre><code class="bash">pnpm add -D eslint @antfu/eslint-config</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126211558.png"></p><p>创建<code>.eslintrc</code>写入</p><pre><code>&#123;  &quot;extends&quot;: &quot;@antfu&quot;&#125;</code></pre><p>在package json里加入</p><pre><code class="json">&#123;  &quot;scripts&quot;: &#123;    &quot;lint&quot;: &quot;eslint .&quot;,    &quot;lint:fix&quot;: &quot;eslint . --fix&quot;  &#125;&#125;</code></pre><p>如果你使用的是VSCode 下载 <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">VS Code ESLint extension</a> 然后编辑 <code>.vscode/settings.json</code></p><pre><code class="json">&#123;  &quot;prettier.enable&quot;: false,  &quot;editor.formatOnSave&quot;: false,  &quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true  &#125;&#125;</code></pre><p>之后重启vscode</p><p>安装完成😎</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们来写一个小demo</p><p>就把原本的默认界面改成unocss好了</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126212340.png"></p><p>先看app.vue</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;/vite.svg&quot; class=&quot;logo&quot; alt=&quot;Vite logo&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;logo vue&quot; alt=&quot;Vue logo&quot;&gt;    &lt;/a&gt;  &lt;/div&gt;  &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;.logo &#123;  height: 6em;  padding: 1.5em;  will-change: filter;&#125;.logo:hover &#123;  filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123;  filter: drop-shadow(0 0 2em #42b883aa);&#125;&lt;/style&gt;</code></pre><p>改成原子化css的形式</p><p>这里最好先配置一下vite config 多加一点预设</p><pre><code class="ts">// vite.config.tsimport &#123; defineConfig &#125; from &#39;vite&#39;import vue from &#39;@vitejs/plugin-vue&#39;import UnoCSS from &#39;unocss/vite&#39;import &#123; presetAttributify, presetIcons, presetTypography, presetUno, presetWebFonts, transformerDirectives, transformerVariantGroup &#125; from &#39;unocss&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    UnoCSS(      &#123;        presets: [          presetUno(),          presetAttributify(),          presetIcons(&#123;            scale: 1.2,          &#125;),          presetTypography(),          presetWebFonts(&#123;            fonts: &#123;              sans: &#39;DM Sans&#39;,              serif: &#39;DM Serif Display&#39;,              mono: &#39;DM Mono&#39;,            &#125;,          &#125;),        ],        transformers: [          transformerDirectives(),          transformerVariantGroup(),        ],      &#125;,    ),  ],&#125;)</code></pre><p>我们先用@apply将css改一下 <code>&lt;style scoped&gt;</code></p><pre><code class="css">.logo &#123;  height: 6em;  padding: 1.5em;  will-change: filter;&#125;.logo:hover &#123;  filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123;  filter: drop-shadow(0 0 2em #42b883aa);&#125;</code></pre><p>这里不会的语法可以看tailwindcss文档</p><p>改成</p><pre><code class="css">.logo &#123;  @apply h-6em p-1.5em&#125;.logo &#123;  @apply hover:drop-shadow-[0_0_2em_#646cffaa]&#125;.logo.vue &#123;  @apply hover:drop-shadow-[0_0_2em_#42b883aa]&#125;</code></pre><p>怎么样？是不是感觉很清晰明了</p><p>这是在tailwindcss里很受欢迎的@apply命令 通过预设导入了unocss</p><p>但是这样体现不出原子化css的方便，虽然非常好看</p><p>我们把css写入html</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;/vite.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#646cffaa]&quot; alt=&quot;Vite logo&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;hover:drop-shadow-[0_0_2em_#42b883aa]&quot; alt=&quot;Vue logo&quot;&gt;    &lt;/a&gt;  &lt;/div&gt;  &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>这样写就很方便了</p><p>再看<code>HelloWorld.vue</code></p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;card&quot;&gt;    &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;count is &#123;&#123; count &#125;&#125;&lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot;      &gt;create-vue&lt;/a    &gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;read-the-docs&quot;&gt;Click on the Vite and Vue logos to learn more&lt;/p&gt;&lt;/template&gt;&lt;style scoped&gt;.read-the-docs &#123;  color: #888;&#125;&lt;/style&gt;</code></pre><p>这个改的比较少</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;card&quot;&gt;    &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;      count is &#123;&#123; count &#125;&#125;    &lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot;&gt;create-vue&lt;/a&gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;text-[#888]&quot;&gt;    Click on the Vite and Vue logos to learn more  &lt;/p&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>改成这样就行</p><p>再看<code>style.css</code>文件 内容比较多</p><pre><code class="css">:root &#123;  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;  font-size: 16px;  line-height: 24px;  font-weight: 400;  color-scheme: light dark;  color: rgba(255, 255, 255, 0.87);  background-color: #242424;  font-synthesis: none;  text-rendering: optimizeLegibility;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  -webkit-text-size-adjust: 100%;&#125;a &#123;  font-weight: 500;  color: #646cff;  text-decoration: inherit;&#125;a:hover &#123;  color: #535bf2;&#125;body &#123;  margin: 0;  display: flex;  place-items: center;  min-width: 320px;  min-height: 100vh;&#125;h1 &#123;  font-size: 3.2em;  line-height: 1.1;&#125;button &#123;  border-radius: 8px;  border: 1px solid transparent;  padding: 0.6em 1.2em;  font-size: 1em;  font-weight: 500;  font-family: inherit;  background-color: #1a1a1a;  cursor: pointer;  transition: border-color 0.25s;&#125;button:hover &#123;  border-color: #646cff;&#125;button:focus,button:focus-visible &#123;  outline: 4px auto -webkit-focus-ring-color;&#125;.card &#123;  padding: 2em;&#125;#app &#123;  max-width: 1280px;  margin: 0 auto;  padding: 2rem;  text-align: center;&#125;@media (prefers-color-scheme: light) &#123;  :root &#123;    color: #213547;    background-color: #ffffff;  &#125;  a:hover &#123;    color: #747bff;  &#125;  button &#123;    background-color: #f9f9f9;  &#125;&#125;</code></pre><p>一点点儿改</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126221543.png"></p><p>最后改成了这样 还挺还原的是不是</p><p>有一些媒体查询不会改</p><p>根元素没改</p><p>代码如下</p><pre><code class="css">// style.css:root &#123;  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;  font-size: 16px;  line-height: 24px;  font-weight: 400;  color-scheme: light dark;  color: rgba(255, 255, 255, 0.87);  background-color: #242424;  font-synthesis: none;  text-rendering: optimizeLegibility;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  -webkit-text-size-adjust: 100%;&#125;@media (prefers-color-scheme: light) &#123;  :root &#123;    color: #213547;    background-color: #ffffff;  &#125;  a:hover &#123;    color: #747bff;  &#125;  button &#123;    background-color: #f9f9f9;  &#125;&#125;</code></pre><pre><code class="vue">// HelloWorld.vue&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1 class=&quot;text-3.2em leading-tight&quot;&gt;    &#123;&#123; msg &#125;&#125;  &lt;/h1&gt;  &lt;div class=&quot;p-2em flex flex-col place-items-center&quot;&gt;    &lt;button      type=&quot;button&quot; class=&quot;      rounded-8px border-1px border-solid border-transparent      py-0.6em px-1.2em text-1em font-medium      bg-[#1a1a1a] cursor-pointer transition duration-250      hover:border-color-[#646cff]      focus:outline-4 focus:outline-[-webkit-focus-ring-color]      focus-visible:outline-4 focus-visible:outline-[-webkit-focus-ring-color]    &quot; @click=&quot;count++&quot;    &gt;      count is &#123;&#123; count &#125;&#125;    &lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;create-vue&lt;/a&gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;text-[#888]&quot;&gt;    Click on the Vite and Vue logos to learn more  &lt;/p&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code class="vue">// App.vue&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;m-0 flex flex-col place-items-center min-w-320px min-h-100vh&quot;&gt;    &lt;div class=&quot;max-w-1280px my-0 mx-auto p-2rem text-center&quot;&gt;      &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;        &lt;img src=&quot;/vite.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#646cffaa]&quot; alt=&quot;Vite logo&quot;&gt;      &lt;/a&gt;      &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;        &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#42b883aa]&quot; alt=&quot;Vue logo&quot;&gt;      &lt;/a&gt;    &lt;/div&gt;    &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>可以看出来虽然写的简单，但是还是比较乱</p><p>这样写的好处是，不用想类名，</p><p>如果加了@apply会更美观，但是还是要写类名，和普通css的区别就是简单了一些</p><p>同时还有一些自带的样式预设</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇我们介绍了UnoCSS的特点，UnoCSS的使用，还是改了挺长时间的，主要是不会写语法，要查tailwind文档 <a href="https://tailwindcss.com/docs">https://tailwindcss.com/docs</a></p><p>还有一些好几个值的css 不知道什么意思</p><pre><code class="css">outline: green solid 3px;/* mdn:颜色 | 样式 | 宽度 */</code></pre><pre><code class="css">outline: 4px auto -webkit-focus-ring-color;/* style.css */</code></pre><p>关于这种就不知道怎么写</p><p>最后只能掰成</p><pre><code>focus:outline-4 focus:outline-[-webkit-focus-ring-color]</code></pre><p>题外话：</p><blockquote><p>Anthony Fu大佬真的是我目前的偶像，狂热的开源爱好者，人长得又帅，做的东西又好</p></blockquote><p>🤣这是我在掘金搜unocss搜到的一篇文章中的第一句话 文章在这 <a href="https://juejin.cn/post/7028841960752283656">https://juejin.cn/post/7028841960752283656</a></p><p>antfu大佬确实也是我的偶像</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125225032.png"></p><p>22年秋季 antfu大佬在b站办过几场直播写代码，我基本上是每期必看，这个人非常有意思，有很多新鲜的点子，狠活也多 比如说</p><p><a href="https://github.com/antfu/1990-script">https://github.com/antfu/1990-script</a> 这个仓库教你怎么把GitHub历史穿越回1990年🤭</p><p>他的每个star比较多的仓库我都体验过，感觉设计灵感真的让人眼前一亮，启发基于社区，创造更快的轮子，更好玩的轮子</p><p><a href="https://github.com/antfu/retypewriter">https://github.com/antfu/retypewriter</a> 这个是直播写的雏形 让写的代码在vsc里回放，便于理清思路</p><p><a href="https://github.com/antfu/vue-minesweeper">https://github.com/antfu/vue-minesweeper</a> 这个是首次直播写的扫雷，很清晰的vue代码，看他写真的开窍</p><p><a href="https://github.com/antfu/vue-starport">https://github.com/antfu/vue-starport</a> 这个也是直播写的雏形，为了使组件有更好的过渡</p><p>就说这么多，人也长得帅</p><p>🥰😘</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">https://developer.mozilla.org/zh-CN/docs/Web/CSS</a></p><p><a href="https://tailwindcss.com/docs">https://tailwindcss.com/docs</a></p><p><a href="https://www.tailwindcss.cn/docs/functions-and-directives#apply">https://www.tailwindcss.cn/docs/functions-and-directives#apply</a></p><p><a href="https://github.com/unocss/unocss">https://github.com/unocss/unocss</a></p><p><a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子化CSS｜ 青训营笔记</title>
      <link href="/2023/01/25/%E5%8E%9F%E5%AD%90%E5%8C%96CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/25/%E5%8E%9F%E5%AD%90%E5%8C%96CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 9 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原子化 CSS是一个很新颖的定义 出自<a href="https://css-tricks.com/lets-define-exactly-atomic-CSS/">https://CSS-tricks.com/lets-define-exactly-atomic-CSS/</a></p><p>意思是<code>原子化 CSS是一种 CSS的架构方式，它倾向于小巧且用途单一的 class，并且会以视觉效果进行命名。</code></p><h2 id="什么是原子化-CSS"><a href="#什么是原子化-CSS" class="headerlink" title="什么是原子化 CSS?"></a>什么是原子化 CSS?</h2><p>与一般的我们写正常CSS不同，原子化CSS会把元素本身的属性提取出来，加以视觉效果命名，例如：</p><p>如下的html</p><pre><code class="html">&lt;button class=&quot;btn&quot;&gt;Basic&lt;/button&gt;</code></pre><p>正常的CSS</p><pre><code class="css">.btn &#123;    padding: 1rem, 2rem;    font-family: &#39;semi&#39;;    font-weight: bold; &#125;</code></pre><p>使用原子化CSS后，将不用写CSS文件，改为写class属性</p><pre><code class="html">&lt;button class=&quot;py-2 px-4 font-semibold rounded-lg shadow-md text-white bg-green-500 hover:bg-green-700&quot;&gt;  Click me&lt;/button&gt;</code></pre><p>市面上有不少实用至上的 CSS框架，如 <a href="https://tailwindcss.com/">Tailwind CSS</a>，<a href="https://cn.windicss.org/">Windi CSS</a> 以及 <a href="https://tachyons.io/">Tachyons</a> 等。</p><p>同时有些 UI 库也会附带一些 CSS工具类作为框架的补充，如 <a href="https://getbootstrap.com/docs/5.1/utilities/api/">Bootstrap</a> 和 <a href="https://chakra-ui.com/docs/features/style-props">Chakra UI</a>。</p><h2 id="写之前，我们谈谈优势"><a href="#写之前，我们谈谈优势" class="headerlink" title="写之前，我们谈谈优势"></a>写之前，我们谈谈优势</h2><ul><li>类名自由：你绞尽脑汁想这个元素的类名怎么写。在你面前的是一点击就会变颜色的按钮，你想给他起个class或者id，你想了半天，最后取了class名为<code>click-it-and-turn-it-from-blue-to-green</code>😰。</li><li>html嵌入：正常情况我们要引入CSS文件去写这个样式，切来切去不太方便。</li><li>预设的原子化CSS：可以引入插件、其他基于原子化CSS写的组件库。</li><li>IDE支持：插件支持类名提示，很好写。</li><li>写的快：比如说hover属性，原子化CSS可以直接写在class里，很快很方便，比如说tailwind自带的响应式布局，不用自己写媒体查询就可以适配移动端。</li></ul><h2 id="常用的原子化CSS框架"><a href="#常用的原子化CSS框架" class="headerlink" title="常用的原子化CSS框架"></a>常用的原子化CSS框架</h2><ul><li><p>tailwindCSS<a href="https://tailwindcss.com/">https://tailwindcss.com/</a></p><ul><li><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125214852.png"></li></ul></li><li><p>Windi CSS<a href="https://windicss.org/">https://windicss.org/</a></p><ul><li><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125215026.png"></li></ul></li><li><p><a href="https://tachyons.io/">Tachyons</a> <a href="https://tachyons.io/">https://tachyons.io/</a></p><ul><li><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125215141.png"></p></li><li><p>UnoCSS<a href="https://github.com/unocss/unocss">https://github.com/unocss/unocss</a></p><ul><li><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125215337.png"></li></ul></li></ul></li></ul><h2 id="本文的重点：UnoCSS"><a href="#本文的重点：UnoCSS" class="headerlink" title="本文的重点：UnoCSS"></a>本文的重点：UnoCSS</h2><p>讲这么多，我们终于回到主题UnoCSS上</p><blockquote><p> antfu<a href="https://link.juejin.cn/?target=https://antfu.me/posts/reimagine-atomic-css-zh">重新构想原子化CSS</a> 这篇文章讲了unocss是怎么诞生的</p></blockquote><p>Windi CSS已经足够优秀，但antfu大佬还是不够满意，对于框架预设外的自定义工具的额外配置上，还是比较繁琐，而且配置的方式也不够简便</p><blockquote><p>由于 Windi 需要与 Tailwind 兼容，它还必须使用与 Tailwind 完全相同的配置项。尽管数字推断的问题得到了解决，但如果你想添加一些自定义的工具，这将是一场噩梦。</p></blockquote><p>所以经过重新构想原子化CSS，UnoCSS出现了</p><blockquote><p><a href="https://link.juejin.cn/?target=https://github.com/antfu/unocss"><strong>UnoCSS</strong></a> - 具有高性能且极具灵活性的即时原子化 CSS引擎。</p></blockquote><p>它不是像TailWind CSS和Windi CSS属于框架，而是一个引擎，它没有提供预设的原子化CSS工具类</p><p>UnoCSS通过编写规则来定制工具类</p><p>静态规则</p><pre><code class="js">rules: [    [&#39;m-1&#39;, &#123; margin: &#39;0.25rem&#39; &#125;]]</code></pre><p>使用正则表达式来做动态规则</p><pre><code class="ts">rules: [  [/^m-(\d)$/, ([, d]) =&gt; (&#123; margin: `$&#123;d / 4&#125;rem` &#125;)],  [/^p-(\d)$/, (match) =&gt; (&#123; padding: `$&#123;match[1] / 4&#125;rem` &#125;)],]</code></pre><p>当然这些比较常见的规则unocss已经提供了预设在<code>@unocss/preset-uno</code>中</p><pre><code class="html">&lt;div class=&quot;m-100&quot;&gt;  &lt;button class=&quot;m-3&quot;&gt;    &lt;icon class=&quot;p-5&quot; /&gt;    My Button  &lt;/button&gt;&lt;/div&gt;</code></pre><p>生成出的css为</p><pre><code class="css">.m-100 &#123; margin: 25rem; &#125;.m-3 &#123; margin: 0.75rem; &#125;.p-5 &#123; padding: 1.25rem; &#125;</code></pre><p>unocss提供了一个叫shortcuts的功能，可以批量生成css</p><pre><code class="js">shortcuts: [  // you could still have object style  &#123;    btn: &#39;py-2 px-4 font-semibold rounded-lg shadow-md&#39;,  &#125;,  // dynamic shortcuts  [/^btn-(.*)$/, ([, c]) =&gt; `bg-$&#123;c&#125;-400 text-$&#123;c&#125;-100 py-2 px-4 rounded-lg`],]</code></pre><p>只需要配置这个字段</p><p>在使用中可以使用 <code>btn-green</code> 和 <code>btn-red</code> </p><p>生成的css如下</p><pre><code class="css">.btn-green &#123;  padding-top: 0.5rem;  padding-bottom: 0.5rem;  padding-left: 1rem;  padding-right: 1rem;  --un-bg-opacity: 1;  background-color: rgba(74, 222, 128, var(--un-bg-opacity));  border-radius: 0.5rem;  --un-text-opacity: 1;  color: rgba(220, 252, 231, var(--un-text-opacity));&#125;.btn-red &#123;  padding-top: 0.5rem;  padding-bottom: 0.5rem;  padding-left: 1rem;  padding-right: 1rem;  --un-bg-opacity: 1;  background-color: rgba(248, 113, 113, var(--un-bg-opacity));  border-radius: 0.5rem;  --un-text-opacity: 1;  color: rgba(254, 226, 226, var(--un-text-opacity));&#125;</code></pre><p>unocss提供了很多预设</p><h6 id="Official-Presets"><a href="#Official-Presets" class="headerlink" title="Official Presets"></a>Official Presets</h6><ul><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-uno">@unocss&#x2F;preset-uno</a> - The default preset (right now it’s equivalent to <code>@unocss/preset-wind</code>).</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-mini">@unocss&#x2F;preset-mini</a> - The minimal but essential rules and variants.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-wind">@unocss&#x2F;preset-wind</a> - Tailwind &#x2F; Windi CSScompact preset.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-attributify">@unocss&#x2F;preset-attributify</a> - Provides <a href="https://github.com/unocss/unocss/tree/main/packages/preset-attributify#attributify-mode">Attributify Mode</a> to other presets and rules.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-icons">@unocss&#x2F;preset-icons</a> - Use any icon as a class utility.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-web-fonts">@unocss&#x2F;preset-web-fonts</a> - Web fonts at ease.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-typography">@unocss&#x2F;preset-typography</a> - The typography preset.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-tagify">@unocss&#x2F;preset-tagify</a> - Tagify Mode for UnoCSS.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-rem-to-px">@unocss&#x2F;preset-rem-to-px</a> - Converts rem to px for utils.</li></ul><h6 id="Community-Presets"><a href="#Community-Presets" class="headerlink" title="Community Presets"></a>Community Presets</h6><ul><li><p><a href="https://github.com/macheteHot/unocss-preset-scalpel">unocss-preset-scalpel</a> - Scalpel Preset by <a href="https://github.com/macheteHot/">@macheteHot</a>.</p></li><li><p><a href="https://github.com/chu121su12/unocss-preset-chroma">unocss-preset-chroma</a> - Gradient Preset by <a href="https://github.com/chu121su12">@chu121su12</a>.</p></li><li><p><a href="https://github.com/action-hong/unocss-preset-scrollbar">unocss-preset-scrollbar</a> - Scrollbar Preset by <a href="https://github.com/action-hong">@action-hong</a>.</p></li><li><p><a href="https://github.com/unocss-applet/unocss-applet">unocss-applet</a> - Using UnoCSSin applet (UniApp &#x2F; Taro) by <a href="https://github.com/zguolee">@zguolee</a>.</p></li><li><p><a href="https://github.com/MellowCo/unocss-preset-weapp">unocss-preset-weapp</a> - Wechat MiniProgram Preset for <a href="https://uniapp.dcloud.io/">UniApp</a> and <a href="https://taro-docs.jd.com/taro/docs">Taro</a> by <a href="https://github.com/MellowCo">@MellowCo</a>.</p></li><li><p><a href="https://github.com/Julien-R44/unocss-preset-heropatterns">unocss-preset-heropatterns</a> - Preset that integrates <a href="https://heropatterns.com/">Hero Patterns</a> by <a href="https://github.com/Julien-R44">@Julien-R44</a>.</p></li><li><p><a href="https://github.com/Julien-R44/unocss-preset-flowbite">unocss-preset-flowbite</a> - Port of of <a href="https://github.com/themesberg/flowbite">Flowbite Tailwind plugin</a> for UnoCSSby <a href="https://github.com/Julien-R44">@Julien-R44</a>.</p></li><li><p><a href="https://github.com/Julien-R44/unocss-preset-forms">unocss-preset-forms</a> - Port of <a href="https://github.com/tailwindlabs/tailwindcss-forms">@tailwindcss&#x2F;forms</a> for UnoCSSby <a href="https://github.com/Julien-R44">@Julien-R44</a>.</p></li><li><p><a href="https://github.com/MoomFE/unocss-preset-extra">unocss-preset-extra</a> - <a href="https://animate.style/">Animate.css</a> Preset and some other rules by <a href="https://github.com/Zhang-Wei-666">@Zhang-Wei-666</a>.</p></li><li><p><a href="https://github.com/kidonng/unocss-preset-daisy">unocss-preset-daisy</a> - daisyUI Preset by <a href="https://github.com/kidonng">@kidonng</a>.</p></li><li><p><a href="https://github.com/zirbest/unocss-preset-primitives">unocss-preset-primitives</a> - Like <a href="https://github.com/tailwindlabs/headlessui/tree/main/packages/%40headlessui-tailwindcss">headlessui-tailwindcss</a> , radix-ui , custom for UnoCSSBy <a href="https://github.com/zirbest">@zirbest</a>.</p></li><li><p><a href="https://github.com/Dunqing/unocss-preset-theme">unocss-preset-theme</a> - Preset for automatic theme switching by <a href="https://github.com/Dunqing">@Dunqing</a>.</p><p>通过这些预设可以达到融合tailwind和windi的效果</p></li></ul><h2 id="UnoCSS的优点"><a href="#UnoCSS的优点" class="headerlink" title="UnoCSS的优点"></a>UnoCSS的优点</h2><p>对比其他原子化框架来说</p><ul><li><p>完全可定制：作为一款引擎没有核心实用程序，所有的功能都是通过预设提供的。</p></li><li><p>扩展性强：通过各种预设组合达到windi或者tailwind的效果。</p></li><li><p>快：没有解析，没有AST，没有扫描，它是即时的。</p></li><li><p>小：运行库打包好只有6kb，无痛</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main#shortcuts">Shortcuts</a>：可以写Shortcuts来预设一些常用样式</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/preset-attributify/">Attributify mode</a> ：将class写成组，避免无法阅读的问题</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/preset-icons/">Pure CSSIcons</a> ：纯 CSSicon 可以在 <a href="https://icones.js.org/">https://icones.js.org/</a> 找到并导入成千上万的icon  安装只需要找到你喜欢的 iconfy 库 <code>@iconify-json/[the-collection-you-want]</code> 这样安装就行</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/transformer-variant-group">Variant Groups</a> ：和 <a href="https://github.com/unocss/unocss/tree/main/packages/preset-attributify/">Attributify mode</a> 看起来几乎是一样的功能，写成组</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/transformer-directives">CSSDirectives</a> ：可以在style标签里写  <code>@apply</code>  把一系列样式打包成一个样式，在windi里是个很受欢迎的功能</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/transformer-compile-class/">Compilation mode</a> ：打包优化，生成随机class名</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main#inspector">Inspector</a> ：自带的debug工具</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/runtime">CSS-in-JS Runtime build</a> ：可以CDN导入</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=antfu.unocss">VS Code extension</a>：自带VSCode提示扩展，很方便</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇我们介绍了UnoCSS的特点，原子化CSS的好处，下一篇讲讲unocss实战，安装使用之类的</p><p>题外话：</p><blockquote><p>Anthony Fu大佬真的是我目前的偶像，狂热的开源爱好者，人长得又帅，做的东西又好</p></blockquote><p>🤣这是我在掘金搜unocss搜到的一篇文章中的第一句话 文章在这 <a href="https://juejin.cn/post/7028841960752283656">https://juejin.cn/post/7028841960752283656</a></p><p>antfu大佬确实也是我的偶像</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125225032.png"></p><p>22年秋季 antfu大佬在b站办过几场直播写代码，我基本上是每期必看，这个人非常有意思，有很多新鲜的点子，狠活也多 比如说</p><p><a href="https://github.com/antfu/1990-script">https://github.com/antfu/1990-script</a> 这个仓库教你怎么把GitHub历史穿越回1990年🤭</p><p>他的每个star比较多的仓库我都体验过，感觉设计灵感真的让人眼前一亮，启发基于社区，创造更快的轮子，更好玩的轮子</p><p><a href="https://github.com/antfu/retypewriter">https://github.com/antfu/retypewriter</a> 这个是直播写的雏形 让写的代码在vsc里回放，便于理清思路</p><p><a href="https://github.com/antfu/vue-minesweeper">https://github.com/antfu/vue-minesweeper</a> 这个是首次直播写的扫雷，很清晰的vue代码，看他写真的开窍</p><p><a href="https://github.com/antfu/vue-starport">https://github.com/antfu/vue-starport</a> 这个也是直播写的雏形，为了使组件有更好的过渡</p><p>就说这么多，人也长得帅</p><p>🥰😘</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7028841960752283656">https://juejin.cn/post/7028841960752283656</a></p><p><a href="https://antfu.me/posts/reimagine-atomic-css-zh">https://antfu.me/posts/reimagine-atomic-css-zh</a></p><p><a href="https://juejin.cn/post/7027414082378530852">https://juejin.cn/post/7027414082378530852</a></p><p><a href="https://juejin.cn/post/7161211941652791304">https://juejin.cn/post/7161211941652791304</a></p><p><a href="https://www.tailwindcss.cn/docs/">https://www.tailwindcss.cn/docs/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MonoRepo&amp;Nuxt框架初始化实战 ｜ 青训营笔记</title>
      <link href="/2023/01/24/MonoRepo&amp;Nuxt%E6%A1%86%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/24/MonoRepo&amp;Nuxt%E6%A1%86%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 8 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇笔记介绍了MonoRepo的优点和基于go语言的MonoRepo框架TurboRepo，这一篇我们详细介绍一下如何配置出一个团队能用的TurboRepo库，包括一些actions和自动部署预览等。</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>⚡️ <code>Nuxt3</code> - SSR框架</li><li>✨ <code>Vue3.2 </code>- 最新Vue更多语法糖</li><li>💨 <code>Turbo</code> - MonoRepo框架</li><li>💎 <code>Strapi</code> - Headless CMS 框架</li><li>😎 <code>@Nuxt/Image</code> - images 服务端渲染</li><li>😁 <code>Umami</code> - Better Analytics 访问源分析</li><li>🃏 <code>Commit Lint</code> - commit规范检查</li><li>💖 <code>Husky &amp; Lint Staged</code> — precommit运行库</li><li>📏 <code>Eslint</code> - 规范化TypeScript、JavaScript代码</li><li>🐶 <code>UnoCss</code> - 原子化 CSS 引擎、兼容 tailwindcss、windicss </li><li>🤖 <code>preset-icons</code> - unocss 自带icons</li><li>⏰ The <code>&lt;script setup&gt;</code> syntax setup语法糖 来自Vue3.2</li><li>🍍 <code>Pinia</code> - 全局状态管理库 更好用</li><li>🎨 <code>APIs auto importing</code> - 库自动引入</li><li>🦾 <code>TypeScript</code> - 更规范的语法</li><li>👷 <code>Github Actions</code> - actions自动运行、ci&#x2F;cd云端检查语法</li><li>👀 <code>Automatic Branch and Issue Autolink</code> - Issue AutoLink actions 创建issue会创建一个分支</li><li>🗺 <code>Nuxt SEO Kit</code> - SEO优化 SSR必备</li><li>📦 <code>Vercel</code> - 自动部署、预览的平台</li><li>🔥 <code>Netlify + Cloudflare</code> - 部署平台</li></ul><h2 id="前端模板"><a href="#前端模板" class="headerlink" title="前端模板"></a>前端模板</h2><p>前端模板选择了<a href="https://github.com/antfu/vitesse-nuxt3">https://github.com/antfu/vitesse-nuxt3</a> </p><p>是antfu的vitesse系列模板的nuxt3款</p><p>这套模板用了好多个 很好用的</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230124233609.png"></p><p>配置很全、自带的unocss也是几乎兼容windicss和tailwind 很适应</p><p>想用icons可以去antfu的另一个项目里找</p><p><a href="https://icones.js.org/">https://icones.js.org/</a> 这里二次封装了几万个icons用个爽</p><h2 id="配置turbo"><a href="#配置turbo" class="headerlink" title="配置turbo"></a>配置turbo</h2><p>turbo官网有讲怎么配置到一个已有的MonoRepo里<a href="https://turbo.build/repo/docs/getting-started/existing-monorepo">https://turbo.build/repo/docs/getting-started/existing-monorepo</a></p><p>这里只需要在根目录的package.json里建立<code>workspaces</code>字段 和<code>packageManager</code>字段</p><pre><code class="json">//package.json&#123;&quot;packageManager&quot;: &quot;yarn@1.22.19&quot;,  &quot;workspaces&quot;: [    &quot;frontend&quot;,    &quot;backend&quot;  ],&#125;</code></pre><h3 id="安装TurboRepo"><a href="#安装TurboRepo" class="headerlink" title="安装TurboRepo"></a>安装TurboRepo</h3><pre><code class="sql">yarn global add turbo</code></pre><h3 id="创建任务管道"><a href="#创建任务管道" class="headerlink" title="创建任务管道"></a>创建任务管道</h3><p>在<code>package.json</code> 的<code>turbo</code>中，将想要”turbo”的命令添加到管道中 管道定义了 npm 包中 scripts 的依赖关系，并且为这些命令开启了缓存。这些命令的依赖关系和缓存设置会应用到 MonoRepo 中的各个包中</p><pre><code class="json">//turbo.json&#123;  &quot;$schema&quot;: &quot;https://turbo.build/schema.json&quot;,  &quot;pipeline&quot;: &#123;    &quot;build&quot;: &#123;      // A package&#39;s `build` script depends on that package&#39;s      // dependencies and devDependencies      // `build` tasks  being completed first      // (the `^` symbol signifies `upstream`).      &quot;dependsOn&quot;: [&quot;^build&quot;],      // note: output globs are relative to each package&#39;s `package.json`      // (and not the monorepo root)      &quot;outputs&quot;: [&quot;.next/**&quot;]    &#125;,    &quot;test&quot;: &#123;      // A package&#39;s `test` script depends on that package&#39;s      // own `build` script being completed first.      &quot;dependsOn&quot;: [&quot;build&quot;],      // A package&#39;s `test` script should only be rerun when      // either a `.tsx` or `.ts` file has changed in `src` or `test` folders.      &quot;inputs&quot;: [&quot;src/**/*.tsx&quot;, &quot;src/**/*.ts&quot;, &quot;test/**/*.ts&quot;, &quot;test/**/*.tsx&quot;]    &#125;,    // A package&#39;s `lint` script has no dependencies and    // can be run whenever. It also has no filesystem outputs.    &quot;lint&quot;: &#123;&#125;,    &quot;deploy&quot;: &#123;      // A package&#39;s `deploy` script depends on the `build`,      // `test`, and `lint` scripts of the same package      // being completed. It also has no filesystem outputs.      &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;]    &#125;  &#125;&#125;</code></pre><p>上面的示例中，<code>build</code>和<code>test</code>这两个任务具有依赖性，必须要等他们的依赖项对应的任务完成后才能执行，所以这里用<code>^</code>来表示。 对于每个包中 package.json 中的 script 命令，如果没有配置覆盖项，那么TurboRepo将缓存默认输出到 <code>dist/** </code>和<code>build/**</code>文件夹中。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>这样只需要运行</p><pre><code class="bash">npx turbo run build test lint deploy</code></pre><p>就可以运行全部参数</p><h3 id="配置-gitignore"><a href="#配置-gitignore" class="headerlink" title="配置.gitignore"></a>配置<code>.gitignore</code></h3><p>根目录 创建<code>.gitignore</code>文件</p><pre><code class="json">+ .turbo+ build/**+ dist/**+ .next/**</code></pre><h3 id="Remote-cache"><a href="#Remote-cache" class="headerlink" title="Remote cache"></a>Remote cache</h3><pre><code class="bash">turbo login</code></pre><pre><code class="bash">turbo link</code></pre><p>然后删除你的<code>./node_modules/.cache/turbo</code>文件夹</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230123234538.png"></p><p>显示 full turbo 则证明匹配到了云端的缓存，直接拉下来不再构建一遍</p><h2 id="配置husky"><a href="#配置husky" class="headerlink" title="配置husky"></a>配置husky</h2><p>在根目录安装husky</p><p>先运行<code>husky install</code></p><p>然后创建<code>.husky</code>文件夹</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230124235647.png"></p><p>文件树如上</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code>//.gitignore*</code></pre><pre><code class="sh"># husky.sh#!/usr/bin/env shif [ -z &quot;$husky_skip_init&quot; ]; then  debug () &#123;    if [ &quot;$HUSKY_DEBUG&quot; = &quot;1&quot; ]; then      echo &quot;husky (debug) - $1&quot;    fi  &#125;  readonly hook_name=&quot;$(basename -- &quot;$0&quot;)&quot;  debug &quot;starting $hook_name...&quot;  if [ &quot;$HUSKY&quot; = &quot;0&quot; ]; then    debug &quot;HUSKY env variable is set to 0, skipping hook&quot;    exit 0  fi  if [ -f ~/.huskyrc ]; then    debug &quot;sourcing ~/.huskyrc&quot;    . ~/.huskyrc  fi  readonly husky_skip_init=1  export husky_skip_init  sh -e &quot;$0&quot; &quot;$@&quot;  exitCode=&quot;$?&quot;  if [ $exitCode != 0 ]; then    echo &quot;husky - $hook_name hook exited with code $exitCode (error)&quot;  fi  if [ $exitCode = 127 ]; then    echo &quot;husky - command not found in PATH=$PATH&quot;  fi  exit $exitCodefi</code></pre><pre><code class="sh">//commit-msg#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;npx --no-install commitlint --edit &quot;$1&quot;</code></pre><pre><code class="sh">//post-merge#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;yarn install</code></pre><pre><code class="sh">//pre-commit#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;yarn lint-staged</code></pre><h3 id="安装commit-lint"><a href="#安装commit-lint" class="headerlink" title="安装commit lint"></a>安装commit lint</h3><pre><code>yarn install -D @commitlint/config-conventional @commitlint/cli</code></pre><p>这个可以在MonoRepo内安装不在根目录装</p><p>在前端的package.json里配置</p><pre><code class="json">//./frontend/package.json&#123;  &quot;name&quot;: &quot;frontend&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;nuxi build&quot;,    &quot;dev&quot;: &quot;nuxi dev&quot;,    &quot;start&quot;: &quot;node .output/server/index.mjs&quot;,    &quot;lint&quot;: &quot;eslint .&quot;,    &quot;lint:fix&quot;: &quot;eslint . --fix&quot;,    &quot;generate&quot;: &quot;nuxi generate&quot;,    &quot;typecheck&quot;: &quot;tsc --noEmit --incremental false&quot;,    &quot;lint:strict&quot;: &quot;eslint --max-warnings=0 .&quot;  &#125;,  &quot;lint-staged&quot;: &#123;    &quot;**/*.&#123;js,ts,vue,html&#125;&quot;: [      &quot;eslint --max-warnings=0&quot;    ]  &#125;&#125;</code></pre><p>最后在根目录创建<code>commitlint.config.js</code></p><p>里面写上commit lint 规则</p><pre><code class="js">//commitlint.config.jsmodule.exports = &#123;  extends: [&#39;@commitlint/config-conventional&#39;],  rules: &#123;    &#39;type-enum&#39;: [      2,      &#39;always&#39;,      [        &#39;feat&#39;,        &#39;fix&#39;,        &#39;docs&#39;,        &#39;chore&#39;,        &#39;style&#39;,        &#39;refactor&#39;,        &#39;ci&#39;,        &#39;test&#39;,        &#39;revert&#39;,        &#39;perf&#39;,        &#39;build&#39;,        &#39;vercel&#39;,      ],    ],  &#125;,&#125;</code></pre><h2 id="配置-gitignore-1"><a href="#配置-gitignore-1" class="headerlink" title="配置.gitignore"></a>配置<code>.gitignore</code></h2><pre><code>node_modules*.logdist.output.nuxt.env.turbo# Logslogs*.lognpm-debug.log*yarn-debug.log*yarn-error.log*lerna-debug.log*# Diagnostic reports (https://nodejs.org/api/report.html)report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json# Runtime datapids*.pid*.seed*.pid.lock# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage*.lcov# nyc test coverage.nyc_output# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files).grunt# Bower dependency directory (https://bower.io/)bower_components# node-waf configuration.lock-wscript# Compiled binary addons (https://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modules/jspm_packages/# TypeScript v1 declaration filestypings/# TypeScript cache*.tsbuildinfo# Optional npm cache directory.npm# Optional eslint cache.eslintcache# Microbundle cache.rpt2_cache/.rts2_cache_cjs/.rts2_cache_es/.rts2_cache_umd/# Optional REPL history.node_repl_history# Output of &#39;npm pack&#39;*.tgz# Yarn Integrity file.yarn-integrity# dotenv environment variables file.env.env.test# parcel-bundler cache (https://parceljs.org/).cache# Next.js build output.next# Nuxt.js build / generate output.nuxtdist# Gatsby files.cache/# Comment in the public line in if your project uses Gatsby and *not* Next.js# https://nextjs.org/blog/next-9-1#public-directory-support# public# vuepress build output.vuepress/dist# Serverless directories.serverless/# FuseBox cache.fusebox/# DynamoDB Local files.dynamodb/# TernJS port file.tern-port.vercelfrontend/.env</code></pre><h2 id="配置vercel"><a href="#配置vercel" class="headerlink" title="配置vercel"></a>配置vercel</h2><p>创建<code>vercel.json</code></p><p>由于是nuxt3项目 vercel有预设 只需要配置一个字段</p><pre><code class="json">&#123;  &quot;framework&quot;: &quot;nuxtjs&quot;&#125;</code></pre><p>然后是登录vercel把项目绑定上去</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125000950.png"></p><p>配置好团队是这样的</p><h2 id="配置netlify"><a href="#配置netlify" class="headerlink" title="配置netlify"></a>配置netlify</h2><p>创建<code>netlify.toml</code></p><pre><code class="toml">[build.environment]  NODE_VERSION = &quot;16&quot;[build]  publish = &quot;dist&quot;  command = &quot;yarn build&quot;  functions = &quot;netlify/functions&quot;[[redirects]]  from = &quot;/*&quot;  to = &quot;/index.html&quot;  status = 200</code></pre><p>默认配置为如上</p><p>然后是登录netlify把项目绑定上去</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125001234.png"></p><p>配好了是这样的</p><h2 id="配置workflows"><a href="#配置workflows" class="headerlink" title="配置workflows"></a>配置workflows</h2><p>配置一个actions用来在线lint 有错会xx</p><pre><code class="yaml"># lint.yaml# https://github.com/kentcdodds/kentcdodds.com/blob/main/.github/workflows/deployment.ymlname: Code Checkon:  push:    branches:      - main  pull_request: &#123;&#125;jobs:  lint:    name: ⬣ ESLint    runs-on: ubuntu-latest    steps:      - name: 🛑 Cancel Previous Runs        uses: styfle/cancel-workflow-action@0.9.1      - name: ⬇️ Checkout repo        uses: actions/checkout@v2      - name: ⎔ Setup node        uses: actions/setup-node@v2        with:          node-version: 16      - name: 📥 Download deps        uses: bahmutov/npm-install@v1      - name: 🔬 Lint        run: npx turbo lint:strict</code></pre><p>配置一个release bot 用来生成打包文件 区分版本号</p><pre><code class="yaml"># release.yamlname: release-pleaseon:  # workflow_dispatch:  push:    branches:      - mainjobs:  release-please:    runs-on: ubuntu-latest    steps:      - uses: google-github-actions/release-please-action@v3        with:          release-type: node          package-name: release-please-action</code></pre><p>配置 issue bot 用来自动用issue创建分支</p><pre><code class="yaml"># issue.yamlname: &quot;Issue Autolink&quot;on:  pull_request:    types: [opened]jobs:  issue-links:    runs-on: ubuntu-latest    steps:      - uses: tkt-actions/add-issue-links@v1.6.0        with:          repo-token: &quot;$&#123;&#123; secrets.AUTO_LINK &#125;&#125;&quot;          branch-prefix: &quot;i&quot;          resolve: &quot;true&quot;</code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到此应该初始化的差不多了</p><p>这个从创建 debug 到上线的时间大概花了两天 问题出在 vercel 和 netlify 上</p><p>vercel 对 nuxt 的兼容性不好，不如他的亲儿子 next</p><p>刚去查了一下 nuxt3在1月23日变成了默认版本</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003129.png"></p><p>nuxt3用了一个叫nitro的编译框架 <a href="https://github.com/unjs/nitro">https://github.com/unjs/nitro</a></p><p><a href="https://nitro.unjs.io/">https://nitro.unjs.io/</a></p><p><code>构建和部署通用JavaScript服务器</code></p><p><code>Nitro提供了一个强大的工具链和一个来自unjs生态系统的运行时框架，可以随时随地构建和部署任何JavaScript服务器！</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003640.png"></p><p>unjs 我感觉是写js魔法的组织 里面全是魔法库</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003728.png"></p><p>这位是主谋</p><p>这个框架会自动检测你当前的环境 给你分配一个preset  比如说你在当前node环境build nuxt的话会给你生成一个 .mjs文件 你运行文件就可以启动一个SSR服务器</p><p>你在vercel上运行的话就给你 <code>preset：vercel</code> 生成vercel认的文件格式</p><p>netlify同理</p><p>问题出在 使用MonoRepo 后 nitro不认我这是在vercel里了  他会生成默认的node的mjs文件 然后构建失败</p><p>很烦</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://turbo.build/repo/docs/getting-started/existing-monorepo">https://turbo.build/repo/docs/getting-started/existing-monorepo</a></p><p><a href="https://github.com/antfu/vitesse-nuxt3">https://github.com/antfu/vitesse-nuxt3</a></p><p><a href="https://github.com/antfu?tab=repositories&amp;q=vitesse&amp;type=&amp;language=&amp;sort=">https://github.com/antfu?tab=repositories&amp;q=vitesse&amp;type=&amp;language=&amp;sort=</a></p><p><a href="https://nitro.unjs.io/">https://nitro.unjs.io/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MonoRepo设置与部署 ｜ 青训营笔记</title>
      <link href="/2023/01/23/MonoRepo%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/23/MonoRepo%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 7 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>举个例子，你现在有一个全栈的项目，团队里写了前端、后端、使用文档和一个工具库。</p><p>一般情况的话，我们会创建四个仓库，放不同的内容，其中前端如果使用工具库的话，我们会在前端里引入工具库的包（可能是直接，可能是在npm上publish过的）</p><p>你希望运行前端项目的时候，同时运行三个命令（例如使用yarn）你需要运行 <code>yarn lint</code> 、<code>yarn build</code> 、<code>yarn serve</code> 你需要敲三个命令，很麻烦。</p><h2 id="MonoRepo"><a href="#MonoRepo" class="headerlink" title="MonoRepo"></a>MonoRepo</h2><h3 id="什么是MonoRepo"><a href="#什么是MonoRepo" class="headerlink" title="什么是MonoRepo"></a>什么是MonoRepo</h3><p>在开发场景中，我们希望各个项目之间能够足够的独立，各自的开发和发布不会产生太多的耦合，现在很多的项目也是出于这种考虑去拆成一个一个独立的子项目，在单独的代码仓库中进行管理，这就是我们常见的单代码仓库的开发模式。 </p><p>例如我们<code>前言</code>中举的例子，你想要前端项目中使用工具库中的包，你需要到前端，或者使用npm publish后再安装，当你工具库的版本更新的时候，你需要把前端项目里的工具库版本也更新掉。</p><p>如果把所有有依赖关系的代码都放到一个仓库中进行统一维护，当一个库变动时，其它的代码能自动的进行依赖升级，那么就能精简开发流程、提高开发效率。这种多包的代码仓库管，就是 MonoRepo。 </p><p>其实TurboRepo在前端中非常常见，Babel、React、Vue等开源项目都是使用这种方式在管理代码，其中 Babel 官方开源的多包管理工具 Lerna 也被广泛的使用。</p><p>这次我介绍的是TurboRepo。</p><h2 id="TurboRepo"><a href="#TurboRepo" class="headerlink" title="TurboRepo"></a>TurboRepo</h2><p>TurboRepo是一个适用于 JavaScript 和 Typescript TurboRepo的高性能构建工具，使用go、rust语言编写，性能很好。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>增量构建：缓存构建内容，并跳过已经计算过的内容，通过增量构建来提高构建速度</p></li><li><p>内容hash：通过文件内容计算出来的hash来判断文件是否需要进行构建，缓存在云端，登录即可享受</p></li><li><p>云缓存：可以和团队成员共享CI&#x2F;CD的云构建缓存，来实现更快的构建</p></li><li><p>多任务并行执行：在不浪费空闲 CPU 的情况下，以最大并行数量来进行构建</p></li><li><p>任务管道：通过定义任务之间的关系，让 TurboRepo 优化构建的内容和时间</p></li><li><p>约定式配置：通过约定来降低配置的复杂度，只需要几行简单的 JSON 就能完成配置（配置turbo.json)</p></li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>对于一个新的项目，可以运行下面的命令来生成全新的代码仓库</p><pre><code class="sql">npx create-turbo@latest</code></pre><p>对于一个已经存在的 monorepo 项目，可以通过下面的步骤来接入 turborepo</p><h3 id="安装Turborepo"><a href="#安装Turborepo" class="headerlink" title="安装Turborepo"></a>安装Turborepo</h3><p>将 Turborepo 添加到项目最外层的<code>devDependecies</code>中</p><pre><code class="sql">npm install turbo -Doryarn add turbo --dev</code></pre><h3 id="创建任务管道"><a href="#创建任务管道" class="headerlink" title="创建任务管道"></a>创建任务管道</h3><p>在<code>package.json</code> 的<code>turbo</code>中，将想要”turbo”的命令添加到管道中 管道定义了 npm 包中 scripts 的依赖关系，并且为这些命令开启了缓存。这些命令的依赖关系和缓存设置会应用到 monorepo 中的各个包中</p><pre><code class="json">&#123;    &quot;turbo&quot;: &#123;        &quot;pipeline&quot;: &#123;            &quot;build&quot;: &#123;                &quot;dependsOn&quot;: [&quot;^build&quot;],                        &quot;outputs&quot;: [&quot;.next/**&quot;]                        &#125;,            &quot;test&quot;: &#123;                &quot;dependsOn&quot;: [&quot;^build&quot;],                &quot;outputs&quot;: []                                        &#125;,            &quot;lint&quot;: &#123;                &quot;outputs&quot;: []            &#125;,            &quot;dev&quot;: &#123;                &quot;cache&quot;: false                        &#125;         &#125;        &#125;&#125;</code></pre><p>上面的示例中，<code>build</code>和<code>test</code>这两个任务具有依赖性，必须要等他们的依赖项对应的任务完成后才能执行，所以这里用<code>^</code>来表示。 对于每个包中 package.json 中的 script 命令，如果没有配置覆盖项，那么Turborepo将缓存默认输出到 <code>dist/** </code>和<code>build/**</code>文件夹中。</p><h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><p>从上面的 turbo 的配置中可以看出来，管道(pipeline)是一个核心的概念，Turborepo也是通过管道来处理各个任务和他们的依赖关系的。</p><p>Turborepo提供了一种声明式的方法来指定各个任务之间的关系，这种方式能够更容易理解各个任务之间的关系，并且Turborepo也能通过这种显式的声明来优化任务的执行并充分调度CPU的多核心性能。</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230123234328.png"></p><h3 id="配置pipeline"><a href="#配置pipeline" class="headerlink" title="配置pipeline"></a>配置pipeline</h3><p>pipeline中每个键名都可以通过运行<code>turbo run</code>来执行，并且可以使用<code>dependsOn</code>来执行当前管道的依赖项。</p><p>上图的执行流程，可以配置成如下的格式</p><pre><code class="json">&#123;    &quot;turbo&quot;: &#123;        &quot;pipeline&quot;: &#123;            &quot;build&quot;: &#123;                &quot;dependsOn&quot;: [&quot;^build&quot;],                       &#125;,            &quot;test&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;],                &quot;outputs&quot;: []                                        &#125;,            &quot;lint&quot;: &#123;                &quot;outputs&quot;: []            &#125;,            &quot;deploy&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;]                       &#125;         &#125;        &#125;&#125;</code></pre><p>通过<code>dependsOn</code>的配置，可以看出各个命令的执行顺序：</p><ul><li>因为A和C依赖于B，所以包的构建存在依赖关系，根据build的dependson配置，会先执行依赖项的build命令，依赖项执行完后才会执行自己的build命令。从上面的瀑布流中也可以看出，B的build先执行，执行完以后A和C的build会并行执行</li><li>对于test，只依赖自己的build命令，只要自己的build命令完成了，就立即执行test</li><li>lint没有任何依赖，在任何时间都可以执行</li><li>自己完成build、test、lint后，再执行deploy命令</li></ul><p>可以通过下面的命令执行：</p><pre><code class="bash">npx turbo run test build lint deploy</code></pre><h3 id="常规依赖"><a href="#常规依赖" class="headerlink" title="常规依赖"></a>常规依赖</h3><p>如果一个任务的执行，只依赖自己包其他的任务，那么可以把依赖的任务放在dependsOn数组里</p><pre><code class="json">&#123;    &quot;turbo&quot;: &#123;        &quot;pipeline&quot;: &#123;            &quot;deploy&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;]                       &#125;         &#125;        &#125;&#125;</code></pre><h3 id="特定依赖"><a href="#特定依赖" class="headerlink" title="特定依赖"></a>特定依赖</h3><p>在一些场景下，一个任务可能会依赖某个包的特定的任务，这时候我们需要去手动指定依赖关系。</p><pre><code class="json">&#123;    &quot;turbo&quot;: &#123;        &quot;pipeline&quot;: &#123;            &quot;build&quot;: &#123;                &quot;dependsOn&quot;: [&quot;^build&quot;],                       &#125;,            &quot;test&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;],                &quot;outputs&quot;: []                                        &#125;,            &quot;lint&quot;: &#123;                &quot;outputs&quot;: []            &#125;,            &quot;deploy&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;]                       &#125;,            &quot;frontend#deploy&quot;: &#123;                &quot;dependsOn&quot;: [&quot;ui#test&quot;, &quot;backend#deploy&quot;]                        &#125;        &#125;        &#125;&#125;</code></pre><h2 id="Remote-cache"><a href="#Remote-cache" class="headerlink" title="Remote cache"></a>Remote cache</h2><p>当多人开个一个项目的时候，团队的成员可以共享构建的缓存，从而加快项目的构建速度。</p><p>当一个成员把某个分支构建的缓存文件推送到远程的git仓库是，另一个成员如果在同一个分支上进行开发，那么Turborepo 可以支持你去选择某个成员的构建缓存，并在运行相关的构建任务时，从远端拉去缓存文件到本地，加快构建的速度</p><p>运行 npx turbo link，进行登录后，就可以选择要使用的缓存</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230123234538.png"></p><p>显示 full turbo 则证明匹配到了云端的缓存，直接拉下来不再构建一遍</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>我相信 Turborepo 的出现在不久的将来一定会成为 Monorepo 工具链中重要的一环，无论是构建缓存功能还是基于 pipeline 的智能任务调度系统，都非常优秀的解决了传统 Monorepo 存在“慢”的问题。</p><p>为了更好的性能，大部分人将不再局限于使用 JavaScript 开发 JavaScript 工具，而是更愿意选择其他高门槛语言。</p><p>我感觉使用turbo有很好的体验，但他好像对nuxt兼容性不好，只兼容自己的亲儿子next🤣。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7051929587852247077">https://juejin.cn/post/7051929587852247077</a><br><a href="https://juejin.cn/post/7048234698048274469">https://juejin.cn/post/7048234698048274469</a><br><a href="https://juejin.cn/post/7129267782515949575">https://juejin.cn/post/7129267782515949575</a></p><p><a href="https://github.com/vercel/turbo">https://github.com/vercel/turbo</a></p><p><a href="https://turbo.build/repo/docs/core-concepts/monorepos/running-tasks">https://turbo.build/repo/docs/core-concepts/monorepos/running-tasks</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议 ｜ 青训营笔记</title>
      <link href="/2023/01/22/HTTP%E5%8D%8F%E8%AE%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/22/HTTP%E5%8D%8F%E8%AE%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 6 天</strong></p><h2 id="本堂课重点内容"><a href="#本堂课重点内容" class="headerlink" title="本堂课重点内容"></a>本堂课重点内容</h2><ol><li>HTTP 协议的简单介绍</li><li>HTTP 协议的报文结构</li></ol><h2 id="详细知识点介绍"><a href="#详细知识点介绍" class="headerlink" title="详细知识点介绍"></a>详细知识点介绍</h2><p>HTTP 全称超文本传输协议（Hyper Text Transfer Protocol），是一个基于TCP协议的无状态应用层协议。</p><h3 id="HTTP-发展历史"><a href="#HTTP-发展历史" class="headerlink" title="HTTP 发展历史"></a>HTTP 发展历史</h3><ul><li><p>HTTP&#x2F;0.9</p><ul><li><p>只有GET类型的请求</p></li><li><p>只能响应HTML文档</p></li></ul></li><li><p>HTTP&#x2F;1.0</p><ul><li><p>增加了 Header</p></li><li><p>增加了状态码</p></li><li><p>支持了多种文档类型</p></li></ul></li><li><p>HTTP&#x2F;1.1(常见)</p><ul><li><p>连接复用</p></li><li><p>提供了缓存支持</p></li><li><p>支持内容协商</p></li></ul></li><li><p>HTTP&#x2F;2</p><ul><li><p>二进制协议</p></li><li><p>支持Header压缩</p></li><li><p>增加了服务器推送（Server Push）</p></li></ul></li><li><p>HTTP&#x2F;3</p><ul><li>基于QUIC（udp）协议</li></ul></li></ul><h3 id="常见的-HTTP-Methods"><a href="#常见的-HTTP-Methods" class="headerlink" title="常见的 HTTP Methods"></a>常见的 HTTP Methods</h3><table><thead><tr><th>请求类型</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>请求一个指定的资源。使用GET的请求一般用于获取数据</td></tr><tr><td>POST</td><td>将实体提交到指定资源，通常导致服务器上的状态变化或副作用</td></tr><tr><td>PUT</td><td>用于请求有效载荷替换目标资源</td></tr><tr><td>DELETE</td><td>用于删除指定的资源</td></tr><tr><td>HEAD</td><td>请求一个与GET请求的响应相同的响应，但没有响应体</td></tr><tr><td>OPTIONS</td><td>预检请求，用于描述目标资源的通信选项</td></tr></tbody></table><p>其中最常见的是 <code>GET</code> 请求和 <code>POST</code> 请求，<code>PUT</code> <code>DELETE</code> 常见于各类 RESTful API 中。而 <code>OPTIONS</code> 请求被称为预检请求，倘若我们尝试为前面的几个请求类型增加自定义Header，浏览器会默认向服务器发出一个OPTIONS请求，用于判断服务器能否接收&#x2F;处理该header。</p><h3 id="常见-HTTP-状态码"><a href="#常见-HTTP-状态码" class="headerlink" title="常见 HTTP 状态码"></a>常见 HTTP 状态码</h3><blockquote><p>1xx - 指示信息 </p><p>2xx - 请求成功 </p><p>3xx - 重定向操作 </p><p>4xx - 客户端错误 </p><p>5xx - 服务端错误</p></blockquote><ul><li><code>200</code> 正常响应</li><li><code>301</code> 永久重定向</li><li><code>302</code> 临时重定向</li><li><code>401</code> 未授权</li><li><code>403</code> 请求被拒绝</li><li><code>404</code> 请求资源不存在</li><li><code>500</code> 服务器错误</li><li><code>504</code> 网关错误</li></ul><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>他是一种API设计风格。</p><ol><li>每一个URL代表一种资源</li><li>客户端和服务端之间，传递这种资源的某种表现层。</li><li>客户端通过HTTP method，对服务端资源进行操作，实现”表现层状态转化”</li></ol><h3 id="常见请求头"><a href="#常见请求头" class="headerlink" title="常见请求头"></a>常见请求头</h3><ul><li>Accept：接受类型</li><li>Content-Type：客户端发送出去实体内容的类型</li><li>Cache-Control：指定请求和响应遵循的缓存机制。</li><li>Cookie：有cookie会自动带上</li></ul><h3 id="常用响应头"><a href="#常用响应头" class="headerlink" title="常用响应头"></a>常用响应头</h3><ul><li>Set-Cookie：设置和页面关联的Cookie</li><li>Content-Type：服务端</li></ul><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>帧：http2最小通信单位，每个帧都包含帧头</p><p>消息：与逻辑请求或响应消息对应的完整的一系列帧。</p><p>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</p><p>交错发送，接收方重组织。</p><p>HTTP2连接是永久的，而且仅需要每个来源一个连接。</p><p>流控制：阻止发送方向接收方发送大量数据的机制。</p><p>服务器有主动推送能力，可以提前推送静态资源。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS &#x3D; HTTP + SSL</p><p>对称加密：加密和解密都是用同一个密钥</p><p>非对称加密：加密和解密都需要使用两个不同的密钥：公钥和私钥。</p><h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><ul><li>Session+Cookie</li><li>JWT</li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ul><li>浏览器与服务器进行全双工通讯的网络技术</li><li>实时性高</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>QUIC：HTTP3的新特性</p><h2 id="实践练习例子"><a href="#实践练习例子" class="headerlink" title="实践练习例子"></a>实践练习例子</h2><p><a href="https://www.w3schools.cn/html/exercise.asp">https://www.w3schools.cn/html/exercise.asp</a></p><h2 id="课后个人总结"><a href="#课后个人总结" class="headerlink" title="课后个人总结"></a>课后个人总结</h2><p>本次课程主要介绍了 HTTP 协议的基本知识，以及 HTTP 的发展历史，以及常见的请求方法和状态码，以及 RESTful API。另外还介绍了 HTTPS 和 WebSocket 以及 QUIC 等新特性。学完本节课，我对 HTTP 协议有了更深入的理解，掌握了其中的常见请求头和响应头，以及常用的状态码，并且了解了 HTTP2，HTTPS，WebSocket，以及 QUIC 等新特性。</p><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP</a></p><p><a href="https://jwt.io/">https://jwt.io/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript ｜ 青训营笔记</title>
      <link href="/2023/01/19/TypeScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/19/TypeScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 4 天</strong></p><h2 id="本堂课重点内容"><a href="#本堂课重点内容" class="headerlink" title="本堂课重点内容"></a>本堂课重点内容</h2><ol><li>TypeScript 定义解析</li><li>TypeScript 基础语法</li></ol><h2 id="详细知识点介绍"><a href="#详细知识点介绍" class="headerlink" title="详细知识点介绍"></a>详细知识点介绍</h2><ol><li>语言特性</li><li>基本数据类型</li></ol><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>JavaScript 是动态类型的语言，而TypeScript顾名思义是静态类型的语言。与js相比，静态类型的特性为ts带来了许多优势</p><ul><li>更强的可读性</li><li>更强的可维护性</li><li>大型项目中提升稳定性</li><li>开发效率</li></ul><p>而作为js的超集，ts兼容所有js特性，且支持与js共存，能够渐进式地引入和升级。</p><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>TypeScript能够在变量名称后面添加冒号和期望的类型来为变量赋予具体的类型，例如下面的代码，常见的类型有 <code>string</code> <code>number</code> <code>boolean</code> <code>null</code> <code>undefined</code></p><pre><code class="ts">let a: string = &quot;string&quot;let b: number = 12let c: boolean = true</code></pre><p>如果在之后尝试给变量赋值不同类型的值，将会产生报错</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>ts使用<code>interface</code>关键字来定义新类型</p><pre><code class="ts">interface ICustomObject &#123;    name: string    age: number    hobby?: string    readonly id: number&#125;const obj: ICustonObject &#123;    name: &quot;hello world&quot;,    age: 12,    hobby: &#39;coding&#39;,    id: 10&#125;</code></pre><p>对于只读属性，可以在类型定义时增加readonly修饰符，在之后倘若修改只读属性，将会报错。在属性名后面紧跟问号表示该属性可选（可能不存在），后续倘若直接读取该属性，将导致报错（需要先判断该属性是否存在）</p><blockquote><p>一般情况下，约定自定义类型以大写字母<code>I</code>开头，例如上面的 <code>ICustomObject</code></p></blockquote><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>在某些情况下，对象的键名（key）可能并不固定，比如我希望某个对象键名是任意string，键值是布尔型，那么可以向下面这样定义</p><pre><code class="ts">interface IObj &#123;    [key: string]: boolean&#125;</code></pre><p>或者使用 <code>type</code> 关键字</p><pre><code class="ts">type IObj = Record&lt;string, boolean&gt;</code></pre><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>假设有一个js函数 <code>add</code></p><pre><code class="js">function add(x, y) &#123;    return x + y&#125;</code></pre><p>为其添加类型声明后</p><pre><code class="ts">function add(x: number, y: number):number &#123;    return x + y&#125;</code></pre><p>对于匿名的箭头函数，我们也可以为其添加类型</p><pre><code class="ts">// jsconst add = (x, y) =&gt; x + y// tsconst add: (x: number, y: number) =&gt; number = (x, y) =&gt; x + y</code></pre><p>或许在某些情况下，将类型和函数写在一起会稍显凌乱，那么我们也可以将函数类型单独定义，例如下面这样</p><pre><code class="ts">interface IAdd &#123;    (x: number, y: number): number&#125;const add: IAdd = (x, y) =&gt; x + y</code></pre><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组的类型定义有很多方法，最常见的是像c语言那样的类型定义</p><pre><code class="ts">type IArray = number[]const array: IArray = [1, 2, 3, 4, 5]</code></pre><p>同样也可以使用ts提供的Array泛型，是一样的效果</p><pre><code class="ts">type IArray = Array&lt;number&gt;const array: IArray = [1, 2, 3, 4, 5]</code></pre><p>因为数组实际上就是键名特殊的对象，所以也可以用表示对象的方法来表示</p><pre><code class="ts">interface IArray &#123;    [key: number]: number&#125;const array: IArray = [1, 2, 3, 4, 5]</code></pre><h3 id="TS-新增的类型"><a href="#TS-新增的类型" class="headerlink" title="TS 新增的类型"></a>TS 新增的类型</h3><p>为了实现一些特殊需求，ts也新增了许多类型方便使用</p><h4 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h4><pre><code class="ts">function test(): void &#123;    alert(&quot;hello&quot;)&#125;</code></pre><p>顾名思义，表示无赋值，例如函数没有返回值</p><h3 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h3><pre><code class="ts">type IArray = Array&lt;any&gt;const array: IArray = [1, &quot;string&quot;, true, &#123;a: 1&#125;]</code></pre><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>该类型能够通过枚举名查枚举值，同时能够使用枚举值查枚举名</p><pre><code class="ts">enum EnumTest &#123;    man = &#39;male&#39;,    woman = &#39;female&#39;,&#125;EnumTest[&#39;man&#39;] === &#39;male&#39;EnumTest[&#39;male&#39;] === &#39;man&#39;</code></pre><p>在不提供枚举名的时候，将默认为由0开始的索引值</p><pre><code class="ts">enum EnumWeekDay &#123; Mon, Tue, Wed, Thu, Fri &#125;EnumTest[&#39;Mon&#39;] === 0EnumTest[&#39;Tue&#39;] === 1</code></pre><h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><h4 id="联合类型与交叉类型"><a href="#联合类型与交叉类型" class="headerlink" title="联合类型与交叉类型"></a>联合类型与交叉类型</h4><p>联合类型： <code>IA | IB</code>;</p><p>交叉类型： <code>IA &amp; IB;</code></p><h4 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h4><p>可以直接通过<code>.type</code>然后拿到某个变量的类型，可用于后续变量类型的判断，达到类型保护的作用。</p><h4 id="补充类型"><a href="#补充类型" class="headerlink" title="补充类型"></a>补充类型</h4><ul><li>空类型，表示无赋值</li><li>任意类型，是所有类型的子类型</li><li>枚举类型：支持枚举值到枚举名的正、反向映射</li></ul><h2 id="课后个人总结"><a href="#课后个人总结" class="headerlink" title="课后个人总结"></a>课后个人总结</h2><p>TypeScript是一个非常有用的语言，给JavaScript开发带来了严格的检查</p><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><p><a href="http://www.typescriptlang.org/docs/">www.typescriptlang.org/docs/</a></p><p><a href="https://bytedance.feishu.cn/file/boxcnIjrYQpF7pL6nWGtTl5W8Jd">https://bytedance.feishu.cn/file/boxcnIjrYQpF7pL6nWGtTl5W8Jd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript ｜ 青训营笔记</title>
      <link href="/2023/01/18/JavaScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/18/JavaScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 3 天</strong></p><h2 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h2><ol><li>编码原则</li><li>组件封装</li><li>过程抽象概念</li><li>高阶函数使用模式</li><li>JavaScript 编程范式</li></ol><h2 id="详细知识点介绍"><a href="#详细知识点介绍" class="headerlink" title="详细知识点介绍"></a>详细知识点介绍</h2><h3 id="编码原则"><a href="#编码原则" class="headerlink" title="编码原则"></a>编码原则</h3><p>各司其职，组件封装，过程抽象</p><p>我们在编码的时候需要注意，尽量让HTML&#x2F;CSS&#x2F;JS各司其职，避免不必要的由JS直接操作样式。</p><h3 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h3><p>组件是指一个包含模板、功能、样式的单元，好的组件具有封装性、正确性、扩展性、复用性。 </p><h3 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h3><p>过程抽象用来处理细节控制的一些方法。 需要函数式编程的思想。</p><p>函数式编程，简单理解就是无副作用的输入-&gt;处理-&gt;输出。</p><p>为了能够让<code>只执行一次</code>的需求覆盖不同的事件处理，我们可以将这个需求剥离出来，这个过程我们称为<code>过程抽象</code>。</p><h3 id="高阶函数（HOF）介绍"><a href="#高阶函数（HOF）介绍" class="headerlink" title="高阶函数（HOF）介绍"></a>高阶函数（HOF）介绍</h3><ul><li><p>以函数作为参数</p></li><li><p>以函数作为返回值</p></li><li><p>常用于作为函数装饰器</p></li></ul><h3 id="常见的高阶函数"><a href="#常见的高阶函数" class="headerlink" title="常见的高阶函数"></a>常见的高阶函数</h3><h4 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h4><p>用于只需要执行一次的函数</p><pre><code class="js">function once(fn) &#123;    return function(...args) &#123;        if(fn) &#123;            const ret = fn.apply(this, args);            fn = null;            return ret;        &#125;    &#125;&#125;</code></pre><p>使用方法：</p><pre><code class="js">const print = (content) =&gt; &#123;    console.log(content)&#125;const printOnce = once(print)printOnce(&quot;1&quot;) // 输出 1printOnce(&quot;2&quot;) // 不输出</code></pre><p>常用于只需要执行一次的的事件侦听器（也可以使用事件侦听器自带的once option，或者手动在执行后移除侦听器）</p><h4 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a>节流（Throttle）</h4><p>如果快速调用函数，那么只有第一次能成功调用函数，之后时间间隔之内的调用会被忽略。常用于滚动条事件&#x2F;瀑布流无限滚动的场景（限制函数调用频率，保证一段时间内函数只调用一次）</p><pre><code class="js">function throttle(fn, time = 500) &#123;    let timer = null;    return function (...args) &#123;        if (timer) return;        fn.apply(this, args);        timer = setTimeout(() =&gt; &#123;            timer = null;        &#125;, time);    &#125;&#125;</code></pre><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>当在时间间隔之内快速调用函数时，函数将始终没法执行，直到停止后，函数才会被执行。常用于一些文本输入的场景（比如搜索框停止输入后，展示联想词；文章编辑器中，输入停止后，进行草稿的保存）。</p><pre><code class="js">function debounce(fn, time = 500) &#123;    let timer = null;    return function (...args) &#123;        if (timer) clearTimeout(timer);        timer = setTimeout(() =&gt; &#123;            fn.apply(this, args);        &#125;, time);    &#125;&#125;</code></pre><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>从名字也很好理解，当快速点击时，函数并不会立刻被调用，而是先将任务推入列表，然后在一定时间后一个一个消费掉。</p><pre><code class="js">function consumer(fn, time = 500) &#123;    let tasks = [];    let timer = null;    return function (...args) &#123;        tasks.push(args);        if (timer) return;        timer = setInterval(() =&gt; &#123;            fn.apply(this, tasks.shift());            if (tasks.length === 0) &#123;                clearInterval(timer);                timer = null;            &#125;        &#125;, time)    &#125;&#125;</code></pre><h4 id="Lterative-可迭代函数"><a href="#Lterative-可迭代函数" class="headerlink" title="Lterative 可迭代函数"></a>Lterative 可迭代函数</h4><h3 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h3><p>命令式与声明式。</p><p>命令式趋向于怎么做。声明式趋向于做什么。</p><p>JS是既有命令式又有声明式。</p><h4 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h4><pre><code class="js">let list =[1,2,3]let map = []for(let i =0;i&lt;list.length;i++)&#123;    map.push(list[i]*2);&#125;</code></pre><h4 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h4><pre><code class="js">let list = [1,2,3,4];const double = x =&gt; x*2;list.map(double);</code></pre><h2 id="实践练习例子"><a href="#实践练习例子" class="headerlink" title="实践练习例子"></a>实践练习例子</h2><p>实现一个只能执行一次的函数：</p><pre><code class="js">// 只执行一次函数const once = (fn) =&gt; &#123;  let done = false;  return function (...args) &#123;    if (!done) &#123;      done = true;      return fn.apply(this, args);    &#125;  &#125;&#125;// 测试const sayHello = (name) =&gt; &#123;  console.log(`Hello $&#123;name&#125;`);&#125;;const sayHelloOnce = once(sayHello);sayHelloOnce(&#39;xiaoming&#39;); // Hello xiaomingsayHelloOnce(&#39;xiaohong&#39;); // undefined</code></pre><h2 id="课后个人总结"><a href="#课后个人总结" class="headerlink" title="课后个人总结"></a>课后个人总结</h2><p>​本次课程让我学到了很多有关编程原则、组件封装、过程抽象概念、高阶函数使用模式以及JavaScript编程范式的知识，收获很大。 </p><p>​对于高阶函数，过去只是略有了解，现在能够真正去理解它们是什么，以及它们的用处如何。</p><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><p><a href="https://bytedance.feishu.cn/file/boxcnxKucsHPvnJ7PfXyCQF5WCd">https://bytedance.feishu.cn/file/boxcnxKucsHPvnJ7PfXyCQF5WCd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入CSS ｜ 青训营笔记</title>
      <link href="/2023/01/17/%E6%B7%B1%E5%85%A5CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/17/%E6%B7%B1%E5%85%A5CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 2 天</strong></p><h2 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h2><ol><li>选择器的特异度</li><li>属性的继承</li><li>Layout 方式</li><li>盒子模型</li><li>块级元素和行级元素</li><li>flex</li><li>grid</li><li>float</li><li>position</li></ol><h2 id="详细知识点介绍："><a href="#详细知识点介绍：" class="headerlink" title="详细知识点介绍："></a>详细知识点介绍：</h2><h3 id="1-选择器的特异度（Specificity）"><a href="#1-选择器的特异度（Specificity）" class="headerlink" title="1. 选择器的特异度（Specificity）"></a>1. 选择器的特异度（Specificity）</h3><p>即 CSS 选择器的<strong>优先级</strong>，当一个元素能够匹配多个样式时，浏览器会根据优先级为元素赋予正确的样式。</p><p>一般情况下，ID选择器优先级最高，其次是类选择器&#x2F;属性选择器&#x2F;伪类，优先级最低的是类型选择器和伪元素选择器。不同选择器的叠加也会改变优先级。<code>!important</code> 的样式会覆盖其他样式。</p><p>在 <code>VSCode</code> 中，鼠标悬浮在选择器上是，能实时看到选择器的优先级数值</p><p>id选择器 大于 类选择器 大于 标签选择器</p><h3 id="2-CSS-属性的继承"><a href="#2-CSS-属性的继承" class="headerlink" title="2. CSS 属性的继承"></a>2. CSS 属性的继承</h3><p>某些属性会自动继承其父元素的计算值除非显式指定一个值</p><p>不同的 CSS 属性有着不同的继承规则。对于一个能够被继承的样式属性，子元素能够从父元素继承相同的属性值，而不需要额外的设置。当然，对于一个默认不继承的样式，也可以通过将其值设置为<code>inherit</code>来强制从父元素继承。</p><p>初始值：CSS 中，每个属性都有一个初始值 <code>background-color</code> 的初始值为 <code>transparent</code><br><code>margin-left</code> 的初始值为 0<br>可以使用 <code>initial</code> 关键字显式重置为初始值<br><code>background-color: initial</code></p><h3 id="3-CSS-布局方式"><a href="#3-CSS-布局方式" class="headerlink" title="3. CSS 布局方式"></a>3. CSS 布局方式</h3><p>CSS 存在许多种布局方式。总体上分为三类：常规流&#x2F;文档流、浮动、绝对定位。其中，在正常的文档流中，又可以细分出很多布局方式，例如行级、块级、表格布局、弹性布局（flex）、网格布局（grid）</p><p>盒子模型：<code>margin</code> <code>border</code> <code>padding</code></p><h3 id="4-CSS-盒子模型"><a href="#4-CSS-盒子模型" class="headerlink" title="4. CSS 盒子模型"></a>4. CSS 盒子模型</h3><p>width: content box 的宽度</p><p>height: content box 的高度</p><p>padding: 元素内边距，百分比相对于<strong>元素宽度</strong></p><p>border: 元素的边框样式、粗细和颜色</p><p>margin: 元素外边距，百分比相对于<strong>元素宽度</strong></p><p>当 box-sizing 取值为 border-box 时，模型会发生相应变化。</p><h3 id="5-块级元素"><a href="#5-块级元素" class="headerlink" title="5. 块级元素"></a>5. 块级元素</h3><p>即 <code>display</code> 属性值为 <code>block</code> 的元素。例如 <code>body</code>、<code>article</code>、<code>div</code>、<code>main</code>、<code>section</code>、<code>p</code>、<code>h1</code>~&#96;h6<code>、</code>ul<code>/</code>ol<code>、</code>li&#96; 等</p><h3 id="行级元素"><a href="#行级元素" class="headerlink" title="行级元素"></a>行级元素</h3><p>即 <code>display</code> 属性值为 <code>inline</code> 的元素。</p><h3 id="6-flex"><a href="#6-flex" class="headerlink" title="6. flex"></a>6. flex</h3><p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>2009年，W3C提出了一种新的方案—Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性.</p><pre><code class="css">.box&#123;  display: flex;&#125;</code></pre><p>任何一个容器都可以指定为Flex布局。</p><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><pre><code class="css">.box &#123;  flex-direction: row | row-reverse | column | column-reverse;&#125;</code></pre><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><h3 id="7-grid"><a href="#7-grid" class="headerlink" title="7. grid"></a>7. grid</h3><p>网格是一组相交的水平线和垂直线，它定义了网格的列和行。</p><p>CSS 提供了一个基于网格的布局系统，带有行和列，可以让我们更轻松地设计网页，而无需使用浮动和定位。</p><p>当一个 HTML 元素将 display 属性设置为 grid 或 inline-grid 后，它就变成了一个网格容器，这个元素的所有直系子元素将成为网格元素。</p><pre><code class="css">grid: none;grid: &quot;a&quot; 100px &quot;b&quot; 1fr;grid: [linename1] &quot;a&quot; 100px [linename2];grid: &quot;a&quot; 200px &quot;b&quot; min-content;grid: &quot;a&quot; minmax(100px, max-content) &quot;b&quot; 20%;grid: 100px / 200px;grid: minmax(400px, min-content) / repeat(auto-fill, 50px);grid: 200px / auto-flow;grid: 30% / auto-flow dense;grid: repeat(3, [line1 line2 line3] 200px) / auto-flow 300px;grid: [line1] minmax(20em, max-content) / auto-flow dense 40%;grid: auto-flow / 200px;grid: auto-flow dense / 30%;grid: auto-flow 300px / repeat(3, [line1 line2 line3] 200px);grid: auto-flow dense 40% / [line1] minmax(20em, max-content);grid: inherit;grid: initial;grid: unset;</code></pre><p>我们通过 <strong>grid-template-columns</strong> 和 <strong>grid-template-rows</strong> 属性来定义网格中的行和列。</p><p>这些属性定义了网格的轨道，一个网格轨道就是网格中任意两条线之间的空间。</p><p>在下图中你可以看到一个绿色框的轨道——网格的第一个行轨道。第二行有三个白色框轨道。</p><p>轨道可以使用任何长度单位进行定义。</p><p>网格引入了 <strong>fr</strong> 单位来帮助我们创建灵活的网格轨道。一个 fr 单位代表网格容器中可用空间的一等份。</p><p>以下实例定义了一个网格定义将创建三个相等宽度的轨道，这些轨道会随着可用空间增长和收缩。</p><p>一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。现在再看回我们前面的一个例子, 一旦一个网格元素被定义在一个父级元素当中，那么他的子级元素将会排列在每个事先定义好的网格单元中。</p><p>列与列，行与行之间的交接处就是网格线。</p><p>Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素。</p><pre><code class="css">#container &#123;  display: grid;  grid: repeat(2, 60px) / auto-flow 80px;&#125;#container &gt; div &#123;  background-color: #8ca0ff;  width: 50px;  height: 50px;&#125;</code></pre><p>网格线的编号顺序取决于文章的书写模式。在从左至右书写的语言中，编号为 1 的网格线位于最左边。在从右至左书写的语言中，编号为 1 的网格线位于最右边。</p><p>接下来我使用了 grid-column-start, grid-column-end, grid-row-start 和 grid-row-end 属性来演示如何使用网格线。</p><p>以下实例我们设置一个网格元素的网格线从第一列开始，第三列结束：</p><pre><code class="css">.item1 &#123;  grid-column-start: 1;  grid-column-end: 3;&#125;</code></pre><p><a href="https://www.runoob.com/try/gridgarden/index.html">https://www.runoob.com/try/gridgarden/index.html</a></p><p>菜鸟教程的grid布局小游戏</p><h2 id="实践练习例子："><a href="#实践练习例子：" class="headerlink" title="实践练习例子："></a>实践练习例子：</h2><h3 id="特异度相关例子"><a href="#特异度相关例子" class="headerlink" title="特异度相关例子"></a>特异度相关例子</h3><p>下面的文字是什么颜色？</p><pre><code class="html">&lt;div class=&quot;wrapper1&quot;&gt;  &lt;div class=&quot;text1&quot;&gt;文本1&lt;/div&gt;&lt;/div&gt;&lt;style&gt;  .wrapper1 .text1 &#123;    color: red;  &#125;    .text1 &#123;    color: black;  &#125;&lt;/style&gt;</code></pre><p>正确答案是红色</p><p>虽然黑色的属性声明在后面，理应覆盖掉前面的红色，但是前面是两个类选择器的叠加，优先级是 <code>0, 2, 0</code> ，后者只有一个类选择器，优先级是 <code>0, 1, 0</code>，所以最终浏览器应用了红色。</p><h2 id="课后个人总结："><a href="#课后个人总结：" class="headerlink" title="课后个人总结："></a>课后个人总结：</h2><p>本节课中，我学习了CSS中特异度、属性继承、布局方式、盒子模型、块级元素和行级元素、flex、grid等概念，掌握了相关的知识和应用。 特异度是CSS中最重要的概念之一，让我们明白当一个元素能够匹配多个样式时，浏览器会根据优先级为元素赋予正确的样式。</p><p>属性的继承也是重要的概念，它会依赖于不同的CSS属性，有了它，我们可以让HTML元素的样式可以从父元素继承。</p><p>我们还学习了CSS中的布局方式，包括常规流&#x2F;文档流、浮动、绝对定位等，以及flex、grid等网格布局。</p><p>熟练掌握这些知识，我们可以更好的制作网页，满足各种布局的需求。</p><h2 id="引用参考："><a href="#引用参考：" class="headerlink" title="引用参考："></a>引用参考：</h2><p>课程ppt</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid">https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端与 HTML ｜ 青训营笔记</title>
      <link href="/2023/01/16/%E5%89%8D%E7%AB%AF%E4%B8%8E%20HTML%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/16/%E5%89%8D%E7%AB%AF%E4%B8%8E%20HTML%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 1 天</strong></p><h2 id="本堂课重点内容："><a href="#本堂课重点内容：" class="headerlink" title="本堂课重点内容："></a>本堂课重点内容：</h2><ol><li>前端的介绍</li><li>HTML 标签的简单介绍</li><li>HTML 语义化</li></ol><h2 id="详细知识点介绍："><a href="#详细知识点介绍：" class="headerlink" title="详细知识点介绍："></a>详细知识点介绍：</h2><ol><li>前端技术栈</li><li>前端的边界、开发环境（ide、浏览器）</li><li>DOM 树的简单介绍</li><li>HTML 语法简单介绍</li><li>各类常用标签（h1-h5、p、form、a）</li><li>常见的语义化标签（main&#x2F;footer&#x2F;section）</li><li>语义化的优势</li></ol><h2 id="实践练习例子："><a href="#实践练习例子：" class="headerlink" title="实践练习例子："></a>实践练习例子：</h2><h3 id="1-标题元素"><a href="#1-标题元素" class="headerlink" title="1. 标题元素"></a>1. 标题元素</h3><p>使用 <code>h1</code>~&#96;h6&#96; 标签将标题文本包裹，标题会根据级别拥有默认的字重、字号和外边距。</p><pre><code class="html">&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt;</code></pre><h3 id="2-图片元素"><a href="#2-图片元素" class="headerlink" title="2. 图片元素"></a>2. 图片元素</h3><p>使用 <code>src</code> 属性来确定图片链接，<code>alt</code> 属性用于表示图片无法显示时的替代文本</p><pre><code class="html">&lt;img src=&quot;https://example.com/image&quot; /&gt;&lt;img src=&quot;https://example.com&quot; alt=&quot;显示不出来的图片&quot; /&gt;</code></pre><h3 id="3-单选框"><a href="#3-单选框" class="headerlink" title="3. 单选框"></a>3. 单选框</h3><p><code>radio</code> 类型的 <code>input</code> 元素，相同 <code>name</code> 的单选框会归为同一组（只能选其中一个） 使用 <code>label</code> 标签来标识单选框的内容</p><pre><code class="html">&lt;input type=&quot;radio&quot; id=&quot;el1&quot; name=&quot;group1&quot; /&gt;&lt;label for=&quot;el1&quot;&gt;第一组-选项1&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;el2&quot; name=&quot;group1&quot; /&gt;&lt;label for=&quot;el2&quot;&gt;第一组-选项1&lt;/label&gt;&lt;br&gt;&lt;input type=&quot;radio&quot; id=&quot;el3&quot; name=&quot;group2&quot; /&gt;&lt;label for=&quot;el3&quot;&gt;第二组-选项1&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;el4&quot; name=&quot;group2&quot; /&gt;&lt;label for=&quot;el4&quot;&gt;第二组-选项2&lt;/label&gt;</code></pre><h3 id="4-超链接"><a href="#4-超链接" class="headerlink" title="4. 超链接"></a>4. 超链接</h3><p>使用 <code>a</code> 标签包裹文本，<code>href</code> 属性是目标链接，默认在当前页面打开，为了在新标签页打开，可以将 <code>target</code> 属性设置为 <code>_blank</code></p><pre><code class="html">&lt;a href=&quot;https://example.com&quot;&gt;在当前页面打开&lt;/a&gt;&lt;a href=&quot;https://example.com&quot; target=&quot;_blank&quot;&gt;在新页面打开&lt;/a&gt;</code></pre><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>最外层使用 <code>ol</code>标签包裹，内部包含多个 <code>li</code> 标签</p><pre><code class="html">&lt;ol&gt;    &lt;li&gt;第一&lt;/li&gt;    &lt;li&gt;第二&lt;/li&gt;    &lt;li&gt;&lt;em&gt;第三&lt;/em&gt;&lt;/li&gt;&lt;/ol&gt;</code></pre><h3 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6. 无序列表"></a>6. 无序列表</h3><p>最外层使用 <code>ul</code>标签包裹，内部包含多个 <code>li</code>标签</p><pre><code class="html">&lt;ul&gt;    &lt;li&gt;第一&lt;/li&gt;    &lt;li&gt;第二&lt;/li&gt;    &lt;li&gt;&lt;em&gt;第三&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="课后个人总结："><a href="#课后个人总结：" class="headerlink" title="课后个人总结："></a>课后个人总结：</h3><p>本节课主要介绍了前端的技术栈，以及 HTML 标签的简单介绍和 HTML 语义化，通过本节课的学习，我对 HTML 标签有了一定的了解，掌握了如何使用标签来表达页面元素，并且学习了如何使用语义化标签来提高前端代码的可读性，以及提升代码的可维护性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP3初体验 ｜ 青训营笔记</title>
      <link href="/2023/01/11/HTTP3%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/11/HTTP3%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-x2F-3试水"><a href="#HTTP-x2F-3试水" class="headerlink" title="HTTP&#x2F;3试水"></a>HTTP&#x2F;3试水</h2><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>小看一眼，发现全是编译啥的。应该会踩很多坑的，这次用国外没东西的小1h512M服务器试水一下。<br>目前cloudflare给出了一键开启http3。很好用，我在netlify托管的网页一键开开了。<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230111221046.png" alt="1"><br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230111221121.png" alt="2"></p><h3 id="II"><a href="#II" class="headerlink" title="II"></a>II</h3><p>现在要编译安装一个nginx，用的是<a href="https://github.com/cloudflare/quiche">https://github.com/cloudflare/quiche</a>方案。<br><a href="https://github.com/cloudflare/quiche/tree/master/nginx">https://github.com/cloudflare/quiche/tree/master/nginx</a>处理nginx的教程在这里，一步步跟上</p><pre><code class="bash">  curl -O https://nginx.org/download/nginx-1.16.1.tar.gz  tar xzvf nginx-1.16.1.tar.gz  git clone --recursive https://github.com/cloudflare/quiche  cd nginx-1.16.1  patch -p01 &lt; ../quiche/nginx/nginx-1.16.patch</code></pre><p>在之前要apt upgrade一下避免有装不上的东西<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230111221522.png" alt="3"><br>外网服务器下的就是快😎<br>要编译了发现cmake没有  装个cmake先<br><code>apt install cmake</code></p><p>gcc g++也没有 装个</p><p>接下来</p><pre><code class="bash">  ./configure                                 \       --prefix=$PWD                           \       --build=&quot;quiche-$(git --git-dir=../quiche/.git rev-parse --short HEAD)&quot; \       --with-http_ssl_module                  \       --with-http_v2_module                   \       --with-http_v3_module                   \       --with-openssl=../quiche/quiche/deps/boringssl \       --with-quiche=../quiche  make</code></pre><p>nginx configure 时候报错，<br><code>the HTTP rewrite module requires the PCRE library.</code><br>搜了 装这个 <code>apt install libpcre3 libpcre3-dev</code></p><p><code>the HTTP gzip module requires the zlib library</code><br>搜了 装这个 <code>apt install zlib1g-dev</code></p><p>又error 没有cargo 装个<br><code>apt install cargo</code></p><p>make好了</p><pre><code class="bash">nginx -V</code></pre><p>装是装好了 好像要一个https证书啊<br>acme签一个<br><code>https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E</code></p><pre><code class="conf">events &#123;    worker_connections  1024;&#125;http &#123;    server &#123;        # Enable QUIC and HTTP/3.        listen 443 quic reuseport;        # Enable HTTP/2 (optional).        listen 443 ssl http2;        ssl_certificate      cert.crt;        ssl_certificate_key  cert.key;        # Enable all TLS versions (TLSv1.3 is required for QUIC).        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;        # Add Alt-Svc header to negotiate HTTP/3.        add_header alt-svc &#39;h3=&quot;:443&quot;; ma=86400&#39;;    &#125;&#125;</code></pre><p>签证书签了半天 签好了 放在</p><pre><code class="bash">        ssl_certificate      cert.crt;        ssl_certificate_key  cert.key;</code></pre><p>里面<br>配置好nginx 注意网站不要在root下<br>在root下nginx访问不到直接403了<br>建一个<code>/www/wwwroot/domin</code>文件夹放东西</p><h3 id="III"><a href="#III" class="headerlink" title="III"></a>III</h3><p>最后配置结果是这样滴</p><h4 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h4><p><a href="https://geekflare.com/tools/test/yn22t29e04y7v0u5jl61mcark2dwxmbn">https://geekflare.com/tools/test/yn22t29e04y7v0u5jl61mcark2dwxmbn</a><br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230112004019.png" alt="6"><br>这个网站会检测什么h3-xxx的版本协议 （看不懂，看懂了在写一篇<br>你没有这个版本号的协议这个网站就检测不出来好像 在这里改就行<br><code>add_header alt-svc &#39;h3=&quot;:443&quot;; ma=86400&#39;;</code><br>我加了版本号114514🤓<br><code>add_header alt-svc h3=&quot;:443&quot;; ma=86400; h3-114514=&quot;:443&quot;; ma=86400</code><br>上面这个好像就检测这个alt-svc这个头</p><h4 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h4><p><a href="https://http3check.net/?host=http3.typescriptactions.xyz">https://http3check.net/?host=http3.typescriptactions.xyz</a><br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230112004253.png" alt="7"><br>这个就很正常了 不加版本直接检测h3的</p><h4 id="第三个"><a href="#第三个" class="headerlink" title="第三个"></a>第三个</h4><p>然后是wappalyzer插件<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230112004611.png" alt="8"></p><h4 id="第四个"><a href="#第四个" class="headerlink" title="第四个"></a>第四个</h4><p>然后是浏览器devtools的协议检查<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230112004854.png" alt="9"></p><h3 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h3><p>总结一下<br>2023-1-11 21:57:32 开始的<br>2023-1-12 00:53:12 写完这篇<br>🤥感觉没啥可总结的 国外服务器也测不了http3优势啥的<br>下班！睡觉！😝</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青训营笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/22/java_crud%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
      <url>/2022/10/22/java_crud%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java-crud环境配置教程"><a href="#java-crud环境配置教程" class="headerlink" title="java_crud环境配置教程"></a>java_crud环境配置教程</h1><p>本文会从安装开始，到最后写出一个带命令行交互窗口的CRUD的小项目.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p><a href="https://www.oracle.com/java/technologies/downloads/#jdk17-windows">安装地址</a></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221643.png"></p><p> 建议下载java17以防止有依赖问题</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221712.png"></p><p>点击这个下载<code>.msi</code>安装包来安装</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221734.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221748.png"></p><p>这里建议不要更改<strong>默认位置</strong></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221802.png"></p><p>安装完成🥳</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>在<code>Windows开始菜单</code>搜索<code>环境变量</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221840.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221858.png"></p><p>在系统环境变量下面点击新建</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221915.png"></p><p>变量名设置为 <code>JAVA_HOME</code></p><p>变量值设置为 <code>C:\Program Files\Java\jdk-17.0.4.1</code> 如果你有安装到其他目录请填其他目录</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221927.png"></p><p>新建环境变量 <code>CLASS_PATH</code> </p><p>变量值为 <code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></p><p>如下图所示</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929221948.png"></p><p>注意 变量值比较奇怪 可能理解不能  但是要照上填写</p><p>在系统变量里找到<code>path</code> 双击</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222004.png"></p><p>点击新建  值填写</p><p><code>%JAVA_HOME%\bin</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222021.png"></p><p>点击确定</p><p>接下来按 Windows键加R键  输入cmd点确定</p><p>在命令行里输入<code>java --version</code></p><p>如有正常不报错则配置成功🥳</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222038.png"></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p><a href="https://downloads.mysql.com/archives/installer/">MySQL :: Download MySQL Installer (Archived Versions)</a></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222056.png"></p><p>双击打开</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222109.png"></p><p>选default</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222120.png"></p><p>直接next</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222134.png"></p><p>yes</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222149.png"></p><p>Execute</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222201.png"></p><p>一路next</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222212.png"></p><p>设一个密码</p><p>然后一路next</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222223.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222238.png"></p><p>点check</p><p>点next</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929222255.png"></p><p>最后会跳出这么一个奇奇怪怪的 MySQL JS 的命令行 （说实话我没懂为什么有这玩意</p><p>（不过你可以在上面玩玩 JS 的特性   ：）</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929230157.png"></p><p>和命令行同时弹出来的是workbench </p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929230229.png"></p><p>MySQL已安装完成🥳</p><h2 id="安装-JetBrain-IntelliJ-IDEA"><a href="#安装-JetBrain-IntelliJ-IDEA" class="headerlink" title="安装 JetBrain IntelliJ IDEA"></a>安装 JetBrain IntelliJ IDEA</h2><p><a href="https://www.jetbrains.com/zh-cn/idea/">下载地址</a></p><p>直接下载咯 0配置的</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929230750.png"></p><p>新建项目</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929230914.png"></p><p>创建配置如图所示</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231039.png"></p><p>点进 <code>src/main/java/org/example/main</code>运行一下试试</p><h2 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231348.png"></p><p>点击编辑配置</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231437.png"></p><p>新建一个Maven配置</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231601.png"></p><p>配置如图 保存应用</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231748.png"></p><p>点击运行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231717.png"></p><p>build成功后会生成一个snapshot的jar</p><p>接下来是安装maven依赖项</p><p>打开pom.xml 右键点生成</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231903.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929231942.png"></p><p>搜索 mysql-connector 添加这个8版本的依赖</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929232035.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220930000633.png"></p><p>生成了如图的代码则成功</p><p>在与 dependencies 同级的标签下面 添加如下代码 配置maven依赖自动安装</p><pre><code class="xml"> &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;phase&gt;package&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;single&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;configuration&gt;                    &lt;descriptorRefs&gt;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                    &lt;/descriptorRefs&gt;                    &lt;archive&gt;                        &lt;manifest&gt;                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;                            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;                            &lt;mainClass&gt;org.example.Main&lt;/mainClass&gt;                        &lt;/manifest&gt;                    &lt;/archive&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>点击右上角 <img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929232533.png"> 重新加载maven变更</p><h2 id="加载数据库-amp-amp-创建数据表"><a href="#加载数据库-amp-amp-创建数据表" class="headerlink" title="加载数据库&amp;&amp;创建数据表"></a>加载数据库&amp;&amp;创建数据表</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929232829.png"></p><p>在右边的侧边栏中找到数据库  添加一个MySQL</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233002.png"></p><p>输入你刚设置的账号密码连接</p><p>弹出一个console</p><p>在里面输入</p><pre><code class="sql">CREATE DATABASE `java_crud_demo` CHARACTER SET &#39;utf8mb4&#39; COLLATE &#39;utf8mb4_general_ci&#39;;</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233123.png"></p><p>绿色框内是idea识别出来的sql语句  点击左上绿色箭头执行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233231.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233308.png"></p><p>右侧数据库栏里会出现你刚创建的数据库 但是里面没有表</p><p>在console里输入</p><pre><code class="sql">create table if not exists `java_crud_demo`.`article_table`(    id     int unsigned auto_increment        primary key,    title  varchar(100) not null,    author varchar(40)  not null,    time   datetime     null);</code></pre><p>ctrl + a 全选中 然后点执行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929233643.png"></p><p>生成了表article_table 里面没有数据</p><p>简单的填充数据 可以 console输入</p><pre><code class="sql">INSERT INTO `java_crud_demo`.`article_table` (`title`, `author`, `time`)VALUES (&#39;标题&#39;, &#39;作者&#39;, NOW());</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929234014.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220929234049.png"></p><p>插入完了记得点这个刷新</p><p>也可以直接在table预览界面</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220930000521.png"></p><p>添加行 输入完毕后 点提交</p><h2 id="数据库crud模板"><a href="#数据库crud模板" class="headerlink" title="数据库crud模板"></a>数据库crud模板</h2><p>新建一个crud.java</p><pre><code class="java">package org.example;import java.sql.*;public class Crud &#123;    // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL    //static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;    //static final String DB_URL = &quot;jdbc:mysql://localhost:3306/java_crud_demo&quot;;    // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL    static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;    static final String DB_URL = &quot;jdbc:mysql://localhost:3306/java_crud_demo?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;;    // 数据库的用户名与密码，需要根据自己的设置    static final String USER = &quot;root&quot;;    static final String PASS = &quot;123456&quot;;    public static void main(String[] args) &#123;        Connection conn = null;        Statement stmt = null;        try&#123;            // 注册 JDBC 驱动            Class.forName(JDBC_DRIVER);            // 打开链接            System.out.println(&quot;连接数据库...&quot;);            conn = DriverManager.getConnection(DB_URL,USER,PASS);            // 执行查询            System.out.println(&quot; 实例化Statement对象...&quot;);            stmt = conn.createStatement();            String sql;            sql = &quot;SELECT id, title, author, time FROM java_crud_demo&quot;;            ResultSet rs = stmt.executeQuery(sql);            // 展开结果集数据库            while(rs.next())&#123;                // 通过字段检索                int id  = rs.getInt(&quot;id&quot;);                String title = rs.getString(&quot;title&quot;);                String author = rs.getString(&quot;author&quot;);                String time = rs.getString(&quot;time&quot;);                // 输出数据                System.out.println(&quot;ID: &quot; + id);                System.out.println(&quot;标题：&quot; + title);                System.out.println(&quot;作者：&quot; + author);                System.out.println(&quot;时间：&quot; + time);            &#125;            // 完成后关闭            rs.close();            stmt.close();            conn.close();        &#125;catch(SQLException se)&#123;            // 处理 JDBC 错误            se.printStackTrace();        &#125;catch(Exception e)&#123;            // 处理 Class.forName 错误            e.printStackTrace();        &#125;finally&#123;            // 关闭资源            try&#123;                if(stmt!=null) stmt.close();            &#125;catch(SQLException se2)&#123;            &#125;// 什么都不做            try&#123;                if(conn!=null) conn.close();            &#125;catch(SQLException se)&#123;                se.printStackTrace();            &#125;        &#125;        System.out.println(&quot;Goodbye!&quot;);    &#125;&#125;</code></pre><p>接下来愉快写你的代码主逻辑咯🥳</p><h2 id="双击打开jar"><a href="#双击打开jar" class="headerlink" title="双击打开jar"></a>双击打开jar</h2><pre><code class="java">package org.example;import java.io.File;public class Main &#123;    public static void main(String[] args) &#123;        if (args.length == 0) &#123;            try &#123;                String path = System.getProperty(&quot;java.class.path&quot;);                int lastIndex = path.lastIndexOf(File.separator) + 1;                String file_name = path.substring(lastIndex);                ProcessBuilder pb = new ProcessBuilder();                pb.directory(new File(&quot;.&quot;));                System.out.printf(&quot;%s %s %s %s %s %s %s&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;start&quot;, &quot;java&quot;, &quot;-jar&quot;, file_name, &quot;eject&quot;);                        pb.command(&quot;cmd&quot;, &quot;/c&quot;, &quot;start&quot;, &quot;java&quot;, &quot;-jar&quot;, file_name, &quot;eject&quot;);                pb.start();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125; finally &#123;                System.exit(0);            &#125;        &#125;        else &#123;            //主函数            System.out.println(&quot;Hello World!&quot;);        &#125;    &#125;    &#125;</code></pre><p>在main开头加上这样一段 他会帮你输入命令来打开一个弹出的新窗口啦🥳</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>Maven 构建之后就得到了需要的jar包了🥳</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>抢红包获奖感言🤗</title>
      <link href="/2022/09/19/%E8%8E%B7%E5%A5%96%E6%84%9F%E8%A8%80/"/>
      <url>/2022/09/19/%E8%8E%B7%E5%A5%96%E6%84%9F%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h3 id="呃呃，呃呃呃呃呃呃"><a href="#呃呃，呃呃呃呃呃呃" class="headerlink" title="呃呃，呃呃呃呃呃呃"></a>呃呃，呃呃呃呃呃呃</h3><p>首先恭喜TS的小号<code>TypeScript Actions Bot</code>在8月8号晚上的抢红包大赛中荣获金奖。<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220808210816.png" style="width:30%"></p><h4 id="一共抢到了113-87CNY"><a href="#一共抢到了113-87CNY" class="headerlink" title="一共抢到了113.87CNY"></a>一共抢到了<code>113.87CNY</code></h4><p><code>13.87CNY</code>吐出去了（就给你吐个零头略略略😋）</p><p>首先自证一下没有开挂</p><pre><code class="JSON">&#123;    &quot;message&quot;: &#123;        &quot;id&quot;: &quot;08a0a3dd95ddf1ca1f10c7cea8041a123134343131353231383738373537343636362081e2800308bfef5cba2fdcb8f0138f78d0140f38d0148d4cdc39706&quot;,        &quot;channel_id&quot;: &quot;9054023&quot;,        &quot;guild_id&quot;: &quot;17780811658383776&quot;,        &quot;content&quot;: &quot;[QQ红包]请使用新版手机QQ查收红包。&quot;,        &quot;timestamp&quot;: &quot;2022-08-08T18:35:00+08:00&quot;,        &quot;author&quot;: &#123;            &quot;id&quot;: &quot;14411521877574666&quot;,            &quot;username&quot;: &quot;Ljcbaby&quot;,            &quot;bot&quot;: false        &#125;,        &quot;member&quot;: &#123;            &quot;roles&quot;: [                &quot;2&quot;            ],            &quot;joined_at&quot;: &quot;2022-07-21T14:09:37+08:00&quot;        &#125;    &#125;&#125;</code></pre><p><strong>以上</strong>为<code>TSA</code>能获取到的关于该条红包消息的全部内容<br>呃呃 显然开不了<br>我不知道野频道机器人怎么个返回格式 (<code>TSA</code>是官方的<code>PythonSDK</code>)<br>抢红包全靠手速捏 看看你的单身19年手速捏（没单身的别叫😡）</p><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><p>此次资金会用于TS大号的灾后重建。<br>呃呃 简述一下TS怎么死的<br>TS在八月二号晚和大伙一起期待某个人下飞机，而且给大伙直播，但是直播中出现了呃呃呃呃呃呃呃呃呃呃呃（政）之类的内容，然后就如下图所示↓<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20220808205137.png" style="width:30%"><br>😭TS大号有2个780天左右的火，2个630天左右的火，一个330天的。<br>呃呃呃全掉没了，tx开通svip两个月可以续活一个火，两个月是nm40块钱👿👿👿👿👿👿👿👿我真的气死了👿👿👿👿</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>呃最后非常感谢卢佬和烧鸡哥😍富哥😍😍😍😍<br>卢佬说<code>工资到了就是硬气</code>直接发了3个88我哭死😭</p><p>呃呃呃刻晴还没穿呢 再拖会儿再拖会儿🤗</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《大学生与法》案例分析</title>
      <link href="/2022/09/19/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
      <url>/2022/09/19/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="《大学生与法》写出生活中的法律案例并加以分析。"><a href="#《大学生与法》写出生活中的法律案例并加以分析。" class="headerlink" title="《大学生与法》写出生活中的法律案例并加以分析。"></a>《大学生与法》写出生活中的法律案例并加以分析。</h3><h2 id="来福士母女"><a href="#来福士母女" class="headerlink" title="来福士母女"></a>来福士母女</h2><h3 id="案例详情："><a href="#案例详情：" class="headerlink" title="案例详情："></a>案例详情：</h3><ul><li>母女隐瞒行程从沪来杭被立案，波及多家商场。</li><li>4月6日13:18，杭州市新冠肺炎疫情防控指挥部发布消息，4月5日，宁某某、党某某从省外疫情中高风险地区来杭，接受防疫工作人员调查期间刻意隐瞒行程，造成社会面传播风险，已被上城区公安分局依法立案调查。</li><li>网上有一段昨晚来福士皮爷咖啡店的现场视频，白大褂正在与两名坐在店门口的女子对话，其中一名身穿黑色上衣、没有戴口罩的女子<strong>面带笑容</strong>。</li><li>从地铁里的监控画面中可以看到，身穿同款黑色上衣的女子在人流密集的封闭区域<strong>没有规范戴好口罩</strong>，口鼻均露在外面，只有在被提醒的情况下，<strong>才</strong>把口罩拉上。</li><li>有消息说，她们以<strong>没有健康码</strong>为由，<strong>避开了</strong>验码环节，但签署了承诺书，不过，显然她们的“承诺”<strong>并不真实</strong>，这也是认定她们是否存在“<strong>刻意隐瞒</strong>”情节的重要因素之一。</li></ul><h3 id="涉及杭州市范围内的公共场所如下："><a href="#涉及杭州市范围内的公共场所如下：" class="headerlink" title="涉及杭州市范围内的公共场所如下："></a>涉及杭州市范围内的公共场所如下：</h3><ul><li><p>4月5日，K1805次列车（2号车厢，无座）。</p></li><li><p>4月5日，6时35分、9时25分分别进入铁道大厦负一楼核酸检测点附近公厕（女厕），7时31分进入城站广场平价超市，7时37分进入城站广场世纪华联超市，10时09分进入1号线城站地铁站，经近江地铁站转4号线至江锦路地铁站，于11时12分出站，11时17分进入杭州万象城（上城区富春路），11时40分-21时在杭州来福士中心（上城区新业路）。</p></li><li><p>两人4月5日早上4时左右从上海出发，6时30分左右到达杭州站，出站后，上了一趟卫生间，购买早点并在出站层吃，吃完后乘坐地铁去万象城闲逛十几分钟后，中午来到来福士，购物、吃饭，并在咖啡店休息。</p></li><li><p>二人必然刻意隐瞒了一些真实情况才能从上海一路闯关来到杭州。</p><p>根据通报，宁某某两人在来福士<strong>逗留</strong>了<strong>9个小时</strong>。</p></li></ul><h3 id="资料查询"><a href="#资料查询" class="headerlink" title="资料查询"></a>资料查询</h3><ul><li><strong>不知道感染，但刻意隐瞒行程，要负法律责任吗？</strong></li></ul><p><strong>隐瞒</strong>或<strong>谎称</strong>病情、居住史、行踪轨迹等，这些隐瞒行为在法律上是可以被认定为<strong>拒绝疫情防控措施行为</strong>的。</p><p>这些客观上的行为，如果达到“<strong>引起甲类传染病传播或者有传播严重危险</strong>”的程度，<strong>如造成多人被确诊为新冠肺炎病人</strong>，那视具体情节及行为后果，是可以认定为<strong>妨害传染病防治罪</strong>的。</p><p>上海二人的行为能否以“以危险方法危害公共安全罪”进行定罪处罚，从法律上需要明确三个事实：其一，在主体上二人是否已经属于已确诊的新冠肺炎病人、病原携带者或者新冠肺炎疑似病人；其二，在主观上二人是否具有传播新冠肺炎病原体的故意；其三，在客观上需满足拒绝隔离治疗或者隔离期未满擅自脱离隔离治疗，且实施了进入公共场所或者公共交通工具的行为。</p><p>如果行为人不知道自己存在阳性感染，而仅是隐瞒从疫情高发地区（上海）的旅居史或行踪轨迹，在未造成严重危害后果的情况下，即使无法构成相关涉疫犯罪，也属妨害疫情防控的违法行为，可予以治安处罚。</p><ul><li><strong>明知已感染，仍隐瞒潜入杭州，要面临怎样的法律后果？</strong></li></ul><p>如果相关行为人明知自身已经确诊为新冠肺炎病人或者疑似病人，是出于报复社会等主观故意，恶意向不特定多数人传播病毒，后果严重、情节恶劣的，将涉嫌以危险方法危害公共安全罪。</p><p>根据刑法第一百一十四条规定，犯此罪的，尚未造成严重后果的，处<strong>三年以上十年以下</strong>有期徒刑；致人重伤、死亡或者使公私财产遭受重大损失的，处<strong>十年以上有期徒刑</strong>、无期徒刑或者死刑。</p><p>此外，对于其他拒绝执行疫情防控措施，引起新型冠状病毒传播或者有传播严重危险的行为，则可能涉嫌<strong>妨害传染病防治罪</strong>。</p><p>依据刑法第三百三十条第一款第五项的规定，违反传染病防治法的规定，拒绝执行县级以上人民政府、疾病预防控制机构依照传染病防治法提出的预防、控制措施，引起甲类传染病以及依法确定采取甲类传染病预防、控制措施的传染病传播或者有传播严重危险的，处<strong>三年以下有期徒刑</strong>或者拘役；后果特别严重的，处<strong>三年以上七年以下</strong>有期徒刑。</p><ul><li><strong>除了刑事责任，被感染者可以要求民事赔偿吗？</strong></li></ul><p>依据传染病防治法第十二条的规定，在中华人民共和国领域内的一切单位和个人，必须接受疾病预防控制机构、医疗机构有关传染病的调查、检验、采集样本、隔离治疗等预防、控制措施，<strong>如实提供有关情况</strong>。</p><p>若单位和个人违反本法规定，导致传染病传播、流行，给他人人身、财产造成损害的，还应当<strong>依法承担民事责任</strong>。</p><p>也就是说，如果二人<strong>明知自己是确诊患者或者疑似患者仍然未按照国家疫情防控部门的要求</strong>，还与他人接触导致他人感染的，那么被感染者可以要求传播者赔偿损失。</p><h3 id="法律规定"><a href="#法律规定" class="headerlink" title="法律规定"></a>法律规定</h3><ul><li><p>《<strong>传染病防治法</strong>》第十二条之规定，在中华人民共和国领域内的一切单位和个人，必须接受疾病预防控制机构、医疗机构有关传染病的调查、检验、采集样本、隔离治疗等预防、控制措施，如实提供有关情况。</p></li><li><p>《<strong>传染病防治法</strong>》第三十一条之规定，任何单位和个人发现传染病病人或者疑似传染病病人时，应当及时向附近的疾病预防控制机构或者医疗机构报告。</p></li><li><p>《<strong>突发事件应对法</strong>》第五十四条之规定：“任何单位和个人不得编造、传播有关突发事件事态发展或者应急处置工作的虚假信息。”</p></li><li><p>《<strong>突发事件应对法</strong>》第五十七条之规定，突发事件发生地的公民应当服从人民政府、居民委员会、村民委员会或者所属单位的指挥和安排，配合人民政府采取的应急处置措施，积极参加应急救援工作，协助维护社会秩序。</p></li><li><p>如果明知自身已感染“新型冠状病毒”而故意传播，危害公共安全，依照《<strong>刑法</strong>》一百一十四条、一百十一五条第一款之规定，以危险方法危害公共安全罪定罪处罚，没有造成严重后果的，处三年以上十年以下有期徒刑，造成严重后果的，处十年以上有期徒刑、无期徒刑或者死刑。</p></li><li><p>如果实际上感染“新型冠状病毒”，处于潜伏期，误以为自己没有感染该病毒，而拒绝接受检疫、强制隔离或者治疗，过失造成“新型冠状病毒”传播，情节严重，危害公共安全的，依照《<strong>刑法</strong>》一百一十五第二款之规定，按过失以危险方法危害公共安全罪定罪处罚，最高可处七年有期徒刑。</p></li></ul><h3 id="自己的想法"><a href="#自己的想法" class="headerlink" title="自己的想法"></a>自己的想法</h3><ul><li>如果明知自己携带新冠病毒，却还要在杭州大逛特逛，试图传播病毒，则罪不可赦。给她们的病毒测个序，凡是该序列之后的病毒感染者以及她们造成影响的商家都可以对她们进行民事赔偿诉讼，至于刑事责任由国家公诉。</li><li>如不知道携带新冠病毒，为什么不亮健康码？为什么关掉手机签承诺书？为什么不遵守封控从危险的上海跑到杭州来？为什么在商场里待9小时？为什么从风险区出来在商场里不戴口罩谈笑风生？我觉得这些都是嫌疑点。不排除有其报复社会、妨碍疫情防控的可能。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java答案2</title>
      <link href="/2022/09/19/jvav2/"/>
      <url>/2022/09/19/jvav2/</url>
      
        <content type="html"><![CDATA[<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>DDBDB  BDCAA  ADAAA</p><h3 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h3><p>4-1<br>    BufferedInputStream</p><p>4-2<br>    OutputStream<br>    Reader</p><h3 id="程序填空题"><a href="#程序填空题" class="headerlink" title="程序填空题"></a>程序填空题</h3><p>5-1<br>    throw  new<br>    IllegalAccessException e</p><p>5-2<br>    int t a<br>    t</p><p>5-3<br>    f[i]&#x3D;f[i-1]+f[i-2]<br>    int i&#x3D;0<br>    (i+1)%4&#x3D;&#x3D;0</p><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><p>7-1</p><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        Dog animal = new Dog();        animal.shout();        animal.run();    &#125;&#125;class Animal &#123;    void shout() &#123;        System.out.println(&quot;animal shout！&quot;);    &#125;&#125;class Dog extends Animal &#123;    void shout() &#123;        super.shout();        System.out.println(&quot;wangwang……&quot;);    &#125;    void run() &#123;        System.out.println(&quot;Dog is running&quot;);    &#125;&#125;</code></pre><p>7-2</p><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        Son son = new Son();        son.method();    &#125;&#125;class Parent &#123;    Parent() &#123;        System.out.println(&quot;Parent&#39;s Constructor without parameter&quot;);    &#125;    Parent(boolean b) &#123;        System.out.println(&quot;Parent&#39;s Constructor with a boolean parameter&quot;);    &#125;    public void method() &#123;        System.out.println(&quot;Parent&#39;s method()&quot;);    &#125;&#125;class Son extends Parent &#123;    Son() &#123;        super(true);        System.out.println(&quot;Son&#39;s Constructor without parameter&quot;);    &#125;    public void method() &#123;        System.out.println(&quot;Son&#39;s method()&quot;);        super.method();    &#125;&#125;</code></pre><p>7-3</p><pre><code>import java.util.Scanner;public class Main&#123;    public static void main(String[] args) &#123;        Scanner in=new Scanner(System.in);        int n=in.nextInt();        int sum1=0,sum2=0;        int []s=new int[n];        for(int i=0;i&lt;n;i++) &#123;            int m=in.nextInt();            if(m&gt;100||m&lt;0) &#123;                System.out.println(m+&quot;invalid!&quot;);                i--;                continue;            &#125;            else                s[i]=m;            if(m&lt;60) sum1+=1;            else sum2+=1;        &#125;        System.out.println(sum2);        System.out.println(sum1);    &#125;&#125;</code></pre><p>7-4</p><pre><code>import java.util.Arrays;import java.util.Scanner;class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] arr = new int[n];        for (int i = 0; i &lt; n; i++) &#123;            arr[i] = sc.nextInt();        &#125;        double sum = 0;        for (int i = 0; i &lt; n; i++) &#123;            sum += arr[i];        &#125;        double mean = sum / n;        arr = Arrays.stream(arr).sorted().toArray();        double median = 0;        if (n % 2 == 0) &#123;            median = (arr[n / 2 - 1] + arr[n / 2]) / 2.0;        &#125;        else &#123;            median = arr[n / 2];        &#125;        System.out.print(&quot;mean=&quot; + String.format(&quot;%.2f&quot;, mean) + &quot;,median=&quot; + String.format(&quot;%.1f&quot;, median));    &#125;&#125;</code></pre><p>7-5</p><pre><code>import java.util.Arrays;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        int[] arr = new int[n];        for (int i = 0; i &lt; n; i++) &#123;            try&#123;                String str = scanner.next();                arr[i] = Integer.parseInt(str);            &#125;catch (Exception e)&#123;                System.out.println(e);                i--;            &#125;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java答案</title>
      <link href="/2022/09/19/jvav/"/>
      <url>/2022/09/19/jvav/</url>
      
        <content type="html"><![CDATA[<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>BDCDA CABCC</p><h3 id="程序填空"><a href="#程序填空" class="headerlink" title="程序填空"></a>程序填空</h3><p>5-1</p><pre><code>str.toCharArray()i&lt;x.lengthch&gt;=&#39;a&#39;&amp;&amp;ch&lt;=&#39;z&#39; ||ch&gt;=&#39;A&#39;&amp;&amp;ch&lt;=&#39;Z&#39;ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;c++</code></pre><p>5-2</p><pre><code>sc.nextLine()str.charAt(i)String.valueOf(curChar).toUpperCase()String.valueOf(curChar).toLowerCase()sb.append(s1)sb.toString()</code></pre><p>5-3</p><pre><code>super(a);this.a=super.a*10;super.athis.a</code></pre><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><p>7-1</p><pre><code>import java.util.Scanner;class Rectangle &#123;    double width = 1;    double height = 1;    Rectangle() &#123;    &#125;    Rectangle(double width, double height) &#123;        this.width = width;        this.height = height;    &#125;    double getArea() &#123;        return width * height;    &#125;    double getPerimeter() &#123;        return 2 * (width + height);    &#125;&#125;class Main&#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double width = scanner.nextDouble();        double height = scanner.nextDouble();        Rectangle rectangle1 = new Rectangle(width, height);        System.out.println(rectangle1.width + &quot; &quot; + rectangle1.height + &quot; &quot; + rectangle1.getArea() + &quot; &quot; + rectangle1.getPerimeter());        width = scanner.nextDouble();        height = scanner.nextDouble();        Rectangle rectangle2 = new Rectangle(width, height);        System.out.print(rectangle2.width + &quot; &quot; + rectangle2.height + &quot; &quot; + rectangle2.getArea() + &quot; &quot; + rectangle2.getPerimeter());    &#125;&#125;</code></pre><p>7-2</p><pre><code>import java.util.Scanner;interface ICompute&#123;    int computer(int n, int m);&#125;class Add implements ICompute&#123;    public int computer(int n, int m)&#123;        return n+m;    &#125;&#125;class Sub implements ICompute&#123;    public int computer(int n, int m)&#123;        return n-m;    &#125;&#125;class Main&#123;    public static void main(String[] args)&#123;        Scanner sc = new Scanner(System.in);        int a = sc.nextInt();        int b = sc.nextInt();        ICompute add = new Add();        ICompute sub = new Sub();        System.out.println(add.computer(a, b));        System.out.println(sub.computer(a, b));    &#125;&#125;</code></pre><p>7-3</p><pre><code>import java.util.Scanner;class Circle&#123;    private double radius;    Circle(double radius)&#123;        this.radius = radius;    &#125;    Circle()&#123;        this.radius =0;    &#125;    void setRadius(double r)&#123;        this.radius = r;    &#125;    double getRadius()&#123;        return this.radius;    &#125;    double getArea()&#123;        return Math.PI * this.radius * this.radius;    &#125;    double getPerimeter()&#123;        return Math.PI * this.radius * 2;    &#125;    public String toString()&#123;        return&quot;Circle(r:&quot;+this.radius+&quot;)&quot;;    &#125;&#125;class Cylinder&#123;    private double height;    private Circle circle;    Cylinder(double height,Circle circle)&#123;        this.height = height;        this.circle = circle;    &#125;    Cylinder()&#123;        this.height = 0;        this.circle = new Circle();    &#125;    void setHeight(double height)&#123;        this.height = height;    &#125;    double getHeight()&#123;        return this.height;    &#125;    void setCircle(Circle circle)&#123;        this.circle = circle;    &#125;    Circle getCircle()&#123;        return this.circle;    &#125;    double getArea()&#123;        return 2 * this.circle.getArea() + this.circle.getPerimeter() * this.height;    &#125;    double getVolume()&#123;        return this.circle.getArea() * this.height;    &#125;    public String toString()&#123;        return &quot;Cylinder(h:&quot;+this.height+&quot;,&quot;+this.circle+&quot;)&quot;;    &#125;&#125;public class Main&#123;    public static void main(String args[]) &#123;        Scanner input = new Scanner(System.in);        int n = input.nextInt();        for(int i = 0; i &lt; n; i++) &#123;            String str = input.next();            if(str.equals(&quot;Circle&quot;)) &#123;                Circle c = new Circle(input.nextDouble());                System.out.println(&quot;The area of &quot; + c.toString() + &quot; is &quot; + String.format(&quot;%.2f&quot;,c.getArea()));                System.out.println(&quot;The perimeterof &quot; + c.toString() + &quot; is &quot;+ String.format(&quot;%.2f&quot;,c.getPerimeter()));            &#125; else if(str.equals(&quot;Cylinder&quot;)) &#123;                Cylinder r = new Cylinder(input.nextDouble(), new Circle(input.nextDouble()));                System.out.println(&quot;The area of &quot; + r.toString() + &quot; is &quot; + String.format(&quot;%.2f&quot;,r.getArea()));                System.out.println(&quot;The volume of &quot; + r.toString() + &quot; is &quot; + String.format(&quot;%.2f&quot;,r.getVolume()));            &#125;        &#125;    &#125;&#125;</code></pre><p>7-4</p><pre><code>import java.util.Scanner;class Shape&#123;    double PI=3.1415926;    public double area()&#123;        return 0;    &#125;    public double perimeter()&#123;        return 0;    &#125;&#125;class Oval extends Shape&#123;    private double a;    private double b;    public Oval(double a,double b)&#123;        this.a=a;        this.b=b;    &#125;    public Oval()&#123;        this.a=0;        this.b=0;    &#125;    public double area()&#123;        return PI*a*b;    &#125;    public double perimeter()&#123;        return 2*PI*Math.sqrt((a*a+b*b)/2);    &#125;    public String toString()&#123;        return &quot;Oval(a:&quot;+a+&quot;,b:&quot;+b+&quot;)&quot;;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc=new Scanner(System.in);        double a=sc.nextDouble();        double b=sc.nextDouble();        Oval o=new Oval(a,b);        System.out.println(&quot;The area of &quot;+o.toString()+&quot; is &quot;+o.area());        System.out.println(&quot;The perimeterof &quot;+o.toString()+&quot; is &quot;+o.perimeter());    &#125;&#125;</code></pre><p>7-5</p><pre><code>import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        String statement;            Scanner sc =new Scanner(System.in);            statement=sc.nextLine();            String word1=sc.next();            String word2=sc.next();//用word2替换word1            String words[]=statement.split(&quot; &quot;);        /* for(int i=0;i&lt;words.length;i++)                System.out.print(words[i]+&quot;\t&quot;);*/            for(int i=0;i&lt;words.length;i++) &#123;//将句子分割成单词                if(word1.equals(words[i])) &#123;                    words[i]=word2;                &#125;            &#125;        StringBuffer stb=new StringBuffer();        String sta=null;        for(int i=0;i&lt;words.length;i++) &#123;//数组转换为句子            if(i==words.length-1)stb.append(words[i]);            elsestb.append(words[i]+&quot; &quot;);        &#125;        sta=stb.toString();        System.out.println(sta);            sc.close();    &#125;&#125;</code></pre><p>7-6</p><pre><code>import java.util.Scanner;interface Shape&#123;    double length();&#125;class Triangle implements Shape&#123;    double a;    double b;    double c;    Triangle()&#123;        this.a = this.b = this.c = 0;    &#125;    Triangle(double a)&#123;        this.a = this.b = this.c = 0;    &#125;    Triangle(double a, double b)&#123;        this.a = this.b = this.c = 0;    &#125;    Triangle(double a, double b, double c)&#123;        this.a = a;        this.b = b;        this.c = c;        if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0 || !(a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a))&#123;            this.a = this.b = this.c = 0;        &#125;    &#125;    @Override    public double length() &#123;        return a + b + c;    &#125;&#125;class Rectangle implements Shape&#123;    double a, b;    Rectangle()&#123;        this.a = this.b = 0;    &#125;    Rectangle(double a)&#123;        this.a = this.b = 0;    &#125;    Rectangle(double a, double b)&#123;        this.a = a;        this.b = b;        if(a &lt;= 0 || b &lt;= 0)&#123;            this.a = this.b = 0;        &#125;    &#125;    @Override    public double length() &#123;        return 2 * (a + b);    &#125;&#125;class Circle implements Shape&#123;    double r;    Circle()&#123;        r = 0;    &#125;    Circle(double r)&#123;        this.r = r;        if(r &lt;= 0) this.r = 0;    &#125;    @Override    public double length() &#123;        return 2 * 3.14 * r;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        while(sc.hasNextInt()) &#123;            double[] l = new double[5];            String s;            s = sc.nextLine();            String[] str = s.split(&quot; &quot;);            int cnt = 0;            for (String value : str) &#123;                l[cnt++] = Double.parseDouble(value);            &#125;            if(cnt == 1)&#123;                Circle C = new Circle(l[0]);                System.out.printf(&quot;%.2f\n&quot;, C.length());            &#125;            else if (cnt == 2)&#123;                Rectangle r = new Rectangle(l[0], l[1]);                System.out.printf(&quot;%.2f\n&quot;, r.length());            &#125;            else&#123;                Triangle t = new Triangle(l[0], l[1], l[2]);                System.out.printf(&quot;%.2f\n&quot;, t.length());            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>yaml</title>
      <link href="/2021/10/20/yaml/"/>
      <url>/2021/10/20/yaml/</url>
      
        <content type="html"><![CDATA[<h1 id="🍉前提知识"><a href="#🍉前提知识" class="headerlink" title="🍉前提知识"></a>🍉前提知识</h1><ol><li>Nodejs和npm，会使用Npm安装包</li><li>了解yaml基础语法</li><li>基本的js</li><li>从命令行接收参数 <a href="http://nodejs.cn/learn/nodejs-accept-arguments-from-the-command-line">http://nodejs.cn/learn/nodejs-accept-arguments-from-the-command-line</a></li><li>如何本地直接运行js代码：打开终端，输入 <code>node xxx.js</code></li></ol><h1 id="涉及到的库"><a href="#涉及到的库" class="headerlink" title="涉及到的库"></a>涉及到的库</h1><ol><li><a href="https://github.com/nodeca/js-yaml">js-yaml</a></li></ol><h1 id="练习内容：无页面版Todo-list"><a href="#练习内容：无页面版Todo-list" class="headerlink" title="练习内容：无页面版Todo list"></a>练习内容：无页面版Todo list</h1><ol><li><p>在你的项目文件夹新建一个 todo.yaml</p><ul><li>包含三大块： todo, doing, done，分别代表待办任务的三种状态</li><li>每条任务分布在三大块中，每条任务有以下属性：id，content,</li></ul></li><li><p>实现以下命令：</p></li></ol><ul><li><code>node xxx.js ls</code>：列出所有任务</li><li><code>node xxx.js ls --status=done</code>：列出所有任务完成的任务</li><li><code>node xxx.js ls --status=doing</code>: 列出所有进行中的任务</li><li><code>node xxx.js ls --status=todo</code></li><li><code>node xxx.js done 任务id</code>： 将该id对应的任务置为完成状态</li><li><code>node xxx.js todo 任务id</code></li><li><code>node xxx.js doing 任务id</code></li><li>下面的我省略node xxx.js：</li><li>delete 任务id</li><li>add 任务内容<br>  。。。自行想象添加功能。。。</li></ul><h1 id="一些实现的细节："><a href="#一些实现的细节：" class="headerlink" title="一些实现的细节："></a>一些实现的细节：</h1><ol><li>利用js-yaml中的dump保存js对象到yaml文件</li><li>利用js-yaml中的load读取yaml文件到js对象</li><li>可以边写边加入es6语法来练习</li></ol><hr><h1 id="最后声明"><a href="#最后声明" class="headerlink" title="最后声明"></a>最后声明</h1><blockquote><p>本练习真的只是为了你练习，主要是练习node,npm,js，es6,所以还是靠自觉完成，<strong>但是您的提交次数会作为我们评优的依据</strong>，完成了请推到你的分支</p></blockquote><h1 id="links"><a href="#links" class="headerlink" title="links"></a>links</h1><p><a href="https://github.com/hduhelp/frontend_2021_pratice/">https://github.com/hduhelp/frontend_2021_pratice/</a></p><p>如何将yaml转为js对象: <a href="https://github.com/nodeca/js-yaml">https://github.com/nodeca/js-yaml</a></p><p>每日一篇之yaml: <a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a></p><p>每日一篇之es6: <a href="https://www.w3cschool.cn/escript6/escript6-827l37er.html">https://www.w3cschool.cn/escript6/escript6-827l37er.html</a>  ES6 简介_w3cschool</p><p>安利一本书<a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a> ES6 入门教程</p><p><a href="https://hduhelp21.yuque.com/staff-mhchbm/ergbdy/lobnc5">https://hduhelp21.yuque.com/staff-mhchbm/ergbdy/lobnc5</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>天气小组件入门</title>
      <link href="/2021/10/06/%E5%A4%A9%E6%B0%94%E5%B0%8F%E7%BB%84%E4%BB%B6%E5%85%A5%E9%97%A8/"/>
      <url>/2021/10/06/%E5%A4%A9%E6%B0%94%E5%B0%8F%E7%BB%84%E4%BB%B6%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="天气api"><a href="#天气api" class="headerlink" title="天气api"></a>天气api</h1><p>用的api是qweather<br><strong>和风天气</strong><br><a href="https://www.qweather.com/">qweather</a><br><a href="https://dev.qweather.com/docs/api/">api手册</a></p><h5 id="我是蒟蒻"><a href="#我是蒟蒻" class="headerlink" title="我是蒟蒻"></a>我是蒟蒻</h5><p><del>UI设计拉胯</del><br><strong>使用世界上最好的js框架 vanilla js</strong></p><p>已经实现的功能：</p><ul><li>获取实时气温 湿度 风向 风力 风速 大气压 能见度</li><li>获取当前日期时间周几</li><li>天气小图标</li><li>3天天气预告</li><li>flex布局，适应设备</li></ul><p>待实现功能：</p><ul><li>气温变化图表</li><li>穿衣建议</li><li>darkmode</li><li>iconfont图标</li></ul><p>通过这次小组件开发学会的东西：</p><ul><li>flex的使用</li><li>fetch then promise （还是不会用<del>抄的</del>）</li><li>天气api的使用</li><li>json格式化处理</li></ul><h5 id="api请求格式"><a href="#api请求格式" class="headerlink" title="api请求格式"></a>api请求格式</h5><pre><code>https://devapi.qweather.com/v7/weather/now?[请求参数]</code></pre><p>必须参数 –location<br>必须参数 –key</p><h5 id="返回数据例"><a href="#返回数据例" class="headerlink" title="返回数据例"></a>返回数据例</h5><pre><code>// 北京实况天气 // 商业版 https://api.qweather.com/v7/weather/now?location=101010100&amp;key=你的KEY// 开发版 https://devapi.qweather.com/v7/weather/now?location=101010100&amp;key=你的KEY&#123;  &quot;code&quot;: &quot;200&quot;,  &quot;updateTime&quot;: &quot;2020-06-30T22:00+08:00&quot;,  &quot;fxLink&quot;: &quot;http://hfx.link/2ax1&quot;,  &quot;now&quot;: &#123;    &quot;obsTime&quot;: &quot;2020-06-30T21:40+08:00&quot;,    &quot;temp&quot;: &quot;24&quot;,    &quot;feelsLike&quot;: &quot;26&quot;,    &quot;icon&quot;: &quot;101&quot;,    &quot;text&quot;: &quot;多云&quot;,    &quot;wind360&quot;: &quot;123&quot;,    &quot;windDir&quot;: &quot;东南风&quot;,    &quot;windScale&quot;: &quot;1&quot;,    &quot;windSpeed&quot;: &quot;3&quot;,    &quot;humidity&quot;: &quot;72&quot;,    &quot;precip&quot;: &quot;0.0&quot;,    &quot;pressure&quot;: &quot;1003&quot;,    &quot;vis&quot;: &quot;16&quot;,    &quot;cloud&quot;: &quot;10&quot;,    &quot;dew&quot;: &quot;21&quot;  &#125;,  &quot;refer&quot;: &#123;    &quot;sources&quot;: [      &quot;Weather China&quot;    ],    &quot;license&quot;: [      &quot;commercial license&quot;    ]  &#125;&#125;</code></pre><h5 id="js例"><a href="#js例" class="headerlink" title="js例"></a>js例</h5><p>  function fetchwea() {<br>    fetch(‘<a href="https://devapi.qweather.com/v7/weather/now?key=90304353392d4ea4ba00608cb2e7f9ae&amp;location=101210101&#39;">https://devapi.qweather.com/v7/weather/now?key=90304353392d4ea4ba00608cb2e7f9ae&amp;location=101210101&#39;</a>)<br>    .then(res &#x3D;&gt; res.json())<br>    .then(json &#x3D;&gt; {</p><pre><code>  document.getElementById(&#39;temp&#39;).innerHTML=json.now.temp+&quot;℃&quot;;</code></pre><h3 id="使用图标icon"><a href="#使用图标icon" class="headerlink" title="使用图标icon"></a>使用图标icon</h3><p><a href="https://dev.qweather.com/docs/start/icons/">图标api手册</a></p><pre><code>document.getElementById(&#39;i&#39;).className=&#39;qi-&#39;+json.now.icon;</code></pre><p>这里json.now.icon会返回图标代码<br>导入图标css<br>改变HTML里 <i>标签的class为qi-(图标代码)<br>就可以显示好看的图标啦~<br><img src="https://dev.qweather.com/assets/images/content/qweather-icon-screenshot-new.png" alt="images"></p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><a href="https://imgtu.com/i/5CZo5V"><img src="https://z3.ax1x.com/2021/10/08/5CZo5V.png" alt="5CZo5V.png"></a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
