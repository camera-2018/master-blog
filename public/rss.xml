<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>向阳信息</title>
    <link>https://xyxsw.ltd/</link>
    
    <atom:link href="https://xyxsw.ltd/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>若月千鸮的博客&#39;</description>
    <pubDate>Tue, 25 Jul 2023 14:36:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>go语言三个小项目 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/07/25/go%E8%AF%AD%E8%A8%80%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/07/25/go%E8%AF%AD%E8%A8%80%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 25 Jul 2023 11:59:09 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;猜数字&quot;&gt;&lt;a href=&quot;#猜数字&quot; class=&quot;headerlink&quot; title=&quot;猜数字&quot;&gt;&lt;/a&gt;猜数字&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;猜数字&lt;br&gt;这个项目非常简单，它涉及到随机数的生成和用户输入操作。&lt;br&gt;我们使用了bufio库来处理输入数据。&lt;/l</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><ol><li>猜数字<br>这个项目非常简单，它涉及到随机数的生成和用户输入操作。<br>我们使用了bufio库来处理输入数据。</li></ol><pre><code class="go">reader := bufio.NewReader(os.Stdin)input, _ := reader.ReadString(&#39;\n&#39;)</code></pre><h2 id="简单字典"><a href="#简单字典" class="headerlink" title="简单字典"></a>简单字典</h2><ol start="2"><li>标准库strconv<br>它主要用于字符和其他类型之间的转换。</li></ol><pre><code class="go">strconv.Atoi(s string) int </code></pre><ol start="3"><li>标准库strings</li></ol><pre><code class="go">strings.TrimSuffix(s string ,  suffix string) string</code></pre><p>删除末尾字符，如果没有就正常返回</p><ol start="4"><li>网络库</li></ol><pre><code class="go">client := &amp;http.Client&#123;&#125;</code></pre><p>初始化请求客户端</p><pre><code class="go">req,  err := http.NewRequest(&quot;POST&quot;, &quot;https://api.interpreter.caiyunai.com/v1/dict&quot;,  data)</code></pre><p>构造头</p><pre><code class="go">req.Header.Set(&quot;authority&quot;,  &quot;api.interpreter.caiyunai.com&quot;)</code></pre><p>请求</p><pre><code class="go">bodyText,  err := io.ReadAll(resp.Body)err = json.Unmarshal(bodyText,  &amp;dictResponse)</code></pre><ol start="5"><li>os库</li></ol><pre><code class="go">word := os.Args[1]</code></pre><p>获取环境参数</p><h2 id="socks5代理"><a href="#socks5代理" class="headerlink" title="socks5代理"></a>socks5代理</h2><pre><code class="go">package mainimport (    &quot;context&quot;    &quot;encoding/binary&quot;    &quot;fmt&quot;    &quot;io&quot;    &quot;net&quot;)const (    socks5Ver  = 0x05    atypeIPV4  = 0x01    atypeHOST  = 0x03    cmdConnect = 0x01)func main() &#123;    // 假设在这里建立一个 net.Listener 监听 Socks5 代理请求    for &#123;        client, err := acceptConnection()        if err != nil &#123;            continue        &#125;        // 开启一个 goroutine 处理客户端请求        go handleSocks5Client(client)    &#125;&#125;func acceptConnection() (net.Conn, error) &#123;    // 实现接收连接请求的逻辑&#125;func handleSocks5Client(conn net.Conn) &#123;    defer conn.Close()    // 鉴权阶段    if err := auth(conn); err != nil &#123;        fmt.Println(&quot;Authentication error:&quot;, err)        return    &#125;    // 通讯阶段    addr, err := connect(conn)    if err != nil &#123;        fmt.Println(&quot;Connection error:&quot;, err)        return    &#125;    // 给客户端回包，表示连接成功    _, _ = conn.Write([]byte&#123;socks5Ver, 0x00, 0x00, atypeIPV4, 0, 0, 0, 0, 0, 0&#125;)    // 开始进行数据转发    dest, err := net.Dial(&quot;tcp&quot;, addr)    if err != nil &#123;        fmt.Println(&quot;Failed to connect to destination:&quot;, err)        return    &#125;    defer dest.Close()    ctx, cancel := context.WithCancel(context.Background())    defer cancel()    // 从客户端到目标地址的数据拷贝    go func() &#123;        _, _ = io.Copy(dest, conn)        cancel()    &#125;()    // 从目标地址到客户端的数据拷贝    go func() &#123;        _, _ = io.Copy(conn, dest)        cancel()    &#125;()    &lt;-ctx.Done()&#125;func auth(conn net.Conn) error &#123;    buf := make([]byte, 2)    _, err := io.ReadFull(conn, buf)    if err != nil &#123;        return err    &#125;    ver, nmethods := buf[0], buf[1]    methods := make([]byte, nmethods)    _, err = io.ReadFull(conn, methods)    if err != nil &#123;        return err    &#125;    // 在这里根据收到的 methods 进行认证处理    // 假设这里选择不需要认证，回包告知客户端不需要认证    _, err = conn.Write([]byte&#123;socks5Ver, 0x00&#125;)    if err != nil &#123;        return err    &#125;    return nil&#125;func connect(conn net.Conn) (string, error) &#123;    buf := make([]byte, 4)    _, err := io.ReadFull(conn, buf)    if err != nil &#123;        return &quot;&quot;, err    &#125;    ver, cmd, _, atyp := buf[0], buf[1], buf[2], buf[3]    if ver != socks5Ver || cmd != cmdConnect &#123;        return &quot;&quot;, fmt.Errorf(&quot;Unsupported SOCKS5 command&quot;)    &#125;    var addr string    switch atyp &#123;    case atypeIPV4:        buf := make([]byte, 4)        _, err := io.ReadFull(conn, buf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        addr = fmt.Sprintf(&quot;%d.%d.%d.%d&quot;, buf[0], buf[1], buf[2], buf[3])    case atypeHOST:        hostSizeBuf := make([]byte, 1)        _, err := io.ReadFull(conn, hostSizeBuf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        hostSize := int(hostSizeBuf[0])        hostBuf := make([]byte, hostSize)        _, err = io.ReadFull(conn, hostBuf)        if err != nil &#123;            return &quot;&quot;, err        &#125;        addr = string(hostBuf)    &#125;    portBuf := make([]byte, 2)    _, err = io.ReadFull(conn, portBuf)    if err != nil &#123;        return &quot;&quot;, err    &#125;    port := binary.BigEndian.Uint16(portBuf)    return fmt.Sprintf(&quot;%v:%v&quot;, addr, port), nil&#125;</code></pre><p>使用 SOCKS5 代理的实现，涵盖了以下主要步骤：</p><p>鉴权阶段：</p><p>解析客户端发送的版本号、支持的认证方法数量和认证方法列表。<br>针对支持的认证方法进行验证，返回认证成功的回包。<br>通讯阶段：</p><p>解析客户端发送的连接请求，包括版本号、命令类型、目标地址类型、目标地址、目标端口等信息。<br>根据目标地址类型和地址解析方式，获取目标地址和端口号。<br>向目标地址发起连接请求，并返回连接成功的回包。<br>进程管理：</p><p>使用 goroutine 后台开启两个服务器交互进程。<br>通过 context 库进行进程管理，确保进程在必要时可以被关闭。<br>将客户端和目标之间的数据互相拷贝，使得数据能够在两者之间传递。</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>在这节课学习的内容中，我收获了很多关于Go语言编程的知识和技能。以下是我的感想：</p><p>Go语言的简洁和高效：通过学习这些基础标准库和相关功能，我深刻感受到Go语言的简洁和高效。标准库提供了丰富的功能，让编程变得更加简单和高效。</p><p>数据类型转换和字符串处理：学习了strconv和strings包，对于数据类型转换和字符串处理有了更深入的了解。这些工具使得在处理用户输入和数据转换时更加方便。</p><p>网络编程和HTTP库：了解了Go语言中的网络编程和net&#x2F;http包，我现在能够编写简单的HTTP服务器和客户端，这对于开发网络应用和服务端程序非常有用。</p><p>文件操作和系统交互：通过os包的学习，我学会了如何在Go语言中进行文件操作和与操作系统进行交互，这对于处理文件和系统配置十分重要。</p><p>代理和鉴权：学习了socks5代理和鉴权机制，我对网络代理和安全认证有了更深刻的理解，这对于开发安全性较高的应用非常重要。</p><p>上下文处理：context包的学习使我了解了在Go语言中如何优雅地处理请求上下文，更好地控制请求的流程和生命周期。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/07/25/go%E8%AF%AD%E8%A8%80%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LINUX 挑战：用户和组管理</title>
      <link>https://xyxsw.ltd/2023/05/08/%E6%8C%91%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</link>
      <guid>https://xyxsw.ltd/2023/05/08/%E6%8C%91%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</guid>
      <pubDate>Mon, 08 May 2023 12:26:21 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;LINUX-挑战：用户和组管理&quot;&gt;&lt;a href=&quot;#LINUX-挑战：用户和组管理&quot; class=&quot;headerlink&quot; title=&quot;LINUX 挑战：用户和组管理&quot;&gt;&lt;/a&gt;LINUX 挑战：用户和组管理&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="LINUX-挑战：用户和组管理"><a href="#LINUX-挑战：用户和组管理" class="headerlink" title="LINUX 挑战：用户和组管理"></a>LINUX 挑战：用户和组管理</h1><ol><li></li></ol><pre><code>wget https://labfile.oss.aliyuncs.com/courses/2585/06.tar.gztar -xzf 06.tar.gzchmod 700 ./06.sh./06.sh</code></pre><ol start="2"><li></li></ol><pre><code>sudo userdel guest2sudo userdel guest3sudo userdel guest4sudo userdel guest5sudo rm -rf /home/guest2sudo rm -rf /home/guest3sudo rm -rf /home/guest4sudo rm -rf /home/guest5sudo groupadd guestmkdir /tmp/tempusersudo usermod -u 2000 -g guest -d /tmp/tempuser guest1 </code></pre><ol start="3"><li></li></ol><pre><code>sudo mkdir /home/vsftpdusersudo useradd vsftpduser -d /home/vsftpduser -s /usr/sbin/nologin sudo chown vsftpduser /home/vsftpdusersudo chgrp vsftpduser /home/vsftpdusersudo chmod 744 /home/vsftpduser</code></pre><ol start="4"><li></li></ol><pre><code>sudo useradd magsudo useradd devsudo useradd testsudo mkdir /srv/projectx/magsudo mkdir /srv/projectx/devsudo mkdir /srv/projectx/testsudo usermod -G dev magsudo chown dev:dev /srv/projectxsudo chmod 751 /srv/projectxsudo chmod o+rx /srv/projectx/devsudo chmod o+rx /srv/projectx/test</code></pre><ol start="5"><li></li></ol><pre><code>cat /etc/passwd | grep bash | cut -d &#39;:&#39; -f 1,3 &gt; users.txt</code></pre><ol start="6"><li></li></ol><pre><code>sudo useradd stusudo passwd stu123456123456sudo visudo:21# 按i往里写stu ALL=(shiyanlou:shiyanlou) /bin/touch# 退出按:wq</code></pre><ol start="7"><li></li></ol><pre><code>sudo passwd dev123456123456sudo touch /etc/sudoers.d/devsudo chmod 777 /etc/sudoers.d/devvim /etc/sudoers.d/dev# 按i往里写dev  ALL=(root:root) /usr/sbin/useradd# 退出按:wq</code></pre>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/Linux%E5%AE%9E%E9%AA%8C/">Linux实验</category>
      
      
      <comments>https://xyxsw.ltd/2023/05/08/%E6%8C%91%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Web 开发安全 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/02/08/Web%20%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/02/08/Web%20%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 08 Feb 2023 02:51:11 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 17 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;课程重点&quot;&gt;&lt;a href=&quot;#课程重点&quot; class=&quot;headerlink&quot; title=&quot;课程重点&quot;&gt;&lt;/a&gt;课程重点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 17 天</strong></p><h2 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h2><ul><li><p>Web 相关的攻击介绍</p></li><li><p>Web 相关的防御介绍</p></li></ul><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="XSS-Cross-Site-Scripting"><a href="#XSS-Cross-Site-Scripting" class="headerlink" title="XSS (Cross-Site Scripting)"></a>XSS (Cross-Site Scripting)</h3><p>主要是由于盲目信任用户输入，直接将用户输入渲染出来，导致了攻击脚本的植入</p><p>特点：</p><ol><li>通常难以从 UI 上感知</li><li>窃取用户信息，例如 cookie 和 token</li></ol><p>常见的会导致XSS的代码：</p><pre><code>document.writeel.innerHTML = anyString</code></pre><p>总结来说，所有能够渲染dom结构的函数，都有可能导致XSS攻击。</p><p>比如论坛场景中，<strong>用户提交的内容包含恶意script标签</strong></p><pre><code class="js">fetch(&quot;/submit&quot;, &#123;    body: JSON.stringify(&#123;        id: &quot;1&quot;,        content: `&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;`    &#125;)&#125;)</code></pre><p>导致代码被插入到帖子中，所有用户访问页面都会执行恶意脚本</p><p>XSS 能够分成下面四类</p><p><code>Stored XSS</code> 直接将恶意脚本储存到了数据库中，导致之后的所有访问均会携带恶意脚本，危害很大</p><pre><code>Reflected XSS` 反射型，不储存数据，仅仅从URL传入脚本导致攻击，例如 `/path?param=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p><code>DOM-based XSS</code> 不由服务器参与，攻击的发起和执行都在浏览器，常见于前端框架中</p><p><code>Mutation-based XSS</code> 利用浏览器的特性，不同浏览器会有区别，例如</p><pre><code>&lt;noscript&gt;&lt;p title=&quot;&lt;/noscript&gt;&lt;img src=x onerror=alert(1)&gt;&quot;&gt;</code></pre><h3 id="CSRF-Cross-site-request-forgery"><a href="#CSRF-Cross-site-request-forgery" class="headerlink" title="CSRF (Cross-site request forgery)"></a>CSRF (Cross-site request forgery)</h3><p>特点：</p><ol><li>在用户不知情的前提下</li><li>利用用户权限（cookie）</li><li>构造指定HTTP请求，窃取或修改用户敏感信息</li></ol><p>例子：</p><p>用户没有访问银行网页，但是访问了一个带有攻击内容的网页，该网页尝试请求银行接口，由于用户登录过银行，接口携带cookie，导致请求成功，使得用户受到损失。</p><h3 id="SQL-注入-SQL-Injection"><a href="#SQL-注入-SQL-Injection" class="headerlink" title="SQL 注入 (SQL Injection)"></a>SQL 注入 (SQL Injection)</h3><p>在请求参数中构造恶意字符串，拼接SQL语句，导致服务器执行了特定的SQL语句，造成数据库内容泄露</p><p>例子：</p><pre><code class="js">sql.query(`    SELECT a, b, c FROM table    WHERE username = $&#123;username&#125;    AND form_id = $&#123;form_id&#125;`)</code></pre><p>上面的这段后端代码，攻击者就能够通过构造特殊的 username 或 form_id，使得SQL语句的意义被改变</p><p>例如传入 form_id &#x3D; <code>any; DROP TABLE table;</code></p><p>SQL 语句拼接后变成 <code>SELECT a,b,c FROM table WHERE xxxx AND form_id = any; DROP TABLE table;</code></p><p>将导致数据库被删除</p><h3 id="SSRF-Server-Side-Request-Forgery"><a href="#SSRF-Server-Side-Request-Forgery" class="headerlink" title="SSRF (Server-Side Request Forgery)"></a>SSRF (Server-Side Request Forgery)</h3><p>服务端伪造请求</p><p>例子：</p><pre><code>ctx.body = await fetch(ctx.query.callback)</code></pre><p>导致能够通过传入的参数访问到服务器内网的相关服务</p><h3 id="DoS-Denial-of-Service"><a href="#DoS-Denial-of-Service" class="headerlink" title="DoS (Denial of Service)"></a>DoS (Denial of Service)</h3><p><code>「 不搞复杂的 ， 量大就完事儿了 」</code></p><p>通过构造特定请求，导致服务器资源被消耗，来不及响应更多请求，引发雪崩效应</p><p>例如：</p><ol><li>耗时的同步操作</li><li>文件备份</li><li>数据库写入</li><li>SQL join</li><li>循环执行逻辑</li></ol><h4 id="DDoS-Distributed-DoS"><a href="#DDoS-Distributed-DoS" class="headerlink" title="DDoS (Distributed DoS)"></a>DDoS (Distributed DoS)</h4><p>攻击特点</p><ul><li>直接访问 IP</li><li>任意 API</li><li>消耗大量带宽 （ 耗尽 ）</li></ul><p>SYN Flood</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>安全无小事<br>使用的依赖 npm package，甚至是 NodeJS 可能成为最薄弱的一环</p><ul><li>保持学习心态<br>npm install 除了带来了果洞 ， 还可以带来漏洞</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://bytedance.feishu.cn/file/boxcn9L4YzmTK3mwE3tIBL2UVme">https://bytedance.feishu.cn/file/boxcn9L4YzmTK3mwE3tIBL2UVme</a></p><p><a href="https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065">https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/02/08/Web%20%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NextJs ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/02/01/NextJS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/02/01/NextJS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 01 Feb 2023 06:54:49 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 16 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、本堂课重点内容：&quot;&gt;&lt;a href=&quot;#一、本堂课重点内容：&quot; class=&quot;headerlink&quot; title=&quot;一、本堂课重点内容：&quot;&gt;&lt;/a&gt;一、本</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 16 天</strong></p><h2 id="一、本堂课重点内容："><a href="#一、本堂课重点内容：" class="headerlink" title="一、本堂课重点内容："></a>一、本堂课重点内容：</h2><ol><li>CSR, SSR, SSG</li><li>什么是 Next.js</li><li>Next.js 客户端开发</li><li>Next.js服务端开发</li><li>核心功能</li></ol><h2 id="二、详细知识点介绍："><a href="#二、详细知识点介绍：" class="headerlink" title="二、详细知识点介绍："></a>二、详细知识点介绍：</h2><h3 id="1-CSR-SSR-SSG"><a href="#1-CSR-SSR-SSG" class="headerlink" title="1. CSR, SSR, SSG"></a>1. CSR, SSR, SSG</h3><h4 id="1-CSR（客户端渲染-Client-Side-Render）"><a href="#1-CSR（客户端渲染-Client-Side-Render）" class="headerlink" title="1. CSR（客户端渲染 Client Side Render）"></a>1. CSR（客户端渲染 Client Side Render）</h4><p>即在客户端渲染网页结构，一般情况下我们所熟知的 Vue、React 均采用这种模式。在构建时并不会生成HTML结构，仅仅包含js代码的引用。在浏览器端将HTML结构渲染出来。客户端渲染会在项目体积较大的时候可能会导致较长的首屏加载时间，用户体验不好，且对于SSO来说并不友好。</p><h4 id="2-SSR（服务端渲染-Server-Side-Render）"><a href="#2-SSR（服务端渲染-Server-Side-Render）" class="headerlink" title="2. SSR（服务端渲染 Server Side Render）"></a>2. SSR（服务端渲染 Server Side Render）</h4><p>浏览器请求时，服务器直接生成HTML结构并返回，这种模式其实并不少见，曾经的<code>php</code>和<code>jsp</code>都是这种模式。<code>Vue</code> 和 <code>React</code> 也对这种模式进行了支持，例如 React 下有 <code>Vercel</code> 主导的 <code>Next.js</code> 框架支持服务端渲染，Vue 下也有类似的框架 Nuxt.js。与前者的区别是，<code>php</code>和<code>jsp</code>的前后端代码实际上仍是分离的，需要动态交互的部分还是需要<code>js</code>介入。而<code>React</code>和<code>Vue</code>在服务端和客户端都是同一套代码，这也就导致其比前者多了一步水合 <code>hydrate</code> (也称注水) 的操作。</p><p>在这种模式下，服务端在生成HTML的同时对其进行“脱水”，即将渲染结构的初始数据分离出来，单独储存，以便让前端读取。在浏览器收到页面后，相关的代码读取这部分内容，再对html结构进行“注水”（水合），使得服务端和客户端的数据同步，且浏览器端的元素能够正常交互。</p><p>比起CSR，SSR能够大幅缩短首屏加载的时间，且对于SSO友好，但是需要服务器支持。</p><h4 id="3-SSG（静态网页生成-Static-Site-Generation）"><a href="#3-SSG（静态网页生成-Static-Site-Generation）" class="headerlink" title="3. SSG（静态网页生成 Static Site Generation）"></a>3. SSG（静态网页生成 Static Site Generation）</h4><p>这种形式实际上和SSR类似，但是无需运行一个服务端，HTML结构在构建时就已经创建完了，用户访问时，仍然是个静态页，却具有SSR首屏加载时间短的优势，适合那些修改不频繁的站点，例如一些开发文档。</p><h3 id="2-什么是-Next-js"><a href="#2-什么是-Next-js" class="headerlink" title="2.什么是 Next.js"></a>2.什么是 Next.js</h3><p>基于 React 提供的相关服务器端渲染 API 实现 ， 整个过程实现比较繁琐重复 ， 从零实现对新上手同学很不友好迫切需要一个封装好的集合来快速上手服务器端渲染。</p><p>Next.js是一个构建于 Node.js之上的开源 we b 开发框架 ，支持基于 React 的 web 应用程序功能 ， 例如服务端渲染和生成静态网站 。上手快 ， 能力集全 ， 覆盖了足够多的性能优化。</p><p>对于新同学掌握前后端一体化的开发模式很友好 。</p><h3 id="3-Next-js-客户端开发"><a href="#3-Next-js-客户端开发" class="headerlink" title="3. Next.js 客户端开发"></a>3. Next.js 客户端开发</h3><ol><li>Next.js 初始化</li><li>数据注入</li><li><code>getlnitiaIProps</code></li><li><code>getServerSideProps</code></li><li><code>getStaticProps</code></li><li>CSS Modules</li><li>Layout</li><li>文件式路由</li><li>B F F 层的文件式路由</li><li>路由跳转</li><li>header 的修改</li><li>多媒体适配—— CSS 适配</li><li>多媒体适配—— JS 适配</li><li>大图优化—— webp</li></ol><h3 id="4-Next-js服务端开发"><a href="#4-Next-js服务端开发" class="headerlink" title="4. Next.js服务端开发"></a>4. Next.js服务端开发</h3><ol><li>BFF 层开发</li><li>调试方式</li><li>Strapi —— headless CMS</li></ol><h3 id="5-核心功能"><a href="#5-核心功能" class="headerlink" title="5. 核心功能"></a>5. 核心功能</h3><h4 id="首页功能实现"><a href="#首页功能实现" class="headerlink" title="首页功能实现"></a>首页功能实现</h4><ol><li>页面 &amp; 动画 &amp; 多媒体适配</li><li>BFF</li><li>Strapi</li></ol><h4 id="文章页实现"><a href="#文章页实现" class="headerlink" title="文章页实现"></a>文章页实现</h4><ol><li>页面 &amp; 动画 &amp; 多媒体适配</li><li>BFF</li><li>Strapi 分页</li><li>多媒体格式的转换<ul><li>markdown 转 html</li><li>html 转 dom</li><li>公共样式的定义</li></ul></li></ol><h4 id="主题化功能实现"><a href="#主题化功能实现" class="headerlink" title="主题化功能实现"></a>主题化功能实现</h4><ol><li>基础样式和背景的抽离</li><li>主题化 <code>context</code> 全局注入</li><li>从注入数据中取出 <code>theme</code> 和 <code>setTheme</code></li><li>多进程间的主题同步</li></ol><h2 id="三、实践练习例子："><a href="#三、实践练习例子：" class="headerlink" title="三、实践练习例子："></a>三、实践练习例子：</h2><h3 id="思考题-：-http-localhost-3000-和-http-127-0-0-1-3000-主题可以共享吗"><a href="#思考题-：-http-localhost-3000-和-http-127-0-0-1-3000-主题可以共享吗" class="headerlink" title="思考题 ： http://localhost:3000 和 http://127.0.0.1:3000 主题可以共享吗"></a>思考题 ： <a href="http://localhost:3000/">http://localhost:3000</a> 和 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 主题可以共享吗</h3><p>答案是<strong>不能</strong></p><p>如果存在<code>localstorage</code>里</p><p>那么这俩域名不是同域名</p><p>不会共享</p><h3 id="初始化-Next-js-项目"><a href="#初始化-Next-js-项目" class="headerlink" title="初始化 Next.js 项目"></a>初始化 Next.js 项目</h3><p>Next.js 提供了一个脚手架，直接就能够创建项目</p><pre><code class="bash">npx create-next-app@latest --typescript</code></pre><p>接下来就能够看到创建完成的项目目录了。可能会有下面这些文件</p><p><code>.eslintrc.json</code> - eslint 的配置文件，配置了eslint使用的语法规则</p><p><code>.gitignore</code> - git 仓库的忽略文件</p><p><code>next-env.d.ts</code> - TypeScript 的类型定义，是为了方便引入Next声明的类型</p><p><code>next.config.js</code> - Next.js 的配置文件</p><p><code>pages</code> - 页面目录</p><p><code>styles</code> - 样式目录</p><p><code>public</code> - 公共资源目录，会在构建时被原样拷贝</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>本次课程讲解了 Next.js 的基础概念、客户端开发以及服务端开发，以及核心功能的实现，让我对 Next.js 拥有了更多的了解，它的客户端和服务端的开发可以让我们更有效的实现功能，并且在项目构建的时候可以利用它的脚手架快速创建项目，实现更加高效的开发。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/02/01/NextJS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NodeJS基础 ｜ 青训营笔记.md</title>
      <link>https://xyxsw.ltd/2023/01/31/NodeJS%E5%9F%BA%E7%A1%80%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/31/NodeJS%E5%9F%BA%E7%A1%80%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 31 Jan 2023 15:00:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 15 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、本堂课重点内容：&quot;&gt;&lt;a href=&quot;#一、本堂课重点内容：&quot; class=&quot;headerlink&quot; title=&quot;一、本堂课重点内容：&quot;&gt;&lt;/a&gt;一、本</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 15 天</strong></p><h2 id="一、本堂课重点内容："><a href="#一、本堂课重点内容：" class="headerlink" title="一、本堂课重点内容："></a>一、本堂课重点内容：</h2><ol><li>NodeJS 应用场景</li><li>NodeJS 运行时结构</li><li>使用 NodeJS 编写简单的 HTTP Server</li><li>NodeJS延伸</li></ol><h2 id="二、详细知识点介绍："><a href="#二、详细知识点介绍：" class="headerlink" title="二、详细知识点介绍："></a>二、详细知识点介绍：</h2><h3 id="1-NodeJS应用场景"><a href="#1-NodeJS应用场景" class="headerlink" title="1. NodeJS应用场景"></a>1. NodeJS应用场景</h3><p>NodeJS被广泛应用于前端工程化（<code>Vue</code>、<code>React</code>、<code>AngularJS</code>等）、</p><p>Web 服务端应用（<code>Vercel</code>）和 跨端桌面应用（<code>Electron</code>等）场景</p><p>许多熟知的打包构建工具都有NodeJS参与，例如 <code>webpack</code>、<code>vite</code>、<code>esbuild</code>和<code>parcel</code>等，也有例如<code>babel</code>和<code>TS</code>等语言转换程序也由<code>nodejs</code>编写。</p><p>在前端工程化领域，<code>NodeJS</code>也有许多优势，首先是学习曲线平缓、开发效率较高、其次是运行效率较高，社区生态丰富。且由于其语言优势，和前端结合更加顺畅，例如某些服务端渲染场景。</p><p>在跨端应用方面，微软的<code>VSCode</code>、聊天工具<code>Discord</code>都由<code>Electron</code>开发，值得在项目选型时考虑。</p><p>难以替代</p><p>与前端结合的场景有很大的优势SSR</p><p>字节使用<code>NodeJS</code>，飞书就是<code>electron</code>应用  每年新增1000+<code>nodejs</code>应用</p><h3 id="2-NodeJS运行时结构"><a href="#2-NodeJS运行时结构" class="headerlink" title="2.NodeJS运行时结构"></a>2.NodeJS运行时结构</h3><ul><li>用户代码</li><li>npm</li><li>js core</li><li>cpp core</li><li>v8</li><li>openssl</li><li>…</li></ul><p>异步、单线程、跨平台</p><h3 id="3-使用-NodeJS-编写简单的-HTTP-Server"><a href="#3-使用-NodeJS-编写简单的-HTTP-Server" class="headerlink" title="3. 使用 NodeJS 编写简单的 HTTP Server"></a>3. 使用 NodeJS 编写简单的 HTTP Server</h3><p>0 ． 安装 <code>node.js</code><br>1 .    编写 Http Server + Client, 收发 GET, POST 请求<br>2 ． 编写静态文件服务器<br>3 ． 编写 React SSR 服务<br>4 ． 适用 inspector 进行调试 、 诊断<br>5 ． 部署简介</p><h3 id="4-NodeJS延伸"><a href="#4-NodeJS延伸" class="headerlink" title="4. NodeJS延伸"></a>4. NodeJS延伸</h3><ul><li>编译</li><li>诊断追踪</li><li>wasm</li><li>napi</li><li>…</li></ul><h2 id="三、实践练习例子："><a href="#三、实践练习例子：" class="headerlink" title="三、实践练习例子："></a>三、实践练习例子：</h2><h3 id="简单的-Hello-World"><a href="#简单的-Hello-World" class="headerlink" title="简单的 Hello World"></a>简单的 Hello World</h3><pre><code class="js">const http = require(&#39;http&#39;)const port = 3000const server = http.createServer((req, res) =&gt; &#123;    res.end(&#39;hello&#39;)&#125;)server.listen(port, () =&gt; &#123;    console.log(`listening port on $&#123;port&#125;`)&#125;)</code></pre><p>使用 <code>require(&#39;http&#39;)</code> 引用 NodeJS 自带的 http 模块。</p><p>使用 <code>createServer</code> 方法为请求绑定处理事件函数，</p><p>使用 <code>res.end(&#39;hello&#39;)</code> 来结束请求并返回 <code>hello</code> 字符串。</p><p>使用 <code>listen</code> 函数设置监听的端口，第一个参数是端口号，第二个参数是绑定成功的回调函数。</p><p>用浏览器访问127.0.0.1:3000 会显示hello</p><h3 id="简单的静态文件服务"><a href="#简单的静态文件服务" class="headerlink" title="简单的静态文件服务"></a>简单的静态文件服务</h3><pre><code class="js">const http = require(&#39;http&#39;)const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const url = require(&#39;url&#39;)const port = 3000const server = http.createServer((req, res) =&gt; &#123;    const info = url.parse(req.url)    const file = fs.createReadStream(path.resolve(__dirname, &#39;.&#39; + info.pathname))    file.pipe(res)&#125;)server.listen(port, () =&gt; &#123;    console.log(`listening port on $&#123;port&#125;`)&#125;)</code></pre><p>通过 NodeJS 自带的文件操作模块 <code>fs</code> 的 <code>createReadStream</code> 创建了一个文件流，</p><p>通过流内部方法pipe将其输出给res（响应对象）</p><p>能将对应路径的文件返回给浏览器</p><h2 id="四、课后个人总结："><a href="#四、课后个人总结：" class="headerlink" title="四、课后个人总结："></a>四、课后个人总结：</h2><p>今天的课程主要介绍了<strong>NodeJS</strong>的应用场景以及运行时结构，并且结合实例介绍了如何使用<strong>NodeJS</strong>编写简单的HTTP Server。通过今天的学习，我更加深入地了解了<strong>NodeJS</strong>，再次感受到它的强大，它可以应用于前端工程化、Web 服务端应用以及跨端桌面应用等多种场景，它的未来也是非常可观的。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/31/NodeJS%E5%9F%BA%E7%A1%80%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Slidev 用markdown写PPT！｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/30/Slidev%20%E7%94%A8markdown%E5%86%99PPT%EF%BC%81%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/30/Slidev%20%E7%94%A8markdown%E5%86%99PPT%EF%BC%81%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 30 Jan 2023 07:40:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 14 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;欢迎使用 Slid</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 14 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>欢迎使用 Slidev!为开发者打造的演示文稿工具</code></pre><p>slidev是slidevjs开发的一款开源的使用markdown来编写ppt样式的前端应用的框架</p><p>只需要在单一 Markdown 文件中编写幻灯片就可以创建一个非常漂亮的前端ppt应用</p><p>这个项目自从<code>0.20.0</code>版本我就关注来着，当时就觉得很炫很好用</p><p>昨天看到了antfu更新说在最新版本<code>0.39.0</code>里支持了简单的动画切换效果</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130155007.png"></p><p>😋感觉动画切换是ppt最重要的东西吧，很好很圆满😎</p><p>来试试</p><p><img src="https://cn.sli.dev/screenshots/cover.png" alt="img"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p><strong>支持 Markdown 语法</strong>：Slidev 使用一种扩展的 Markdown 格式，在一个纯文本文件中存储和组织你的幻灯片。这让你专注于制作内容。而且由于内容和样式是分开的，这也使得在不同的主题之间切换变得更加容易。</p></li><li><p><strong>可定制主题</strong>：Slidev 的主题可以通过 <code>npm</code> 包的形式来分享和安装。</p></li><li><p><strong>对开发者友好</strong>：Slidev 为开发者提供了一流的代码片段支持。它同时支持 <a href="https://prismjs.com/">Prism</a> 和 <a href="https://github.com/shikijs/shiki">Shiki</a> 以获得像素级的完美语法高亮，并且能够随时修改代码。通过内置的 <a href="https://microsoft.github.io/monaco-editor/">Monaco 编辑器</a>，它还能让你在演示文稿中进行现场编码&#x2F;演示，并支持自动补全、类型悬停、甚至是 <code>TypeScript</code> 类型检查。</p></li><li><p><strong>快速</strong>：Slidev 得益于 <a href="https://vitejs.dev/">Vite</a>，<a href="https://v3.vuejs.org/">Vue 3</a> 和 <a href="https://windicss.org/">Windi CSS</a>，为你带来了最美妙的创作体验。你所做的每一个改变都会<strong>立即反映</strong>到你的幻灯片上。</p></li><li><p><strong>互动性 &amp; 直观表达</strong>：你可以编写自定义的 Vue 组件并直接在你的 MarkDown 文件中使用它们。你也可以在演示文稿中与它们互动，以更深入和直观的方式表达你的想法。</p></li><li><p><strong>支持录制</strong>：Slidev 提供了内置的录音和摄像头视图。你可以将你的演示文稿与你的相机视图一起分享，或者为你的屏幕和相机分别录制并保存。所有这些都是内置的，不需要额外的工具。</p></li><li><p><strong>可移植性</strong>：用一个命令就可以将你的幻灯片导出为 PDF 或 PNG，甚至是可托管的单页应用程序（SPA），并在任何地方分享它们。</p></li><li><p><strong>可配置</strong>：由于 Slidev 基于 Web 技术，任何可以在 Web 应用中完成的事情，Slidev 也可以做到。例如，<code>WebGL</code>、<code>API请求</code>、<code>iframes</code>，甚至是实时共享。完全取决于你的想象力!</p></li><li><p><strong>演讲者模式</strong>： 可以使用另一个窗口，甚至是你的手机来控制幻灯片。</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm init slidev</code></pre><p>在package.json里配置</p><pre><code>&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;slidev&quot;, //  启动 dev server    &quot;build&quot;: &quot;slidev build&quot;, // 构建生产环境的单页面应用    &quot;export&quot;: &quot;slidev export&quot; // 将幻灯片导出为 pdf 格式  &#125;&#125;</code></pre><p>执行 <code>npx slidev --help</code> 命令获取更多选项的详细信息。</p><p>这样就安装完成了，你只需要在<code>./slides.md</code>里编写你想要的内容就行😎</p><h2 id="推荐的目录结构"><a href="#推荐的目录结构" class="headerlink" title="推荐的目录结构"></a>推荐的目录结构</h2><pre><code>your-slidev/  ├── components/       # 自定义组件  ├── layouts/          # 自定义布局  ├── public/           # 静态资源  ├── setup/            # 自定义 setup / hooks  ├── styles/           # 自定义样式  ├── index.html        # 注入的 index.html  ├── slides.md         # 幻灯片主入口  └── vite.config.ts    # 扩展 vite 配置</code></pre><h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>使用 <code>---</code> 添加分隔符来分隔你的幻灯片。</p><p>注意 这个分隔符最好上下空两行</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130162517.png"></p><p>像这样 </p><p>你可以安装一个VSCode插件 名叫slidev 来获得更好的体验，<a href="https://marketplace.visualstudio.com/items?itemName=antfu.slidev">https://marketplace.visualstudio.com/items?itemName=antfu.slidev</a></p><p>这个#2是插件告诉你这下面是第几张幻灯片</p><pre><code># SlidevHello, World!---# Page 2Directly use code blocks for highlighting```tsconsole.log(&#39;Hello, World!&#39;)```---# Page 3You can directly use Windi CSS and Vue components to style and enrich your slides.&lt;div class=&quot;p-3&quot;&gt;  &lt;Tweet id=&quot;20&quot; /&gt;&lt;/div&gt;</code></pre><p>像这样就创建了三张幻灯片</p><h4 id="扉页及布局"><a href="#扉页及布局" class="headerlink" title="扉页及布局"></a>扉页及布局</h4><p>用两个分隔符来表示一个扉页块</p><pre><code>---layout: cover---</code></pre><p>两个分隔符里是<code>yaml</code>格式的对象</p><p>具体的语法如下</p><pre><code>---# 主题id 或 主题包名称# 了解更多：https://sli.dev/themes/use.htmltheme: &#39;default&#39;# 幻灯片的总标题，如果没有指定，那么将以第一张拥有标题的幻灯片的标题作为总标题title: &#39;Slidev&#39;# titleTemplate for the webpage, `%s` will be replaced by the page&#39;s titletitleTemplate: &#39;%s - Slidev&#39;# information for your slides, can be a markdown stringinfo: false# 在单页（SPA）构建中启用 pdf 下载，也可以指定一个自定义 urldownload: false# 要导出文件的文件名称exportFilename: &#39;slidev-exported.pdf&#39;# 语法高亮设置，可以使用 &#39;prism&#39; 或 &#39;shiki&#39; 方案highlighter: &#39;prism&#39;# 在代码块中显示行号lineNumbers: false# 启用 monaco 编辑器，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;monaco: &#39;dev&#39;# 使用 vite-plugin-remote-assets 在本地下载远程资源，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;remoteAssets: false# 控制幻灯片中的文本是否可以选择selectable: true# 启用幻灯片录制，可以是 boolean，&#39;dev&#39; 或者 &#39;build&#39;record: &#39;dev&#39;# 幻灯片的配色方案，可以使用 &#39;auto&#39;，&#39;light&#39; 或者 &#39;dark&#39;colorSchema: &#39;auto&#39;# vue-router 模式，可以使用 &#39;history&#39; 或 &#39;hash&#39; 模式routerMode: &#39;history&#39;# 幻灯片的长宽比aspectRatio: &#39;16/9&#39;# canvas 的真实宽度，单位为 pxcanvasWidth: 980# 用于主题定制，会将属性 `x` 注入根样式 `--slidev-theme-x`themeConfig:  primary: &#39;#5d8392&#39;# favicon 可以是本地文件路径，也可以是一个 URLfavicon: &#39;https://cdn.jsdelivr.net/gh/slidevjs/slidev/assets/favicon.png&#39;# 用于渲染图表的 PlantUML 服务器的 URLplantUmlServer: &#39;https://www.plantuml.com/plantuml&#39;# 字体将从 Google 字体自动导入# 了解更多：https://sli.dev/custom/fontsfonts:  sans: &#39;Roboto&#39;  serif: &#39;Roboto Slab&#39;  mono: &#39;Fira Code&#39;# 为所有幻灯片添加默认的 frontmatterdefaults:  layout: &#39;default&#39;  # ...# 绘制选项# 了解更多：https://sli.dev/guide/drawing.htmldrawings:  enabled: true  persist: false  presenterOnly: false  syncAll: true---</code></pre><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>可以通过&#96;&#96;&#96;来创建一个代码块</p><pre><code>```tsconsole.log(&#39;Hello, World!&#39;)```</code></pre><p>可以通过在语言名后写大括号的形式来指定特定行高亮<code>&#123;&#125;</code></p><p>注意：行号从 1 开始计算。</p><pre><code>```ts &#123;2-3|5|all&#125;function add(  a: Ref&lt;number&gt; | number,  b: Ref&lt;number&gt; | number) &#123;  return computed(() =&gt; unref(a) + unref(b))&#125;```</code></pre><p>这段代码的意思是 点进来先是2到3行高亮，再点一下2到3不亮第5行亮，再点一下整个都亮</p><h4 id="Monaco-编辑器"><a href="#Monaco-编辑器" class="headerlink" title="Monaco 编辑器"></a>Monaco 编辑器</h4><p>只需在语言 id 后添加 <code>&#123;monaco&#125;</code> 就可以启用monaco</p><p>什么是monaco呢，可以理解为网页版的vscode那样的，可以在线编辑的</p><pre><code>```ts &#123;monaco&#125;console.log(&#39;HelloWorld&#39;)```</code></pre><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>你可以在 Markdown 中直接使用 <code>&lt;style&gt;</code> 标签来覆盖<strong>当前幻灯片</strong>的样式。</p><p>Slidev支持windicss的原子化写法和指令集 例如<code>@apply</code></p><pre><code># Slidev&gt; Hello `world`&lt;style&gt;blockquote &#123;  code &#123;    @apply text-teal-500 dark:text-teal-400;  &#125;&#125;&lt;/style&gt;</code></pre><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>和编写 Markdown 的方式一样，你可以使用本地或远程的 URL 的图片。</p><p>远程资源会缓存</p><p>本地资源请放到public文件夹</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>你也可以为每张幻灯片编写备注。它们将展示在 <a href="https://cn.sli.dev/guide/presenter-mode.html">演讲者模式</a> 中，供你在演示时参考。</p><p>在每一页幻灯片内容最后</p><p>添加注释即可</p><pre><code>---layout: cover---# 第 1 页This is the cover page.&lt;!-- 这是一条备注 --&gt;---# 第 2 页&lt;!-- 这不是一条备注，因为它在幻灯片内容前 --&gt;The second page&lt;!--这是另一条备注--&gt;</code></pre><h4 id="icon图标"><a href="#icon图标" class="headerlink" title="icon图标"></a>icon图标</h4><p>很喜欢的功能</p><p>Slidev 允许你在 Markdown 中<strong>直接</strong>访问几乎所有的开源的图标集。</p><p>你可以通过 <a href="https://icones.js.org/">Icônes</a> 来浏览访问所有可用的图标。</p><p>更详细的请看<a href="https://cn.sli.dev/guide/syntax.html#icons">https://cn.sli.dev/guide/syntax.html#icons</a></p><h4 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h4><p>这个不是很熟啊</p><p><a href="https://demo.sli.dev/starter/8">https://demo.sli.dev/starter/8</a></p><p>可以看下示例 和 文档</p><p><a href="https://katex.org/">https://katex.org/</a></p><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><p>这个东西也没怎么用过，只知道github什么的支持这种语法 基于<a href="https://github.com/mermaid-js/mermaid">https://github.com/mermaid-js/mermaid</a></p><p>被标记为 <code>mermaid</code> 的代码块将被转换为图形，例如：</p><pre><code>```mermaidsequenceDiagram  Alice-&gt;John: Hello John, how are you?  Note over Alice,John: A typical interaction```</code></pre><pre><code class="mermaid">sequenceDiagram  Alice-&gt;John: Hello John, how are you?  Note over Alice,John: A typical interaction</code></pre><p>我在typora也可以创建这个图表，感觉很好用</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130170429.png"></p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230130170544.png"></p><p>导航栏默认在左下角，鼠标移动上去显示</p><p>可以用<code>right / space</code>来切换下一张幻灯片</p><p>按<code>g</code>跳出一个栏，输入页码可以跳转</p><p>更多快捷键详见<a href="https://cn.sli.dev/guide/navigation.html#navigation-bar">https://cn.sli.dev/guide/navigation.html#navigation-bar</a></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>重头戏</p><p>这个版本就更新了这个</p><h4 id="点击动画"><a href="#点击动画" class="headerlink" title="点击动画"></a>点击动画</h4><p><code>v-click</code> 可以用<code>&lt;v-click&gt;&lt;/v-click&gt;</code>标签或在标签内写<code>&lt;div v-click class=&quot;text-xl p-2&quot;&gt;</code>这样的指令</p><p>以下指令写法同理</p><p><code>v-after</code> 和<code>v-click</code>绑定，这俩会一起显示</p><p><code>v-click-hide</code>点击后不可见</p><p><code>v-clicks</code> 只能使用标签写法 可以方便的展示一个列表</p><pre><code>&lt;v-clicks&gt;- Item 1- Item 2- Item 3- Item 4&lt;/v-clicks&gt;</code></pre><p>你还可以手动指定过渡动画 覆写两个类的动画</p><pre><code>// the default.slidev-vclick-target &#123;  transition: opacity 100ms ease;&#125;.slidev-vclick-hidden &#123;  opacity: 0;  pointer-events: none;&#125;</code></pre><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p><a href="https://vueuse.org/functions.html#category=%40Motion">https://vueuse.org/functions.html#category=%40Motion</a></p><p>内置了vueuse的motion功能</p><p>你可以对任何元素应用 <code>v-motion</code> 指令，以对它们施加运动效果。例如：</p><pre><code>&lt;div  v-motion  :initial=&quot;&#123; x: -80 &#125;&quot;  :enter=&quot;&#123; x: 0 &#125;&quot;&gt;  Slidev&lt;/div&gt;</code></pre><p>文本 <code>Slidev</code> 将从其初始化位置 <code>-80px</code> 移至其原始位置。</p><h4 id="页面过渡"><a href="#页面过渡" class="headerlink" title="页面过渡"></a>页面过渡</h4><p>🤩新功能！</p><p>可以在扉页中填写</p><pre><code>---transition: slide-left---</code></pre><p>这将给你一个很好的滑动效果。将其设置在首页，将适用于所有的幻灯片。您还可以为每张幻灯片设置不同的过渡。</p><p>自带的过渡效果</p><pre><code>fade - Crossfade in/outfade-out - Fade out and then fade inslide-left - Slides to the left, slide to right when going backslide-right - Slides to the right, slide to left when going backslide-top - Slides to the top, slide to bottom when going backslide-bottom - Slides to the bottom, slide to top when going back</code></pre><p>还可以自定义过渡效果</p><pre><code>---transition: my-transition---</code></pre><pre><code>.my-transition-enter-active,.my-transition-leave-active &#123;  transition: opacity 0.5s ease;&#125;.my-transition-enter-from,.my-transition-leave-to &#123;  opacity: 0;&#125;</code></pre><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>导出为pdf 依赖于微软开源的playwright框架</p><p><a href="https://playwright.dev/docs/installation#download-single-browser-binary"><code>playwright-chromium</code></a></p><p>需要先安装</p><pre><code>npm i -D playwright-chromium</code></pre><p>使用</p><pre><code>slidev export</code></pre><p>可导出pdf格式</p><pre><code>slidev export --format png</code></pre><p>可导出png格式</p><h2 id="静态部署"><a href="#静态部署" class="headerlink" title="静态部署"></a>静态部署</h2><pre><code>slidev build</code></pre><p>编译当前幻灯片生成在<code>dist/</code>目录下，可以部署到静态托管平台</p><h4 id="提供可下载的-PDF"><a href="#提供可下载的-PDF" class="headerlink" title="提供可下载的 PDF"></a>提供可下载的 PDF</h4><p>在扉页中设置</p><pre><code>---download: true---</code></pre><p>会在单页应用中展示下载按钮</p><p>也可以自定义url</p><pre><code>---download: &#39;https://myside.com/my-talk.pdf&#39;---</code></pre><h4 id="部署到netlify"><a href="#部署到netlify" class="headerlink" title="部署到netlify"></a>部署到netlify</h4><p>创建<code>netlify.toml</code>文件 配置</p><pre><code>[build.environment]  NODE_VERSION = &quot;14&quot;[build]  publish = &quot;dist&quot;  command = &quot;npm run build&quot;[[redirects]]  from = &quot;/*&quot;  to = &quot;/index.html&quot;  status = 200</code></pre><h4 id="部署到vercel"><a href="#部署到vercel" class="headerlink" title="部署到vercel"></a>部署到vercel</h4><p>创建<code>vercel.json</code>文件 配置</p><pre><code>&#123;  &quot;rewrites&quot;: [    &#123; &quot;source&quot;: &quot;/(.*)&quot;, &quot;destination&quot;: &quot;/index.html&quot; &#125;  ]&#125;</code></pre><h2 id="演讲录制"><a href="#演讲录制" class="headerlink" title="演讲录制"></a>演讲录制</h2><h4 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h4><p>导航面板的小人按钮可以开启摄像头</p><p>你可以拖动它，并使用右下角的把手来调整大小。尺寸和位置将持久化存储在 <code>localStorage</code> 中，因此，可以保证多次刷新后的展示一致，无需担心位置和大小丢失的问题。</p><h4 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h4><p>导航面板的摄像机按钮</p><p>可以录制麦克风和摄像头</p><h2 id="演讲者模式"><a href="#演讲者模式" class="headerlink" title="演讲者模式"></a>演讲者模式</h2><p>点击小人带麦克风的按钮</p><p>可以进入演讲者模式</p><p>需要双端在同一网络下</p><p>其他页面的实例会自动和演讲者的页面同步</p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>可以在页面上画画</p><p>可以在演讲者模式中启用，会实时自动同步</p><p>支持触控笔压感</p><h2 id="编辑器整合"><a href="#编辑器整合" class="headerlink" title="编辑器整合"></a>编辑器整合</h2><p>你可以在运行中在网页上更改你的源码，他会自动同步到slide.md里</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>在这里浏览主题并应用到你的实例中</p><p><a href="https://cn.sli.dev/themes/gallery.html">https://cn.sli.dev/themes/gallery.html</a></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><a href="https://cn.sli.dev/builtin/layouts.html">https://cn.sli.dev/builtin/layouts.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇写了不少，详细的写了我比较喜欢的ppt框架</p><p>我有一个部署的版本，地址在 <a href="https://botppt.netlify.app/">https://botppt.netlify.app/</a></p><p>是很久之前写的辣，版本还是很老的，有时间会更新一下</p><p>😎</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://botppt.netlify.app/1">https://botppt.netlify.app/1</a></p><p><a href="https://cn.sli.dev/showcases.html">https://cn.sli.dev/showcases.html</a></p><p><a href="https://cn.sli.dev/">https://cn.sli.dev/</a></p><p><a href="https://github.com/slidevjs/slidev">https://github.com/slidevjs/slidev</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/30/Slidev%20%E7%94%A8markdown%E5%86%99PPT%EF%BC%81%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt3与服务端渲染SSR（高级篇） ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/29/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/29/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sun, 29 Jan 2023 08:13:02 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 13 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前两篇写了一些nuxt3和SSR的</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 13 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两篇写了一些nuxt3和SSR的基础</p><p>这一篇讲讲nuxt3比较进阶的部分</p><h2 id="自动引入"><a href="#自动引入" class="headerlink" title="自动引入"></a>自动引入</h2><h4 id="nuxt3自带自动引入"><a href="#nuxt3自带自动引入" class="headerlink" title="nuxt3自带自动引入"></a>nuxt3自带自动引入</h4><p>包括一些nuxt3的api都是不用导入的直接就可以用</p><p>例如</p><ul><li><p>数据获取的函数<code>useFetch</code> <code>useAsyncData</code> </p></li><li><p>状态管理函数<code>useState</code> </p></li><li><p>运行变量获取函数 <code>useRuntimeConfig</code></p></li><li><p>运行时上下文获取函数 <code>useNuxtApp</code></p></li></ul><h4 id="还有一些Vue的api"><a href="#还有一些Vue的api" class="headerlink" title="还有一些Vue的api"></a>还有一些Vue的api</h4><p>例如</p><ul><li><p>响应式的函数<code>ref</code></p></li><li><p>计算属性 <code>computed</code></p></li></ul><h4 id="文件夹下的内容自动引入"><a href="#文件夹下的内容自动引入" class="headerlink" title="文件夹下的内容自动引入"></a>文件夹下的内容自动引入</h4><p>例如</p><ul><li><code>components/</code>文件夹下的组件</li><li><code>composables/</code>文件夹下的响应式函数</li><li><code>utils/</code>文件夹下的工具函数</li></ul><h4 id="可以使用-imports来使导入明确"><a href="#可以使用-imports来使导入明确" class="headerlink" title="可以使用#imports来使导入明确"></a>可以使用<code>#imports</code>来使导入明确</h4><pre><code>&lt;script setup&gt;  import &#123; ref, computed &#125; from &#39;#imports&#39;  const count = ref(1)  const double = computed(() =&gt; count.value * 2)&lt;/script&gt;</code></pre><h4 id="关闭自动引入"><a href="#关闭自动引入" class="headerlink" title="关闭自动引入"></a>关闭自动引入</h4><p>在<code>nuxtconfig</code>里加入</p><pre><code>export default defineNuxtConfig(&#123;  imports: &#123;    autoImport: false  &#125;&#125;)</code></pre><p>（😡谁会这么做</p><h2 id="自动引入的组件"><a href="#自动引入的组件" class="headerlink" title="自动引入的组件"></a>自动引入的组件</h2><p>假设目录如下</p><pre><code>| components/--| base/----| foo/------| Button.vue</code></pre><p>此时可以使用<code>&lt;BaseFooButton /&gt;</code>标签引入这个button组件</p><p>另外，可以使用一个Lazy前缀来懒加载组件</p><p>例如</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Mountains&lt;/h1&gt;    &lt;LazyMountainsList v-if=&quot;show&quot; /&gt;    &lt;button v-if=&quot;!show&quot; @click=&quot;show = true&quot;&gt;Show List&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      show: false    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>这样可以减少打包大小，增加性能</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>写在<code>pages/</code>里的组件会自动写入路由</p><p><code>pages/index.vue</code>会匹配路由<code>/</code></p><p>只需要在<code>app.vue</code>里添加</p><p><code>&lt;NuxtPage /&gt;</code>标签</p><p>可以通过插槽写法例如写<code>[id].vue</code>来匹配路由内的参数</p><p>例如如下文件树</p><pre><code>-| pages/---| index.vue---| users-[group]/-----| [id].vue</code></pre><p>在<code>[id].vue</code>里写下</p><pre><code>&lt;template&gt;  &lt;p&gt;&#123;&#123; $route.params.group &#125;&#125; - &#123;&#123; $route.params.id &#125;&#125;&lt;/p&gt;&lt;/template&gt;</code></pre><p>读取group参数和id参数</p><p>访问路由<code>/users-admins/123</code>会渲染成</p><pre><code>&lt;p&gt;admins - 123&lt;/p&gt;</code></pre><h2 id="渲染模式"><a href="#渲染模式" class="headerlink" title="渲染模式"></a>渲染模式</h2><h4 id="传统的Vue项目渲染方式为-客户端渲染"><a href="#传统的Vue项目渲染方式为-客户端渲染" class="headerlink" title="传统的Vue项目渲染方式为  客户端渲染"></a>传统的Vue项目渲染方式为  <code>客户端渲染</code></h4><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230129144946.png"></p><p>浏览器会先下载到空的html文件→下载js→渲染出来</p><p>这种方式的优点是：</p><ul><li><p>开发速度快：当完全在客户端上工作时，我们不必担心代码的服务器兼容性，例如，使用像windows这样的浏览器api。 </p></li><li><p>更便宜的服务器成本：运行一个服务器会增加一个基础设施的成本，因为您需要在一个支持JavaScript的平台上运行。我们可以在任何具有HTML、CSS和JavaScript文件的静态服务器上托管仅限客户端的应用程序。 </p></li><li><p>下载好后离线：因为代码完全在浏览器中运行，所以它可以很好地在互联网不可用时很好地保持工作。</p></li></ul><p>缺点为：</p><ul><li>性能不好：用户必须等待浏览器下载、解析和运行JavaScript文件。根据下载部分的网络和用户的解析和执行设备，这可能需要一些时间，并影响用户的体验。</li><li>不友好的搜索引擎优化：索引和更新通过客户端呈现交付的内容比使用服务器呈现的HTML文档需要更多的时间。</li></ul><h4 id="nuxt3的服务端渲染"><a href="#nuxt3的服务端渲染" class="headerlink" title="nuxt3的服务端渲染"></a>nuxt3的<code>服务端渲染</code></h4><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230129145732.png"></p><p>有内容的html文件会下载到浏览器→用户在此时可以点击和浏览页面上的内容（部分功能）→需要的组件渲染完成、此时的页面有全部功能</p><p>这种方式的优点是：</p><ul><li>性能好：用户可以立即访问页面的内容，因为浏览器显示静态内容的速度比<code>javascript</code>生成的静态内容要快得多。</li><li>搜索引擎优化：通用呈现将页面的整个HTML内容作为一个经典的服务器应用程序传递到浏览器。Web爬虫可以直接索引页面的内容。</li></ul><p>缺点是：</p><ul><li>开发约束：服务器和浏览器环境不提供相同的api，而且编写可以在两边无缝运行的代码可能会很棘手。幸运的是，Nuxt提供了特定的变量来同步这些。</li><li>成本高：服务器需要运行，才能动态地呈现页面。这就像任何传统服务器一样，增加了每月的成本。但是，由于浏览器接管了客户端导航的通用渲染，服务器调用大大减少了。</li></ul><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>使用 <code>TypeScript</code> 后可以使用nuxi带的语法检查</p><pre><code>yarn nuxi typecheck</code></pre><p>nuxt也会自动生成类型</p><p>在<a href="https://nuxt.com/docs/guide/concepts/typescript#nuxtnuxtdts"><code>.nuxt/nuxt.d.ts</code></a>目录下</p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>一个完整的nuxt3项目文件目录应该包含以下文件夹和文件</p><pre><code>.nuxt                      nuxt生成的文件目录里面有 运行的类型等.output                    build产物文件夹assets                     css文件、字体文件、图片文件components                 组件目录composables                响应式函数的文件夹content                    基于文件的cms的文件夹layouts                    布局组件的文件夹middleware                 中间件文件夹node_modules               依赖文件夹pages                      路由的页面plugins                    nuxt插件public                     公共文件文件夹，可以放ico图标，图片server                     服务端api文件夹utils                      工具函数文件夹.gitignore                 git忽略文件.nuxtignore                不加入nuxt编译的忽略文件app.config.ts              config文件 可以使用useAppConfig读取app.vue                    vue入口 nuxt.config.ts             nuxt配置文件package.json               依赖描述文件tsconfig.json              ts检查配置文件</code></pre><p><a href="https://nuxt.com/docs/guide/directory-structure/nuxt">https://nuxt.com/docs/guide/directory-structure/nuxt</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章介绍了nuxt3的高级用法</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><p>😎🥰</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/docs/guide/concepts/auto-imports">https://nuxt.com/docs/guide/concepts/auto-imports</a></p><p><a href="https://nuxt.com/docs/guide/directory-structure/composables">https://nuxt.com/docs/guide/directory-structure/composables</a></p><p><a href="https://nuxt.com/docs/guide/directory-structure/components">https://nuxt.com/docs/guide/directory-structure/components</a></p><p><a href="https://github.com/unjs/nitro">https://github.com/unjs/nitro</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/29/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>青训营任务-我的名片-可爱捏☺</title>
      <link>https://xyxsw.ltd/2023/01/28/%E3%80%8C%E9%9D%92%E8%AE%AD%E8%90%A5%20X%20%E7%A0%81%E4%B8%8A%E6%8E%98%E9%87%91%E3%80%8D%E4%B8%BB%E9%A2%98%201%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E5%90%8D%E7%89%87/</link>
      <guid>https://xyxsw.ltd/2023/01/28/%E3%80%8C%E9%9D%92%E8%AE%AD%E8%90%A5%20X%20%E7%A0%81%E4%B8%8A%E6%8E%98%E9%87%91%E3%80%8D%E4%B8%BB%E9%A2%98%201%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E5%90%8D%E7%89%87/</guid>
      <pubDate>Sat, 28 Jan 2023 14:57:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;当青训营遇上码上掘金&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;主题介绍&quot;&gt;&lt;a href=&quot;#主题介绍&quot; class=&quot;headerlink&quot; title=&quot;主题介绍&quot;&gt;&lt;/a&gt;主题介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;主题-1：我的名片&quot;&gt;&lt;a</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>当青训营遇上码上掘金</strong></p><h2 id="主题介绍"><a href="#主题介绍" class="headerlink" title="主题介绍"></a>主题介绍</h2><ul><li><h4 id="主题-1：我的名片"><a href="#主题-1：我的名片" class="headerlink" title="主题 1：我的名片"></a>主题 1：我的名片</h4>名片是向人介绍自我的重要工具，作为一名程序员用代码做自我介绍是一件非常酷炫的事情。请大家围绕“我的名片”这个主题进行代码创作。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然说整个酷炫的</p><p>直接上框架</p><p><a href="https://github.com/antfu/vitesse-webext">https://github.com/antfu/vitesse-webext</a></p><p>这个模板是基于Vue的webext（浏览器插件手脚架）</p><p>webext是一个可以帮助构建、运行和测试Web扩展的命令行工具。</p><p><a href="https://wiki.mozilla.org/WebExtensions">https://wiki.mozilla.org/WebExtensions</a></p><p>webext的目标是以一种标准的、可移植、跨平台的方式支持浏览器扩展。最初，它将为开发火狐扩展提供一个简化的体验。</p><p>我们的目标是实现一个浏览器扩展类型的名片</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>⚡️ Vite 快速构建</li><li>🥝 Vue 3 -组合式api 3.2+setup语法</li><li>💬<a href="https://github.com/antfu/webext-bridge"><code>webext-bridge</code></a> 的local storage 和 <a href="https://github.com/antfu/vueuse">VueUse</a> 的使用结合</li><li>🌈 <a href="https://github.com/unocss/unocss">UnoCSS</a> - 原子化CSS引擎</li><li>🦾 <a href="https://www.typescriptlang.org/">TypeScript</a> 语法支持</li><li>📦 <a href="https://github.com/antfu/vitesse-webext/blob/main/src/components">Components auto importing</a> 自动引入</li><li>🌍 WebExtension - 标准浏览器扩展手脚架 可以一键生成chromium、Firefox适配的扩展</li><li>😴 mv3 - manifest v3</li></ul><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>本身这个项目没什么坑的、只是</p><p>😡</p><p>浏览器在2023年抛弃manifest v2</p><p>所以使用manifest v2打包后的浏览器扩展浏览器不认</p><p>会显示</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128210235.png"></p><p>😱</p><p>还有一点就是本身不太会CSS</p><p>调CSS花了很长时间</p><p>但是unocss还是很方便的</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="vue">&lt;script setup&gt;import &#123; useImage &#125; from &#39;@vueuse/core&#39;const avatarUrl = &#39;https://s1.ax1x.com/2023/01/23/pSYuIYD.png&#39;const waka = &#39;https://wakatime.com/badge/user/84476697-3421-4720-bcdc-efb5c0fbc1b8.svg?style=flat-square&#39;const kita = &#39;https://www.z4a.net/images/2023/01/28/kita.gif&#39;const &#123; isLoading &#125; = useImage(&#123; src: avatarUrl &#125;)const &#123; isLoading_waka &#125; = useImage(&#123; src: waka &#125;)const &#123; isLoading_kita &#125; = useImage(&#123; src: kita &#125;)const to_left = () =&gt; &#123;  document.getElementsByClassName(&#39;img&#39;)[0].classList.remove(&#39;to_right&#39;)  document.getElementsByClassName(&#39;right_text&#39;)[0].classList.remove(&#39;to_right_text&#39;)  document.getElementsByClassName(&#39;right_block&#39;)[0].classList.remove(&#39;to_right_block&#39;)  document.getElementsByClassName(&#39;left_block&#39;)[0].classList.remove(&#39;to_left_block&#39;)  document.getElementsByClassName(&#39;left_img&#39;)[0].classList.remove(&#39;to_left_img&#39;)&#125;const to_right = () =&gt; &#123;  document.getElementsByClassName(&#39;img&#39;)[0].classList.add(&#39;to_right&#39;)  document.getElementsByClassName(&#39;right_text&#39;)[0].classList.add(&#39;to_right_text&#39;)  document.getElementsByClassName(&#39;right_block&#39;)[0].classList.add(&#39;to_right_block&#39;)  document.getElementsByClassName(&#39;left_block&#39;)[0].classList.add(&#39;to_left_block&#39;)  document.getElementsByClassName(&#39;left_img&#39;)[0].classList.add(&#39;to_left_img&#39;)&#125;&lt;/script&gt;&lt;template&gt;  &lt;main class=&quot;w-[384px] h-[256px] text-center text-light-700 bg-[#f69db2] font-sans&quot;&gt;    &lt;div class=&quot;h-100% w-100% flex flex-row justify-between p-5 items-center gap-5&quot;&gt;      &lt;div class=&quot;absolute left-0 top-0 translate-x-[-100%]&quot;&gt;        &lt;div class=&quot;flex flex-col justify-end left_block duration-700 &quot;&gt;          &lt;div class=&quot;bg-[#60c5e7] p-5&quot; /&gt;          &lt;div class=&quot;bg-[#f3d263] p-5&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;absolute left-0 top-0 translate-x-[-100%]&quot;&gt;        &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-11.5 py-16 text-center font-black&quot;&gt;Loading&lt;/span&gt;        &lt;img v-else :src=&quot;kita&quot; class=&quot;left_img duration-400&quot;&gt;      &lt;/div&gt;      &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-11.5 py-16 text-center font-black&quot;&gt;Loading&lt;/span&gt;      &lt;img v-else :src=&quot;avatarUrl&quot; class=&quot;w-35 h-35 img duration-700&quot;&gt;      &lt;div class=&quot;flex flex-col gap-5 h-119%&quot;&gt;        &lt;div class=&quot;flex flex-row justify-end translate-x-4.9 right_block duration-700 &quot;&gt;          &lt;div class=&quot;bg-[#60c5e7] p-5&quot; /&gt;          &lt;div class=&quot;bg-[#f3d263] p-5&quot; /&gt;        &lt;/div&gt;        &lt;div class=&quot;flex flex-col gap-5 pt-8 right_text duration-700 &quot;&gt;          &lt;div class=&quot;text-center font-bold text-lg text-[#df4b57]&quot;&gt;            👋  Hi, I’m  @camera-2018          &lt;/div&gt;          &lt;span v-if=&quot;isLoading&quot; class=&quot;animate-pulse bg-[#0A4445] px-15 text-center font-black&quot;&gt;Loading&lt;/span&gt;          &lt;a v-else href=&quot;https://wakatime.com/@84476697-3421-4720-bcdc-efb5c0fbc1b8&quot;&gt;&lt;img :src=&quot;waka&quot; alt=&quot;Total time coded since May 9 2022&quot;&gt;&lt;/a&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;footer class=&quot;bg-[#f69db2] &quot;&gt;      &lt;button class=&quot;i-carbon-caret-left hover:bg-[#1DCED1] bg-light-50&quot; @click=&quot;to_left&quot; /&gt;      &lt;button class=&quot;i-carbon-caret-right hover:bg-[#1DCED1] bg-light-50&quot; @click=&quot;to_right&quot; /&gt;    &lt;/footer&gt;  &lt;/main&gt;&lt;/template&gt;&lt;style&gt;.to_right&#123;  @apply translate-x-142% transition&#125;.to_right_text &#123;  @apply translate-x-190% transition&#125;.to_right_block &#123;  @apply translate-y-[-120%] transition&#125;.to_left_block &#123;  @apply translate-x-100% transition&#125;.to_left_img &#123;  @apply translate-x-90% transition&#125;&lt;/style&gt;</code></pre><p>主要的代码就这么多</p><h3 id="大概思路是"><a href="#大概思路是" class="headerlink" title="大概思路是"></a>大概思路是</h3><ol><li><p>通过unocss的预设添加使用@apply的样式</p></li><li><p>再通过js添加样式到元素上</p></li><li><p>使用过渡效果 添加过渡时间</p></li><li><p>图片加载部分使用vueuse的useImage 没加载出来之前是有个loading的界面</p></li><li><p>使用了一个wakatime的svg展示最近敲代码时间点击可看</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/GIF%202023-1-28%2020-45-47.gif"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128213920.png"></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128214002.png"></p><h2 id="灵感"><a href="#灵感" class="headerlink" title="灵感"></a>灵感</h2><p><a href="https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C">https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C</a></p><p>复刻了孤独摇滚 后藤一里 的配色 右上角或左上角的方块为波奇酱的发饰</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>代码开源于</p><p><a href="https://github.com/camera-2018/business-card-mv3">https://github.com/camera-2018/business-card-mv3</a></p><p>可以在<a href="https://github.com/camera-2018/business-card-mv3/releases">Releases</a>中下载编译好的扩展 解压然后点击浏览器的扩展程序选项卡 <code>chrome://extensions/</code></p><p>记得要开右上角的开发者模式哦</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128212633.png"></p><p>然后加载已解压的扩展程序就可以了</p><h2 id="popup部分代码"><a href="#popup部分代码" class="headerlink" title="popup部分代码"></a>popup部分代码</h2><p><a href="https://github.com/camera-2018/business-card-mv3/tree/refactor/mv3/src/popup">popup</a>部分代码放在码上掘金上</p><p><a href="https://code.juejin.cn/api/raw/7193666089241772090?id=7193666089241821242">https://code.juejin.cn/api/raw/7193666089241772090?id=7193666089241821242</a></p><p>由于依赖比较多，而码上掘金拉不到cdnjsdelivr的数据</p><p>所以在码上掘金上是无法正常显示的😥 想试试的话请去<a href="https://github.com/camera-2018/business-card-mv3%E6%BA%90%E7%A0%81">https://github.com/camera-2018/business-card-mv3源码</a></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230128213154.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://code.juejin.cn/pen/7193666089241772090">https://code.juejin.cn/pen/7193666089241772090</a></p><p><a href="https://juejin.cn/post/7187753682421678137">https://juejin.cn/post/7187753682421678137</a></p><p><a href="https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C">https://mzh.moegirl.org.cn/%E5%90%8E%E8%97%A4%E4%B8%80%E9%87%8C</a></p><p><a href="https://github.com/antfu/vitesse-webext">https://github.com/antfu/vitesse-webext</a></p>]]></content:encoded>
      
      
      
      
      <comments>https://xyxsw.ltd/2023/01/28/%E3%80%8C%E9%9D%92%E8%AE%AD%E8%90%A5%20X%20%E7%A0%81%E4%B8%8A%E6%8E%98%E9%87%91%E3%80%8D%E4%B8%BB%E9%A2%98%201%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E5%90%8D%E7%89%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt3与服务端渲染SSR（下） ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/28/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8B%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/</link>
      <guid>https://xyxsw.ltd/2023/01/28/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8B%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/</guid>
      <pubDate>Sat, 28 Jan 2023 13:37:03 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 12 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇文章介绍了大概一半的nuxt</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 12 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章介绍了大概一半的nuxt3特性，这一篇会介绍另外一半</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>Nuxt利用Vue的 <a href="https://vuejs.org/guide/built-ins/transition.html#the-transition-component"><code>&lt;Transition&gt;</code></a>组件来应用页面和布局之间的转换。</p><p>只需要在nuxt config里设置</p><pre><code class="js">export default defineNuxtConfig(&#123;  app: &#123;    pageTransition: &#123; name: &#39;page&#39;, mode: &#39;out-in&#39; &#125;  &#125;,&#125;)</code></pre><p>然后在<code>app.vue</code>里设置你想要的过渡动画</p><pre><code class="vue">&lt;template&gt;  &lt;NuxtPage /&gt;&lt;/template&gt;&lt;style&gt;.page-enter-active,.page-leave-active &#123;  transition: all 0.4s;&#125;.page-enter-from,.page-leave-to &#123;  opacity: 0;  filter: blur(1rem);&#125;&lt;/style&gt;</code></pre><p>类名必须是这几个</p><p>就可以实现一个切换页面有虚化效果的动画</p><p>更高级的用法详见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/transitions">https://nuxt.com/docs/getting-started/transitions</a></p><h2 id="使用Api获取数据"><a href="#使用Api获取数据" class="headerlink" title="使用Api获取数据"></a>使用Api获取数据</h2><p>nuxt3自带一个<code>vueuse</code>里的 <code>useFetch</code> api</p><p>使用方法为</p><pre><code>&lt;script setup&gt;const &#123; data: count &#125; = await useFetch(&#39;/api/count&#39;)&lt;/script&gt;&lt;template&gt;  Page visits: &#123;&#123; count &#125;&#125;&lt;/template&gt;</code></pre><p>可以使用<code>useAsyncData</code>来异步获取数据</p><pre><code>&lt;script setup&gt;const &#123; data &#125; = await useAsyncData(&#39;count&#39;, () =&gt; $fetch(&#39;/api/count&#39;))&lt;/script&gt;&lt;template&gt;  Page visits: &#123;&#123; data &#125;&#125;&lt;/template&gt;</code></pre><p>更高级的用法详见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/data-fetching">https://nuxt.com/docs/getting-started/data-fetching</a></p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>nuxt3提供了<code>vueuse</code>的一个api叫<code>useState</code>来实现全局状态管理</p><p>无需创建state文件</p><p>直接使用</p><pre><code>&lt;script setup&gt;const counter = useState(&#39;counter&#39;, () =&gt; Math.round(Math.random() * 1000))&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    Counter: &#123;&#123; counter &#125;&#125;    &lt;button @click=&quot;counter++&quot;&gt;      +    &lt;/button&gt;    &lt;button @click=&quot;counter--&quot;&gt;      -    &lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>这个例子创建了一个state叫counter 里面默认记录了一个随机数</p><p>点击按钮会让随机数进行加减</p><p><code>useState</code>默认为响应式 很方便</p><p>nuxt3的auto import特性可以使state简写为</p><pre><code>const counter = useCounter() // Same as useState(&#39;counter&#39;)</code></pre><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>nuxt提供了很多高级的错误处理方式</p><p>一个最简单的api是<code>useError</code></p><pre><code>const error = useError()</code></pre><p>这句代码可以快速的抛出一条错误</p><p>也可以使用<code>createError</code>方法</p><pre><code>&lt;script setup&gt;const route = useRoute()const &#123; data &#125; = await useFetch(`/api/movies/$&#123;route.params.slug&#125;`)if (!data.value) &#123;  throw createError(&#123; statusCode: 404, statusMessage: &#39;Page Not Found&#39; &#125;)&#125;&lt;/script&gt;</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>正常的使用<code>nuxt build</code>命令会生成一个在node环境中运行的运行时</p><p><code>.mjs文件</code></p><pre><code class="sh">node .output/server/index.mjs</code></pre><p>即可运行</p><pre><code class="bash">$ node .output/server/index.mjsListening on http://localhost:3000</code></pre><p>可以设置环境变量例如</p><pre><code>PORT=3001 node .output/server/index.mjs</code></pre><p>在3001端口运行</p><p>在 <code>nuxt.config</code> 里添加</p><pre><code>export default &#123;  nitro: &#123;    preset: &#39;node-server&#39;  &#125;&#125;</code></pre><p>或者<code>NITRO_PRESET=node-server nuxt build</code></p><p>preset字段可以更改生成的代码的依赖平台</p><p>支持的平台有</p><ul><li><a href="https://nitro.unjs.io/deploy/providers/aws">AWS</a></li><li><a href="https://nitro.unjs.io/deploy/providers/azure">Azure</a></li><li><a href="https://nitro.unjs.io/deploy/providers/cleavr">Cleavr</a></li><li><a href="https://nitro.unjs.io/deploy/providers/cloudflare">CloudFlare</a></li><li><a href="https://nitro.unjs.io/deploy/providers/digitalocean">Digital Ocean</a></li><li><a href="https://nitro.unjs.io/deploy/providers/firebase">Firebase</a></li><li><a href="https://nitro.unjs.io/deploy/providers/heroku">heroku</a></li><li><a href="https://nitro.unjs.io/deploy/providers/edgio">Edgio</a></li><li><a href="https://nitro.unjs.io/deploy/providers/netlify">Netlify</a></li><li><a href="https://nitro.unjs.io/deploy/providers/render">Render</a></li><li><a href="https://nitro.unjs.io/deploy/providers/stormkit">Stormkit</a></li><li><a href="https://nitro.unjs.io/deploy/providers/vercel">Vercel</a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>可以添加vitest库来进行测试</p><pre><code>yarn add --dev @nuxt/test-utils vitest</code></pre><p>方法如下</p><p>新建test目录 创建文件 <code>demo.test.ts</code></p><pre><code class="ts">import &#123; describe, test &#125; from &#39;vitest&#39;import &#123; setup, $fetch &#125; from &#39;@nuxt/test-utils&#39;describe(&#39;My test&#39;, async () =&gt; &#123;  await setup(&#123;    // test context options  &#125;)  test(&#39;my test&#39;, () =&gt; &#123;    // ...  &#125;)&#125;)</code></pre><p>运行vitest即可获得通过或不通过提示</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到这里nuxt3基础就几乎结束了</p><p>还有一些更高级的用法没有讲，例如生命周期啊，nuxt-kit啊，自动导入啊</p><p>有机会可以写一篇高级教程</p><p>😋😎</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/docs/getting-started/state-management">https://nuxt.com/docs/getting-started/state-management</a></p><p><a href="https://nuxt.com/docs/api/composables/use-state">https://nuxt.com/docs/api/composables/use-state</a></p><p><a href="https://juejin.cn/post/7193305766692913189">https://juejin.cn/post/7193305766692913189</a></p><p><a href="https://vueuse.org/">https://vueuse.org/</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/28/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8B%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt3与服务端渲染SSR（上） ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/27/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8A%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/27/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8A%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Fri, 27 Jan 2023 10:41:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 11 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nuxt同时提供了前端和后端功能，</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 11 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nuxt同时提供了前端和后端功能，因此您可以专注于重要的事情：创建web应用程序。</p><p><a href="https://nuxt.com/docs">Nuxt3</a> 是基于 <code>Vite</code>、<code>Vue3</code> 和 <code>Nitro</code> 的 <code>Nuxt</code> 框架的重构，具有一流的 <code>Typescript</code> 支持，且这次更新对内核进行了精简，使之速度更快，体验更好。</p><h2 id="了解-SSR"><a href="#了解-SSR" class="headerlink" title="了解 SSR"></a>了解 <code>SSR</code></h2><p><code>Nuxt</code> 是一个基于 <code>Vue.js</code> 的服务端渲染应用框架</p><h3 id="什么是-SSR"><a href="#什么是-SSR" class="headerlink" title="什么是 SSR"></a>什么是 <code>SSR</code></h3><p><code>服务器端渲染</code>（Server-Side Rendering）是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p><p>简单理解就是html是由服务端写出，可以动态改变页面内容，即所谓的动态页面。早年的 php 、 asp 、 jsp  这些 Server page 都是 SSR 的。</p><h3 id="为什么使用-SSR"><a href="#为什么使用-SSR" class="headerlink" title="为什么使用 SSR"></a>为什么使用 <code>SSR</code></h3><ul><li>网页内容在服务器端渲染完成，一次性传输到浏览器，所以 <code>首屏加载速度非常快</code>；</li><li><code>有利于SEO</code>，因为服务器返回的是一个完整的 html，在浏览器可以看到完整的 dom，对于爬虫、百度搜索等引擎就比较友好；</li></ul><h2 id="Nuxt-3"><a href="#Nuxt-3" class="headerlink" title="Nuxt 3"></a>Nuxt 3</h2><p><code>Nuxt</code> 是一个基于 <code>Vue.js</code> 的服务端渲染应用框架，</p><p>刚去查了一下 nuxt3在1月23日变成了默认版本</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003129.png"></p><p>在1月25日发布了3.1.0版本</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127185726.png"></p><ul><li><p>实验组件群岛 准备就绪</p></li><li><p>新的api</p></li><li><p>Nitro v2 ，vite 4 ，rollup3</p></li><li><p>性能改进</p></li></ul><h2 id="什么是Nuxt？"><a href="#什么是Nuxt？" class="headerlink" title="什么是Nuxt？"></a>什么是Nuxt？</h2><p>要理解Nuxt是什么，我们需要了解创建一个现代应用程序需要什么：</p><ul><li>JavaScript框架： 一个带来JavaScript组件的JavaScript框架，支持Vue.js。</li><li>打包工具：支持开发中的热模块替换和生产代码，支持webpack 5和Vite。</li><li>最新JavaScript语法：在支持遗留浏览器的同时编写最新的JavaScript语法的转换器，支持esbuild。</li><li>服务器端：Nuxt是一个在开发中服务于应用程序的服务器，同时也支持服务器端呈现或API路由，它使用h3进行部署的多功能性，如serverless, workers, Node.js和无与伦比的性能。</li><li>路由：一个处理客户端导航的路由库，支持 <a href="https://router.vuejs.org/">vue-router</a>.。</li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p><a href="https://nuxt.com/docs/getting-started/installation#prerequisites">https://nuxt.com/docs/getting-started/installation#prerequisites</a></p><pre><code class="bash">pnpm dlx nuxi init &lt;project-name&gt;</code></pre><pre><code class="bash">code &lt;project-name&gt;</code></pre><pre><code class="bash"># Make sure you have `shamefully-hoist=true` in `.npmrc` before running pnpm installpnpm install</code></pre><p><strong>注意：</strong> 如果你用 <code>pnpm</code> 安装依赖，请创建一个 <code>.npmrc</code> 文件，且设置:</p><pre><code class="ini">shamefully-hoist=true</code></pre><p>安装完成😋</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code class="bash">pnpm dev -o</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127193306.png"></p><p>看一眼文件树</p><p>抛开编译结果<code>.nuxt</code>文件夹不谈 就只有一个<code>app.vue</code> 和<code>nuxt.config.ts</code></p><p>很简陋 怎么会这样呢？我们一般写的vue框架也不是这样的啊</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127193603.png"></p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>创建 <code>components/</code> <code>pages/</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230127200417.png"></p><p>具体操作见官方文档</p><p><a href="https://nuxt.com/docs/getting-started/views">https://nuxt.com/docs/getting-started/views</a></p><p>也可以新建<code>src</code>目录 把 <code>components/</code> <code>pages/</code>目录放到<code>src</code>里</p><p>在nuxt里组件是自动导入的，不用配置</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>路由是自动创建的</p><pre><code class="html">&lt;NuxtLink to=&quot;/about&quot;&gt;About&lt;/NuxtLink&gt;</code></pre><p>以上的代码点击会自动跳到<code>page/about.vue</code></p><p>也可以使用路由</p><pre><code class="vue">&lt;script setup&gt;const route = useRoute()// When accessing /posts/1, route.params.id will be 1console.log(route.params.id)&lt;/script&gt;</code></pre><p><code>/posts/1</code>是创建的<code>/posts/[id].vue</code>这样id会被当做props传入</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>nuxt服务端渲染最重要的就是搜索引擎优化</p><p>可以被拉取到带内容的html</p><p>而不是一般vue项目的空html</p><pre><code class="js">export default defineNuxtConfig(&#123;  app: &#123;    head: &#123;      charset: &#39;utf-16&#39;,      viewport: &#39;width=500, initial-scale=1&#39;,      title: &#39;My App&#39;,      meta: [        // &lt;meta name=&quot;description&quot; content=&quot;My amazing site&quot;&gt;        &#123; name: &#39;description&#39;, content: &#39;My amazing site.&#39; &#125;      ],    &#125;  &#125;&#125;)</code></pre><p>在<code>nuxt.config.ts</code>配置如上内容</p><p>或者在<code>app.vue</code>里添加</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;useHead(&#123;  title: &#39;My App&#39;,  meta: [    &#123; name: &#39;description&#39;, content: &#39;My amazing site.&#39; &#125;  ],  bodyAttrs: &#123;    class: &#39;test&#39;  &#125;,  script: [ &#123; children: &#39;console.log(\&#39;Hello world\&#39;)&#39; &#125; ]&#125;)useServerSeoMeta(&#123;  title: &#39;My Amazing Site&#39;,  ogTitle: &#39;My Amazing Site&#39;,  description: &#39;This is my amazing site, let me tell you all about it.&#39;,  ogDescription: &#39;This is my amazing site, let me tell you all about it.&#39;,  ogImage: &#39;https://example.com/image.png&#39;,  twitterCard: &#39;summary_large_image&#39;,&#125;)&lt;/script&gt;</code></pre><p>这几个函数可以添加meta头</p><p>还有一些设置可以看官方文档 <a href="https://nuxt.com/docs/getting-started/seo-meta">https://nuxt.com/docs/getting-started/seo-meta</a></p><p>也可以使用 <a href="https://nuxt.com/modules/seo-kit">https://nuxt.com/modules/seo-kit</a></p><p>这个模块来配置SEO</p><p>很方便😎</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇文章介绍了大概一半的nuxt3特性，下一篇会介绍另外一半</p><p>我也是第一次使用nuxt3来开发项目</p><p>踩到的坑还是很多的，预计可以写一篇踩坑记录</p><p>😎</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nuxt.com/modules/seo-kit">https://nuxt.com/modules/seo-kit</a></p><p><a href="https://nuxt.com/docs/getting-started/seo-meta">https://nuxt.com/docs/getting-started/seo-meta</a></p><p><a href="https://nuxt.com/docs/getting-started/views">https://nuxt.com/docs/getting-started/views</a></p><p><a href="https://nuxt.com/docs">https://nuxt.com/docs</a></p><p><a href="https://juejin.cn/post/7170746000112353293">https://juejin.cn/post/7170746000112353293</a></p><p><a href="https://juejin.cn/post/7037336504418435103">https://juejin.cn/post/7037336504418435103</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/27/Nuxt3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%EF%BC%88%E4%B8%8A%EF%BC%89%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>UnoCSS实战 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/26/UnoCSS%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/26/UnoCSS%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Thu, 26 Jan 2023 15:00:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 10 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原子化css体验&lt;/p&gt;
&lt;p&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 10 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原子化css体验</p><p><a href="https://link.juejin.cn/?target=https://antfu.me/posts/reimagine-atomic-css-zh">重新构想原子化 CSS (antfu.me)</a></p><p>本篇介绍一下如何配置UnoCSS、UnoCSS怎么使用</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先创建一个vite模板   <a href="https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project">https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project</a></p><p>这里使用pnpm</p><pre><code class="bash">pnpm create vite</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126210343.png"></p><p>选择vue、typescript</p><pre><code class="bash">cd vite-projectpnpm installpnpm run dev</code></pre><p>运行一下</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126210518.png"></p><p>初始化成功了，接下来安装unocss  <a href="https://github.com/unocss/unocss/tree/main/packages/vite">https://github.com/unocss/unocss/tree/main/packages/vite</a></p><p>使用文档给的vite安装方式</p><pre><code class="bash">pnpm i -D unocss</code></pre><p>在vite config里写上</p><pre><code class="ts">// vite.config.tsimport UnoCSS from &#39;unocss/vite&#39;export default &#123;  plugins: [    UnoCSS(&#123; /* options */ &#125;),  ],&#125;</code></pre><p>配置完全的vite config是这样的</p><pre><code class="ts">// vite.config.tsimport &#123; defineConfig &#125; from &#39;vite&#39;import vue from &#39;@vitejs/plugin-vue&#39;import UnoCSS from &#39;unocss/vite&#39;import &#123; presetUno &#125; from &#39;unocss&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    UnoCSS(&#123;      presets: [        presetUno(),      ],    &#125;),  ],&#125;)</code></pre><p>然后在<code>main.ts</code>里加入</p><pre><code class="ts">// main.tsimport &#39;uno.css&#39;</code></pre><p>这里没有eslint还是很不舒服的，推荐一个antfu的eslint配置，来安装一下eslint</p><p><a href="https://github.com/antfu/eslint-config">https://github.com/antfu/eslint-config</a></p><pre><code class="bash">pnpm add -D eslint @antfu/eslint-config</code></pre><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126211558.png"></p><p>创建<code>.eslintrc</code>写入</p><pre><code>&#123;  &quot;extends&quot;: &quot;@antfu&quot;&#125;</code></pre><p>在package json里加入</p><pre><code class="json">&#123;  &quot;scripts&quot;: &#123;    &quot;lint&quot;: &quot;eslint .&quot;,    &quot;lint:fix&quot;: &quot;eslint . --fix&quot;  &#125;&#125;</code></pre><p>如果你使用的是VSCode 下载 <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">VS Code ESLint extension</a> 然后编辑 <code>.vscode/settings.json</code></p><pre><code class="json">&#123;  &quot;prettier.enable&quot;: false,  &quot;editor.formatOnSave&quot;: false,  &quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true  &#125;&#125;</code></pre><p>之后重启vscode</p><p>安装完成😎</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们来写一个小demo</p><p>就把原本的默认界面改成unocss好了</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126212340.png"></p><p>先看app.vue</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;/vite.svg&quot; class=&quot;logo&quot; alt=&quot;Vite logo&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;logo vue&quot; alt=&quot;Vue logo&quot;&gt;    &lt;/a&gt;  &lt;/div&gt;  &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;.logo &#123;  height: 6em;  padding: 1.5em;  will-change: filter;&#125;.logo:hover &#123;  filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123;  filter: drop-shadow(0 0 2em #42b883aa);&#125;&lt;/style&gt;</code></pre><p>改成原子化css的形式</p><p>这里最好先配置一下vite config 多加一点预设</p><pre><code class="ts">// vite.config.tsimport &#123; defineConfig &#125; from &#39;vite&#39;import vue from &#39;@vitejs/plugin-vue&#39;import UnoCSS from &#39;unocss/vite&#39;import &#123; presetAttributify, presetIcons, presetTypography, presetUno, presetWebFonts, transformerDirectives, transformerVariantGroup &#125; from &#39;unocss&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    UnoCSS(      &#123;        presets: [          presetUno(),          presetAttributify(),          presetIcons(&#123;            scale: 1.2,          &#125;),          presetTypography(),          presetWebFonts(&#123;            fonts: &#123;              sans: &#39;DM Sans&#39;,              serif: &#39;DM Serif Display&#39;,              mono: &#39;DM Mono&#39;,            &#125;,          &#125;),        ],        transformers: [          transformerDirectives(),          transformerVariantGroup(),        ],      &#125;,    ),  ],&#125;)</code></pre><p>我们先用@apply将css改一下 <code>&lt;style scoped&gt;</code></p><pre><code class="css">.logo &#123;  height: 6em;  padding: 1.5em;  will-change: filter;&#125;.logo:hover &#123;  filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123;  filter: drop-shadow(0 0 2em #42b883aa);&#125;</code></pre><p>这里不会的语法可以看tailwindcss文档</p><p>改成</p><pre><code class="css">.logo &#123;  @apply h-6em p-1.5em&#125;.logo &#123;  @apply hover:drop-shadow-[0_0_2em_#646cffaa]&#125;.logo.vue &#123;  @apply hover:drop-shadow-[0_0_2em_#42b883aa]&#125;</code></pre><p>怎么样？是不是感觉很清晰明了</p><p>这是在tailwindcss里很受欢迎的@apply命令 通过预设导入了unocss</p><p>但是这样体现不出原子化css的方便，虽然非常好看</p><p>我们把css写入html</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;/vite.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#646cffaa]&quot; alt=&quot;Vite logo&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt;      &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;hover:drop-shadow-[0_0_2em_#42b883aa]&quot; alt=&quot;Vue logo&quot;&gt;    &lt;/a&gt;  &lt;/div&gt;  &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>这样写就很方便了</p><p>再看<code>HelloWorld.vue</code></p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;card&quot;&gt;    &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;count is &#123;&#123; count &#125;&#125;&lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot;      &gt;create-vue&lt;/a    &gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;read-the-docs&quot;&gt;Click on the Vite and Vue logos to learn more&lt;/p&gt;&lt;/template&gt;&lt;style scoped&gt;.read-the-docs &#123;  color: #888;&#125;&lt;/style&gt;</code></pre><p>这个改的比较少</p><pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;card&quot;&gt;    &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;      count is &#123;&#123; count &#125;&#125;    &lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot;&gt;create-vue&lt;/a&gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;text-[#888]&quot;&gt;    Click on the Vite and Vue logos to learn more  &lt;/p&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>改成这样就行</p><p>再看<code>style.css</code>文件 内容比较多</p><pre><code class="css">:root &#123;  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;  font-size: 16px;  line-height: 24px;  font-weight: 400;  color-scheme: light dark;  color: rgba(255, 255, 255, 0.87);  background-color: #242424;  font-synthesis: none;  text-rendering: optimizeLegibility;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  -webkit-text-size-adjust: 100%;&#125;a &#123;  font-weight: 500;  color: #646cff;  text-decoration: inherit;&#125;a:hover &#123;  color: #535bf2;&#125;body &#123;  margin: 0;  display: flex;  place-items: center;  min-width: 320px;  min-height: 100vh;&#125;h1 &#123;  font-size: 3.2em;  line-height: 1.1;&#125;button &#123;  border-radius: 8px;  border: 1px solid transparent;  padding: 0.6em 1.2em;  font-size: 1em;  font-weight: 500;  font-family: inherit;  background-color: #1a1a1a;  cursor: pointer;  transition: border-color 0.25s;&#125;button:hover &#123;  border-color: #646cff;&#125;button:focus,button:focus-visible &#123;  outline: 4px auto -webkit-focus-ring-color;&#125;.card &#123;  padding: 2em;&#125;#app &#123;  max-width: 1280px;  margin: 0 auto;  padding: 2rem;  text-align: center;&#125;@media (prefers-color-scheme: light) &#123;  :root &#123;    color: #213547;    background-color: #ffffff;  &#125;  a:hover &#123;    color: #747bff;  &#125;  button &#123;    background-color: #f9f9f9;  &#125;&#125;</code></pre><p>一点点儿改</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230126221543.png"></p><p>最后改成了这样 还挺还原的是不是</p><p>有一些媒体查询不会改</p><p>根元素没改</p><p>代码如下</p><pre><code class="css">// style.css:root &#123;  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;  font-size: 16px;  line-height: 24px;  font-weight: 400;  color-scheme: light dark;  color: rgba(255, 255, 255, 0.87);  background-color: #242424;  font-synthesis: none;  text-rendering: optimizeLegibility;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  -webkit-text-size-adjust: 100%;&#125;@media (prefers-color-scheme: light) &#123;  :root &#123;    color: #213547;    background-color: #ffffff;  &#125;  a:hover &#123;    color: #747bff;  &#125;  button &#123;    background-color: #f9f9f9;  &#125;&#125;</code></pre><pre><code class="vue">// HelloWorld.vue&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;defineProps&lt;&#123; msg: string &#125;&gt;()const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;h1 class=&quot;text-3.2em leading-tight&quot;&gt;    &#123;&#123; msg &#125;&#125;  &lt;/h1&gt;  &lt;div class=&quot;p-2em flex flex-col place-items-center&quot;&gt;    &lt;button      type=&quot;button&quot; class=&quot;      rounded-8px border-1px border-solid border-transparent      py-0.6em px-1.2em text-1em font-medium      bg-[#1a1a1a] cursor-pointer transition duration-250      hover:border-color-[#646cff]      focus:outline-4 focus:outline-[-webkit-focus-ring-color]      focus-visible:outline-4 focus-visible:outline-[-webkit-focus-ring-color]    &quot; @click=&quot;count++&quot;    &gt;      count is &#123;&#123; count &#125;&#125;    &lt;/button&gt;    &lt;p&gt;      Edit      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR    &lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;    Check out    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;create-vue&lt;/a&gt;, the official Vue + Vite starter  &lt;/p&gt;  &lt;p&gt;    Install    &lt;a href=&quot;https://github.com/johnsoncodehk/volar&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;Volar&lt;/a&gt;    in your IDE for a better DX  &lt;/p&gt;  &lt;p class=&quot;text-[#888]&quot;&gt;    Click on the Vite and Vue logos to learn more  &lt;/p&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code class="vue">// App.vue&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;m-0 flex flex-col place-items-center min-w-320px min-h-100vh&quot;&gt;    &lt;div class=&quot;max-w-1280px my-0 mx-auto p-2rem text-center&quot;&gt;      &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;        &lt;img src=&quot;/vite.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#646cffaa]&quot; alt=&quot;Vite logo&quot;&gt;      &lt;/a&gt;      &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot; class=&quot;font-medium color-[#646cff] hover:color-[#535bf2]&quot;&gt;        &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;h-6em p-1.5em hover:drop-shadow-[0_0_2em_#42b883aa]&quot; alt=&quot;Vue logo&quot;&gt;      &lt;/a&gt;    &lt;/div&gt;    &lt;HelloWorld msg=&quot;Vite + Vue&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>可以看出来虽然写的简单，但是还是比较乱</p><p>这样写的好处是，不用想类名，</p><p>如果加了@apply会更美观，但是还是要写类名，和普通css的区别就是简单了一些</p><p>同时还有一些自带的样式预设</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇我们介绍了UnoCSS的特点，UnoCSS的使用，还是改了挺长时间的，主要是不会写语法，要查tailwind文档 <a href="https://tailwindcss.com/docs">https://tailwindcss.com/docs</a></p><p>还有一些好几个值的css 不知道什么意思</p><pre><code class="css">outline: green solid 3px;/* mdn:颜色 | 样式 | 宽度 */</code></pre><pre><code class="css">outline: 4px auto -webkit-focus-ring-color;/* style.css */</code></pre><p>关于这种就不知道怎么写</p><p>最后只能掰成</p><pre><code>focus:outline-4 focus:outline-[-webkit-focus-ring-color]</code></pre><p>题外话：</p><blockquote><p>Anthony Fu大佬真的是我目前的偶像，狂热的开源爱好者，人长得又帅，做的东西又好</p></blockquote><p>🤣这是我在掘金搜unocss搜到的一篇文章中的第一句话 文章在这 <a href="https://juejin.cn/post/7028841960752283656">https://juejin.cn/post/7028841960752283656</a></p><p>antfu大佬确实也是我的偶像</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125225032.png"></p><p>22年秋季 antfu大佬在b站办过几场直播写代码，我基本上是每期必看，这个人非常有意思，有很多新鲜的点子，狠活也多 比如说</p><p><a href="https://github.com/antfu/1990-script">https://github.com/antfu/1990-script</a> 这个仓库教你怎么把GitHub历史穿越回1990年🤭</p><p>他的每个star比较多的仓库我都体验过，感觉设计灵感真的让人眼前一亮，启发基于社区，创造更快的轮子，更好玩的轮子</p><p><a href="https://github.com/antfu/retypewriter">https://github.com/antfu/retypewriter</a> 这个是直播写的雏形 让写的代码在vsc里回放，便于理清思路</p><p><a href="https://github.com/antfu/vue-minesweeper">https://github.com/antfu/vue-minesweeper</a> 这个是首次直播写的扫雷，很清晰的vue代码，看他写真的开窍</p><p><a href="https://github.com/antfu/vue-starport">https://github.com/antfu/vue-starport</a> 这个也是直播写的雏形，为了使组件有更好的过渡</p><p>就说这么多，人也长得帅</p><p>🥰😘</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">https://developer.mozilla.org/zh-CN/docs/Web/CSS</a></p><p><a href="https://tailwindcss.com/docs">https://tailwindcss.com/docs</a></p><p><a href="https://www.tailwindcss.cn/docs/functions-and-directives#apply">https://www.tailwindcss.cn/docs/functions-and-directives#apply</a></p><p><a href="https://github.com/unocss/unocss">https://github.com/unocss/unocss</a></p><p><a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/26/UnoCSS%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>原子化CSS｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/25/%E5%8E%9F%E5%AD%90%E5%8C%96CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/25/%E5%8E%9F%E5%AD%90%E5%8C%96CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 25 Jan 2023 13:12:53 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 9 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原子化 CSS是一个很新颖的定义 出</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 9 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原子化 CSS是一个很新颖的定义 出自<a href="https://css-tricks.com/lets-define-exactly-atomic-CSS/">https://CSS-tricks.com/lets-define-exactly-atomic-CSS/</a></p><p>意思是<code>原子化 CSS是一种 CSS的架构方式，它倾向于小巧且用途单一的 class，并且会以视觉效果进行命名。</code></p><h2 id="什么是原子化-CSS"><a href="#什么是原子化-CSS" class="headerlink" title="什么是原子化 CSS?"></a>什么是原子化 CSS?</h2><p>与一般的我们写正常CSS不同，原子化CSS会把元素本身的属性提取出来，加以视觉效果命名，例如：</p><p>如下的html</p><pre><code class="html">&lt;button class=&quot;btn&quot;&gt;Basic&lt;/button&gt;</code></pre><p>正常的CSS</p><pre><code class="css">.btn &#123;    padding: 1rem, 2rem;    font-family: &#39;semi&#39;;    font-weight: bold; &#125;</code></pre><p>使用原子化CSS后，将不用写CSS文件，改为写class属性</p><pre><code class="html">&lt;button class=&quot;py-2 px-4 font-semibold rounded-lg shadow-md text-white bg-green-500 hover:bg-green-700&quot;&gt;  Click me&lt;/button&gt;</code></pre><p>市面上有不少实用至上的 CSS框架，如 <a href="https://tailwindcss.com/">Tailwind CSS</a>，<a href="https://cn.windicss.org/">Windi CSS</a> 以及 <a href="https://tachyons.io/">Tachyons</a> 等。</p><p>同时有些 UI 库也会附带一些 CSS工具类作为框架的补充，如 <a href="https://getbootstrap.com/docs/5.1/utilities/api/">Bootstrap</a> 和 <a href="https://chakra-ui.com/docs/features/style-props">Chakra UI</a>。</p><h2 id="写之前，我们谈谈优势"><a href="#写之前，我们谈谈优势" class="headerlink" title="写之前，我们谈谈优势"></a>写之前，我们谈谈优势</h2><ul><li>类名自由：你绞尽脑汁想这个元素的类名怎么写。在你面前的是一点击就会变颜色的按钮，你想给他起个class或者id，你想了半天，最后取了class名为<code>click-it-and-turn-it-from-blue-to-green</code>😰。</li><li>html嵌入：正常情况我们要引入CSS文件去写这个样式，切来切去不太方便。</li><li>预设的原子化CSS：可以引入插件、其他基于原子化CSS写的组件库。</li><li>IDE支持：插件支持类名提示，很好写。</li><li>写的快：比如说hover属性，原子化CSS可以直接写在class里，很快很方便，比如说tailwind自带的响应式布局，不用自己写媒体查询就可以适配移动端。</li></ul><h2 id="常用的原子化CSS框架"><a href="#常用的原子化CSS框架" class="headerlink" title="常用的原子化CSS框架"></a>常用的原子化CSS框架</h2><ul><li><p>tailwindCSS<a href="https://tailwindcss.com/">https://tailwindcss.com/</a></p><ul><li><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125214852.png"></li></ul></li><li><p>Windi CSS<a href="https://windicss.org/">https://windicss.org/</a></p><ul><li><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125215026.png"></li></ul></li><li><p><a href="https://tachyons.io/">Tachyons</a> <a href="https://tachyons.io/">https://tachyons.io/</a></p><ul><li><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125215141.png"></p></li><li><p>UnoCSS<a href="https://github.com/unocss/unocss">https://github.com/unocss/unocss</a></p><ul><li><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125215337.png"></li></ul></li></ul></li></ul><h2 id="本文的重点：UnoCSS"><a href="#本文的重点：UnoCSS" class="headerlink" title="本文的重点：UnoCSS"></a>本文的重点：UnoCSS</h2><p>讲这么多，我们终于回到主题UnoCSS上</p><blockquote><p> antfu<a href="https://link.juejin.cn/?target=https://antfu.me/posts/reimagine-atomic-css-zh">重新构想原子化CSS</a> 这篇文章讲了unocss是怎么诞生的</p></blockquote><p>Windi CSS已经足够优秀，但antfu大佬还是不够满意，对于框架预设外的自定义工具的额外配置上，还是比较繁琐，而且配置的方式也不够简便</p><blockquote><p>由于 Windi 需要与 Tailwind 兼容，它还必须使用与 Tailwind 完全相同的配置项。尽管数字推断的问题得到了解决，但如果你想添加一些自定义的工具，这将是一场噩梦。</p></blockquote><p>所以经过重新构想原子化CSS，UnoCSS出现了</p><blockquote><p><a href="https://link.juejin.cn/?target=https://github.com/antfu/unocss"><strong>UnoCSS</strong></a> - 具有高性能且极具灵活性的即时原子化 CSS引擎。</p></blockquote><p>它不是像TailWind CSS和Windi CSS属于框架，而是一个引擎，它没有提供预设的原子化CSS工具类</p><p>UnoCSS通过编写规则来定制工具类</p><p>静态规则</p><pre><code class="js">rules: [    [&#39;m-1&#39;, &#123; margin: &#39;0.25rem&#39; &#125;]]</code></pre><p>使用正则表达式来做动态规则</p><pre><code class="ts">rules: [  [/^m-(\d)$/, ([, d]) =&gt; (&#123; margin: `$&#123;d / 4&#125;rem` &#125;)],  [/^p-(\d)$/, (match) =&gt; (&#123; padding: `$&#123;match[1] / 4&#125;rem` &#125;)],]</code></pre><p>当然这些比较常见的规则unocss已经提供了预设在<code>@unocss/preset-uno</code>中</p><pre><code class="html">&lt;div class=&quot;m-100&quot;&gt;  &lt;button class=&quot;m-3&quot;&gt;    &lt;icon class=&quot;p-5&quot; /&gt;    My Button  &lt;/button&gt;&lt;/div&gt;</code></pre><p>生成出的css为</p><pre><code class="css">.m-100 &#123; margin: 25rem; &#125;.m-3 &#123; margin: 0.75rem; &#125;.p-5 &#123; padding: 1.25rem; &#125;</code></pre><p>unocss提供了一个叫shortcuts的功能，可以批量生成css</p><pre><code class="js">shortcuts: [  // you could still have object style  &#123;    btn: &#39;py-2 px-4 font-semibold rounded-lg shadow-md&#39;,  &#125;,  // dynamic shortcuts  [/^btn-(.*)$/, ([, c]) =&gt; `bg-$&#123;c&#125;-400 text-$&#123;c&#125;-100 py-2 px-4 rounded-lg`],]</code></pre><p>只需要配置这个字段</p><p>在使用中可以使用 <code>btn-green</code> 和 <code>btn-red</code> </p><p>生成的css如下</p><pre><code class="css">.btn-green &#123;  padding-top: 0.5rem;  padding-bottom: 0.5rem;  padding-left: 1rem;  padding-right: 1rem;  --un-bg-opacity: 1;  background-color: rgba(74, 222, 128, var(--un-bg-opacity));  border-radius: 0.5rem;  --un-text-opacity: 1;  color: rgba(220, 252, 231, var(--un-text-opacity));&#125;.btn-red &#123;  padding-top: 0.5rem;  padding-bottom: 0.5rem;  padding-left: 1rem;  padding-right: 1rem;  --un-bg-opacity: 1;  background-color: rgba(248, 113, 113, var(--un-bg-opacity));  border-radius: 0.5rem;  --un-text-opacity: 1;  color: rgba(254, 226, 226, var(--un-text-opacity));&#125;</code></pre><p>unocss提供了很多预设</p><h6 id="Official-Presets"><a href="#Official-Presets" class="headerlink" title="Official Presets"></a>Official Presets</h6><ul><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-uno">@unocss&#x2F;preset-uno</a> - The default preset (right now it’s equivalent to <code>@unocss/preset-wind</code>).</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-mini">@unocss&#x2F;preset-mini</a> - The minimal but essential rules and variants.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-wind">@unocss&#x2F;preset-wind</a> - Tailwind &#x2F; Windi CSScompact preset.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-attributify">@unocss&#x2F;preset-attributify</a> - Provides <a href="https://github.com/unocss/unocss/tree/main/packages/preset-attributify#attributify-mode">Attributify Mode</a> to other presets and rules.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-icons">@unocss&#x2F;preset-icons</a> - Use any icon as a class utility.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-web-fonts">@unocss&#x2F;preset-web-fonts</a> - Web fonts at ease.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-typography">@unocss&#x2F;preset-typography</a> - The typography preset.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-tagify">@unocss&#x2F;preset-tagify</a> - Tagify Mode for UnoCSS.</li><li><a href="https://github.com/unocss/unocss/tree/main/packages/preset-rem-to-px">@unocss&#x2F;preset-rem-to-px</a> - Converts rem to px for utils.</li></ul><h6 id="Community-Presets"><a href="#Community-Presets" class="headerlink" title="Community Presets"></a>Community Presets</h6><ul><li><p><a href="https://github.com/macheteHot/unocss-preset-scalpel">unocss-preset-scalpel</a> - Scalpel Preset by <a href="https://github.com/macheteHot/">@macheteHot</a>.</p></li><li><p><a href="https://github.com/chu121su12/unocss-preset-chroma">unocss-preset-chroma</a> - Gradient Preset by <a href="https://github.com/chu121su12">@chu121su12</a>.</p></li><li><p><a href="https://github.com/action-hong/unocss-preset-scrollbar">unocss-preset-scrollbar</a> - Scrollbar Preset by <a href="https://github.com/action-hong">@action-hong</a>.</p></li><li><p><a href="https://github.com/unocss-applet/unocss-applet">unocss-applet</a> - Using UnoCSSin applet (UniApp &#x2F; Taro) by <a href="https://github.com/zguolee">@zguolee</a>.</p></li><li><p><a href="https://github.com/MellowCo/unocss-preset-weapp">unocss-preset-weapp</a> - Wechat MiniProgram Preset for <a href="https://uniapp.dcloud.io/">UniApp</a> and <a href="https://taro-docs.jd.com/taro/docs">Taro</a> by <a href="https://github.com/MellowCo">@MellowCo</a>.</p></li><li><p><a href="https://github.com/Julien-R44/unocss-preset-heropatterns">unocss-preset-heropatterns</a> - Preset that integrates <a href="https://heropatterns.com/">Hero Patterns</a> by <a href="https://github.com/Julien-R44">@Julien-R44</a>.</p></li><li><p><a href="https://github.com/Julien-R44/unocss-preset-flowbite">unocss-preset-flowbite</a> - Port of of <a href="https://github.com/themesberg/flowbite">Flowbite Tailwind plugin</a> for UnoCSSby <a href="https://github.com/Julien-R44">@Julien-R44</a>.</p></li><li><p><a href="https://github.com/Julien-R44/unocss-preset-forms">unocss-preset-forms</a> - Port of <a href="https://github.com/tailwindlabs/tailwindcss-forms">@tailwindcss&#x2F;forms</a> for UnoCSSby <a href="https://github.com/Julien-R44">@Julien-R44</a>.</p></li><li><p><a href="https://github.com/MoomFE/unocss-preset-extra">unocss-preset-extra</a> - <a href="https://animate.style/">Animate.css</a> Preset and some other rules by <a href="https://github.com/Zhang-Wei-666">@Zhang-Wei-666</a>.</p></li><li><p><a href="https://github.com/kidonng/unocss-preset-daisy">unocss-preset-daisy</a> - daisyUI Preset by <a href="https://github.com/kidonng">@kidonng</a>.</p></li><li><p><a href="https://github.com/zirbest/unocss-preset-primitives">unocss-preset-primitives</a> - Like <a href="https://github.com/tailwindlabs/headlessui/tree/main/packages/%40headlessui-tailwindcss">headlessui-tailwindcss</a> , radix-ui , custom for UnoCSSBy <a href="https://github.com/zirbest">@zirbest</a>.</p></li><li><p><a href="https://github.com/Dunqing/unocss-preset-theme">unocss-preset-theme</a> - Preset for automatic theme switching by <a href="https://github.com/Dunqing">@Dunqing</a>.</p><p>通过这些预设可以达到融合tailwind和windi的效果</p></li></ul><h2 id="UnoCSS的优点"><a href="#UnoCSS的优点" class="headerlink" title="UnoCSS的优点"></a>UnoCSS的优点</h2><p>对比其他原子化框架来说</p><ul><li><p>完全可定制：作为一款引擎没有核心实用程序，所有的功能都是通过预设提供的。</p></li><li><p>扩展性强：通过各种预设组合达到windi或者tailwind的效果。</p></li><li><p>快：没有解析，没有AST，没有扫描，它是即时的。</p></li><li><p>小：运行库打包好只有6kb，无痛</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main#shortcuts">Shortcuts</a>：可以写Shortcuts来预设一些常用样式</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/preset-attributify/">Attributify mode</a> ：将class写成组，避免无法阅读的问题</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/preset-icons/">Pure CSSIcons</a> ：纯 CSSicon 可以在 <a href="https://icones.js.org/">https://icones.js.org/</a> 找到并导入成千上万的icon  安装只需要找到你喜欢的 iconfy 库 <code>@iconify-json/[the-collection-you-want]</code> 这样安装就行</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/transformer-variant-group">Variant Groups</a> ：和 <a href="https://github.com/unocss/unocss/tree/main/packages/preset-attributify/">Attributify mode</a> 看起来几乎是一样的功能，写成组</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/transformer-directives">CSSDirectives</a> ：可以在style标签里写  <code>@apply</code>  把一系列样式打包成一个样式，在windi里是个很受欢迎的功能</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/transformer-compile-class/">Compilation mode</a> ：打包优化，生成随机class名</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main#inspector">Inspector</a> ：自带的debug工具</p></li><li><p><a href="https://github.com/unocss/unocss/tree/main/packages/runtime">CSS-in-JS Runtime build</a> ：可以CDN导入</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=antfu.unocss">VS Code extension</a>：自带VSCode提示扩展，很方便</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本篇我们介绍了UnoCSS的特点，原子化CSS的好处，下一篇讲讲unocss实战，安装使用之类的</p><p>题外话：</p><blockquote><p>Anthony Fu大佬真的是我目前的偶像，狂热的开源爱好者，人长得又帅，做的东西又好</p></blockquote><p>🤣这是我在掘金搜unocss搜到的一篇文章中的第一句话 文章在这 <a href="https://juejin.cn/post/7028841960752283656">https://juejin.cn/post/7028841960752283656</a></p><p>antfu大佬确实也是我的偶像</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125225032.png"></p><p>22年秋季 antfu大佬在b站办过几场直播写代码，我基本上是每期必看，这个人非常有意思，有很多新鲜的点子，狠活也多 比如说</p><p><a href="https://github.com/antfu/1990-script">https://github.com/antfu/1990-script</a> 这个仓库教你怎么把GitHub历史穿越回1990年🤭</p><p>他的每个star比较多的仓库我都体验过，感觉设计灵感真的让人眼前一亮，启发基于社区，创造更快的轮子，更好玩的轮子</p><p><a href="https://github.com/antfu/retypewriter">https://github.com/antfu/retypewriter</a> 这个是直播写的雏形 让写的代码在vsc里回放，便于理清思路</p><p><a href="https://github.com/antfu/vue-minesweeper">https://github.com/antfu/vue-minesweeper</a> 这个是首次直播写的扫雷，很清晰的vue代码，看他写真的开窍</p><p><a href="https://github.com/antfu/vue-starport">https://github.com/antfu/vue-starport</a> 这个也是直播写的雏形，为了使组件有更好的过渡</p><p>就说这么多，人也长得帅</p><p>🥰😘</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7028841960752283656">https://juejin.cn/post/7028841960752283656</a></p><p><a href="https://antfu.me/posts/reimagine-atomic-css-zh">https://antfu.me/posts/reimagine-atomic-css-zh</a></p><p><a href="https://juejin.cn/post/7027414082378530852">https://juejin.cn/post/7027414082378530852</a></p><p><a href="https://juejin.cn/post/7161211941652791304">https://juejin.cn/post/7161211941652791304</a></p><p><a href="https://www.tailwindcss.cn/docs/">https://www.tailwindcss.cn/docs/</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/25/%E5%8E%9F%E5%AD%90%E5%8C%96CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MonoRepo&amp;Nuxt框架初始化实战 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/24/MonoRepo&amp;Nuxt%E6%A1%86%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/24/MonoRepo&amp;Nuxt%E6%A1%86%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 24 Jan 2023 14:27:28 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 8 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇笔记介绍了MonoRepo的优</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 8 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇笔记介绍了MonoRepo的优点和基于go语言的MonoRepo框架TurboRepo，这一篇我们详细介绍一下如何配置出一个团队能用的TurboRepo库，包括一些actions和自动部署预览等。</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>⚡️ <code>Nuxt3</code> - SSR框架</li><li>✨ <code>Vue3.2 </code>- 最新Vue更多语法糖</li><li>💨 <code>Turbo</code> - MonoRepo框架</li><li>💎 <code>Strapi</code> - Headless CMS 框架</li><li>😎 <code>@Nuxt/Image</code> - images 服务端渲染</li><li>😁 <code>Umami</code> - Better Analytics 访问源分析</li><li>🃏 <code>Commit Lint</code> - commit规范检查</li><li>💖 <code>Husky &amp; Lint Staged</code> — precommit运行库</li><li>📏 <code>Eslint</code> - 规范化TypeScript、JavaScript代码</li><li>🐶 <code>UnoCss</code> - 原子化 CSS 引擎、兼容 tailwindcss、windicss </li><li>🤖 <code>preset-icons</code> - unocss 自带icons</li><li>⏰ The <code>&lt;script setup&gt;</code> syntax setup语法糖 来自Vue3.2</li><li>🍍 <code>Pinia</code> - 全局状态管理库 更好用</li><li>🎨 <code>APIs auto importing</code> - 库自动引入</li><li>🦾 <code>TypeScript</code> - 更规范的语法</li><li>👷 <code>Github Actions</code> - actions自动运行、ci&#x2F;cd云端检查语法</li><li>👀 <code>Automatic Branch and Issue Autolink</code> - Issue AutoLink actions 创建issue会创建一个分支</li><li>🗺 <code>Nuxt SEO Kit</code> - SEO优化 SSR必备</li><li>📦 <code>Vercel</code> - 自动部署、预览的平台</li><li>🔥 <code>Netlify + Cloudflare</code> - 部署平台</li></ul><h2 id="前端模板"><a href="#前端模板" class="headerlink" title="前端模板"></a>前端模板</h2><p>前端模板选择了<a href="https://github.com/antfu/vitesse-nuxt3">https://github.com/antfu/vitesse-nuxt3</a> </p><p>是antfu的vitesse系列模板的nuxt3款</p><p>这套模板用了好多个 很好用的</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230124233609.png"></p><p>配置很全、自带的unocss也是几乎兼容windicss和tailwind 很适应</p><p>想用icons可以去antfu的另一个项目里找</p><p><a href="https://icones.js.org/">https://icones.js.org/</a> 这里二次封装了几万个icons用个爽</p><h2 id="配置turbo"><a href="#配置turbo" class="headerlink" title="配置turbo"></a>配置turbo</h2><p>turbo官网有讲怎么配置到一个已有的MonoRepo里<a href="https://turbo.build/repo/docs/getting-started/existing-monorepo">https://turbo.build/repo/docs/getting-started/existing-monorepo</a></p><p>这里只需要在根目录的package.json里建立<code>workspaces</code>字段 和<code>packageManager</code>字段</p><pre><code class="json">//package.json&#123;&quot;packageManager&quot;: &quot;yarn@1.22.19&quot;,  &quot;workspaces&quot;: [    &quot;frontend&quot;,    &quot;backend&quot;  ],&#125;</code></pre><h3 id="安装TurboRepo"><a href="#安装TurboRepo" class="headerlink" title="安装TurboRepo"></a>安装TurboRepo</h3><pre><code class="sql">yarn global add turbo</code></pre><h3 id="创建任务管道"><a href="#创建任务管道" class="headerlink" title="创建任务管道"></a>创建任务管道</h3><p>在<code>package.json</code> 的<code>turbo</code>中，将想要”turbo”的命令添加到管道中 管道定义了 npm 包中 scripts 的依赖关系，并且为这些命令开启了缓存。这些命令的依赖关系和缓存设置会应用到 MonoRepo 中的各个包中</p><pre><code class="json">//turbo.json&#123;  &quot;$schema&quot;: &quot;https://turbo.build/schema.json&quot;,  &quot;pipeline&quot;: &#123;    &quot;build&quot;: &#123;      // A package&#39;s `build` script depends on that package&#39;s      // dependencies and devDependencies      // `build` tasks  being completed first      // (the `^` symbol signifies `upstream`).      &quot;dependsOn&quot;: [&quot;^build&quot;],      // note: output globs are relative to each package&#39;s `package.json`      // (and not the monorepo root)      &quot;outputs&quot;: [&quot;.next/**&quot;]    &#125;,    &quot;test&quot;: &#123;      // A package&#39;s `test` script depends on that package&#39;s      // own `build` script being completed first.      &quot;dependsOn&quot;: [&quot;build&quot;],      // A package&#39;s `test` script should only be rerun when      // either a `.tsx` or `.ts` file has changed in `src` or `test` folders.      &quot;inputs&quot;: [&quot;src/**/*.tsx&quot;, &quot;src/**/*.ts&quot;, &quot;test/**/*.ts&quot;, &quot;test/**/*.tsx&quot;]    &#125;,    // A package&#39;s `lint` script has no dependencies and    // can be run whenever. It also has no filesystem outputs.    &quot;lint&quot;: &#123;&#125;,    &quot;deploy&quot;: &#123;      // A package&#39;s `deploy` script depends on the `build`,      // `test`, and `lint` scripts of the same package      // being completed. It also has no filesystem outputs.      &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;]    &#125;  &#125;&#125;</code></pre><p>上面的示例中，<code>build</code>和<code>test</code>这两个任务具有依赖性，必须要等他们的依赖项对应的任务完成后才能执行，所以这里用<code>^</code>来表示。 对于每个包中 package.json 中的 script 命令，如果没有配置覆盖项，那么TurboRepo将缓存默认输出到 <code>dist/** </code>和<code>build/**</code>文件夹中。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>这样只需要运行</p><pre><code class="bash">npx turbo run build test lint deploy</code></pre><p>就可以运行全部参数</p><h3 id="配置-gitignore"><a href="#配置-gitignore" class="headerlink" title="配置.gitignore"></a>配置<code>.gitignore</code></h3><p>根目录 创建<code>.gitignore</code>文件</p><pre><code class="json">+ .turbo+ build/**+ dist/**+ .next/**</code></pre><h3 id="Remote-cache"><a href="#Remote-cache" class="headerlink" title="Remote cache"></a>Remote cache</h3><pre><code class="bash">turbo login</code></pre><pre><code class="bash">turbo link</code></pre><p>然后删除你的<code>./node_modules/.cache/turbo</code>文件夹</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230123234538.png"></p><p>显示 full turbo 则证明匹配到了云端的缓存，直接拉下来不再构建一遍</p><h2 id="配置husky"><a href="#配置husky" class="headerlink" title="配置husky"></a>配置husky</h2><p>在根目录安装husky</p><p>先运行<code>husky install</code></p><p>然后创建<code>.husky</code>文件夹</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230124235647.png"></p><p>文件树如上</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code>//.gitignore*</code></pre><pre><code class="sh"># husky.sh#!/usr/bin/env shif [ -z &quot;$husky_skip_init&quot; ]; then  debug () &#123;    if [ &quot;$HUSKY_DEBUG&quot; = &quot;1&quot; ]; then      echo &quot;husky (debug) - $1&quot;    fi  &#125;  readonly hook_name=&quot;$(basename -- &quot;$0&quot;)&quot;  debug &quot;starting $hook_name...&quot;  if [ &quot;$HUSKY&quot; = &quot;0&quot; ]; then    debug &quot;HUSKY env variable is set to 0, skipping hook&quot;    exit 0  fi  if [ -f ~/.huskyrc ]; then    debug &quot;sourcing ~/.huskyrc&quot;    . ~/.huskyrc  fi  readonly husky_skip_init=1  export husky_skip_init  sh -e &quot;$0&quot; &quot;$@&quot;  exitCode=&quot;$?&quot;  if [ $exitCode != 0 ]; then    echo &quot;husky - $hook_name hook exited with code $exitCode (error)&quot;  fi  if [ $exitCode = 127 ]; then    echo &quot;husky - command not found in PATH=$PATH&quot;  fi  exit $exitCodefi</code></pre><pre><code class="sh">//commit-msg#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;npx --no-install commitlint --edit &quot;$1&quot;</code></pre><pre><code class="sh">//post-merge#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;yarn install</code></pre><pre><code class="sh">//pre-commit#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;yarn lint-staged</code></pre><h3 id="安装commit-lint"><a href="#安装commit-lint" class="headerlink" title="安装commit lint"></a>安装commit lint</h3><pre><code>yarn install -D @commitlint/config-conventional @commitlint/cli</code></pre><p>这个可以在MonoRepo内安装不在根目录装</p><p>在前端的package.json里配置</p><pre><code class="json">//./frontend/package.json&#123;  &quot;name&quot;: &quot;frontend&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;nuxi build&quot;,    &quot;dev&quot;: &quot;nuxi dev&quot;,    &quot;start&quot;: &quot;node .output/server/index.mjs&quot;,    &quot;lint&quot;: &quot;eslint .&quot;,    &quot;lint:fix&quot;: &quot;eslint . --fix&quot;,    &quot;generate&quot;: &quot;nuxi generate&quot;,    &quot;typecheck&quot;: &quot;tsc --noEmit --incremental false&quot;,    &quot;lint:strict&quot;: &quot;eslint --max-warnings=0 .&quot;  &#125;,  &quot;lint-staged&quot;: &#123;    &quot;**/*.&#123;js,ts,vue,html&#125;&quot;: [      &quot;eslint --max-warnings=0&quot;    ]  &#125;&#125;</code></pre><p>最后在根目录创建<code>commitlint.config.js</code></p><p>里面写上commit lint 规则</p><pre><code class="js">//commitlint.config.jsmodule.exports = &#123;  extends: [&#39;@commitlint/config-conventional&#39;],  rules: &#123;    &#39;type-enum&#39;: [      2,      &#39;always&#39;,      [        &#39;feat&#39;,        &#39;fix&#39;,        &#39;docs&#39;,        &#39;chore&#39;,        &#39;style&#39;,        &#39;refactor&#39;,        &#39;ci&#39;,        &#39;test&#39;,        &#39;revert&#39;,        &#39;perf&#39;,        &#39;build&#39;,        &#39;vercel&#39;,      ],    ],  &#125;,&#125;</code></pre><h2 id="配置-gitignore-1"><a href="#配置-gitignore-1" class="headerlink" title="配置.gitignore"></a>配置<code>.gitignore</code></h2><pre><code>node_modules*.logdist.output.nuxt.env.turbo# Logslogs*.lognpm-debug.log*yarn-debug.log*yarn-error.log*lerna-debug.log*# Diagnostic reports (https://nodejs.org/api/report.html)report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json# Runtime datapids*.pid*.seed*.pid.lock# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage*.lcov# nyc test coverage.nyc_output# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files).grunt# Bower dependency directory (https://bower.io/)bower_components# node-waf configuration.lock-wscript# Compiled binary addons (https://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modules/jspm_packages/# TypeScript v1 declaration filestypings/# TypeScript cache*.tsbuildinfo# Optional npm cache directory.npm# Optional eslint cache.eslintcache# Microbundle cache.rpt2_cache/.rts2_cache_cjs/.rts2_cache_es/.rts2_cache_umd/# Optional REPL history.node_repl_history# Output of &#39;npm pack&#39;*.tgz# Yarn Integrity file.yarn-integrity# dotenv environment variables file.env.env.test# parcel-bundler cache (https://parceljs.org/).cache# Next.js build output.next# Nuxt.js build / generate output.nuxtdist# Gatsby files.cache/# Comment in the public line in if your project uses Gatsby and *not* Next.js# https://nextjs.org/blog/next-9-1#public-directory-support# public# vuepress build output.vuepress/dist# Serverless directories.serverless/# FuseBox cache.fusebox/# DynamoDB Local files.dynamodb/# TernJS port file.tern-port.vercelfrontend/.env</code></pre><h2 id="配置vercel"><a href="#配置vercel" class="headerlink" title="配置vercel"></a>配置vercel</h2><p>创建<code>vercel.json</code></p><p>由于是nuxt3项目 vercel有预设 只需要配置一个字段</p><pre><code class="json">&#123;  &quot;framework&quot;: &quot;nuxtjs&quot;&#125;</code></pre><p>然后是登录vercel把项目绑定上去</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125000950.png"></p><p>配置好团队是这样的</p><h2 id="配置netlify"><a href="#配置netlify" class="headerlink" title="配置netlify"></a>配置netlify</h2><p>创建<code>netlify.toml</code></p><pre><code class="toml">[build.environment]  NODE_VERSION = &quot;16&quot;[build]  publish = &quot;dist&quot;  command = &quot;yarn build&quot;  functions = &quot;netlify/functions&quot;[[redirects]]  from = &quot;/*&quot;  to = &quot;/index.html&quot;  status = 200</code></pre><p>默认配置为如上</p><p>然后是登录netlify把项目绑定上去</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125001234.png"></p><p>配好了是这样的</p><h2 id="配置workflows"><a href="#配置workflows" class="headerlink" title="配置workflows"></a>配置workflows</h2><p>配置一个actions用来在线lint 有错会xx</p><pre><code class="yaml"># lint.yaml# https://github.com/kentcdodds/kentcdodds.com/blob/main/.github/workflows/deployment.ymlname: Code Checkon:  push:    branches:      - main  pull_request: &#123;&#125;jobs:  lint:    name: ⬣ ESLint    runs-on: ubuntu-latest    steps:      - name: 🛑 Cancel Previous Runs        uses: styfle/cancel-workflow-action@0.9.1      - name: ⬇️ Checkout repo        uses: actions/checkout@v2      - name: ⎔ Setup node        uses: actions/setup-node@v2        with:          node-version: 16      - name: 📥 Download deps        uses: bahmutov/npm-install@v1      - name: 🔬 Lint        run: npx turbo lint:strict</code></pre><p>配置一个release bot 用来生成打包文件 区分版本号</p><pre><code class="yaml"># release.yamlname: release-pleaseon:  # workflow_dispatch:  push:    branches:      - mainjobs:  release-please:    runs-on: ubuntu-latest    steps:      - uses: google-github-actions/release-please-action@v3        with:          release-type: node          package-name: release-please-action</code></pre><p>配置 issue bot 用来自动用issue创建分支</p><pre><code class="yaml"># issue.yamlname: &quot;Issue Autolink&quot;on:  pull_request:    types: [opened]jobs:  issue-links:    runs-on: ubuntu-latest    steps:      - uses: tkt-actions/add-issue-links@v1.6.0        with:          repo-token: &quot;$&#123;&#123; secrets.AUTO_LINK &#125;&#125;&quot;          branch-prefix: &quot;i&quot;          resolve: &quot;true&quot;</code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到此应该初始化的差不多了</p><p>这个从创建 debug 到上线的时间大概花了两天 问题出在 vercel 和 netlify 上</p><p>vercel 对 nuxt 的兼容性不好，不如他的亲儿子 next</p><p>刚去查了一下 nuxt3在1月23日变成了默认版本</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003129.png"></p><p>nuxt3用了一个叫nitro的编译框架 <a href="https://github.com/unjs/nitro">https://github.com/unjs/nitro</a></p><p><a href="https://nitro.unjs.io/">https://nitro.unjs.io/</a></p><p><code>构建和部署通用JavaScript服务器</code></p><p><code>Nitro提供了一个强大的工具链和一个来自unjs生态系统的运行时框架，可以随时随地构建和部署任何JavaScript服务器！</code></p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003640.png"></p><p>unjs 我感觉是写js魔法的组织 里面全是魔法库</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230125003728.png"></p><p>这位是主谋</p><p>这个框架会自动检测你当前的环境 给你分配一个preset  比如说你在当前node环境build nuxt的话会给你生成一个 .mjs文件 你运行文件就可以启动一个SSR服务器</p><p>你在vercel上运行的话就给你 <code>preset：vercel</code> 生成vercel认的文件格式</p><p>netlify同理</p><p>问题出在 使用MonoRepo 后 nitro不认我这是在vercel里了  他会生成默认的node的mjs文件 然后构建失败</p><p>很烦</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://turbo.build/repo/docs/getting-started/existing-monorepo">https://turbo.build/repo/docs/getting-started/existing-monorepo</a></p><p><a href="https://github.com/antfu/vitesse-nuxt3">https://github.com/antfu/vitesse-nuxt3</a></p><p><a href="https://github.com/antfu?tab=repositories&amp;q=vitesse&amp;type=&amp;language=&amp;sort=">https://github.com/antfu?tab=repositories&amp;q=vitesse&amp;type=&amp;language=&amp;sort=</a></p><p><a href="https://nitro.unjs.io/">https://nitro.unjs.io/</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/24/MonoRepo&amp;Nuxt%E6%A1%86%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E6%88%98%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MonoRepo设置与部署 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/23/MonoRepo%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/23/MonoRepo%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 23 Jan 2023 15:54:27 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 7 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;举个例子，你现在有一个全栈的项目，团</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 7 天</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>举个例子，你现在有一个全栈的项目，团队里写了前端、后端、使用文档和一个工具库。</p><p>一般情况的话，我们会创建四个仓库，放不同的内容，其中前端如果使用工具库的话，我们会在前端里引入工具库的包（可能是直接，可能是在npm上publish过的）</p><p>你希望运行前端项目的时候，同时运行三个命令（例如使用yarn）你需要运行 <code>yarn lint</code> 、<code>yarn build</code> 、<code>yarn serve</code> 你需要敲三个命令，很麻烦。</p><h2 id="MonoRepo"><a href="#MonoRepo" class="headerlink" title="MonoRepo"></a>MonoRepo</h2><h3 id="什么是MonoRepo"><a href="#什么是MonoRepo" class="headerlink" title="什么是MonoRepo"></a>什么是MonoRepo</h3><p>在开发场景中，我们希望各个项目之间能够足够的独立，各自的开发和发布不会产生太多的耦合，现在很多的项目也是出于这种考虑去拆成一个一个独立的子项目，在单独的代码仓库中进行管理，这就是我们常见的单代码仓库的开发模式。 </p><p>例如我们<code>前言</code>中举的例子，你想要前端项目中使用工具库中的包，你需要到前端，或者使用npm publish后再安装，当你工具库的版本更新的时候，你需要把前端项目里的工具库版本也更新掉。</p><p>如果把所有有依赖关系的代码都放到一个仓库中进行统一维护，当一个库变动时，其它的代码能自动的进行依赖升级，那么就能精简开发流程、提高开发效率。这种多包的代码仓库管，就是 MonoRepo。 </p><p>其实TurboRepo在前端中非常常见，Babel、React、Vue等开源项目都是使用这种方式在管理代码，其中 Babel 官方开源的多包管理工具 Lerna 也被广泛的使用。</p><p>这次我介绍的是TurboRepo。</p><h2 id="TurboRepo"><a href="#TurboRepo" class="headerlink" title="TurboRepo"></a>TurboRepo</h2><p>TurboRepo是一个适用于 JavaScript 和 Typescript TurboRepo的高性能构建工具，使用go、rust语言编写，性能很好。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>增量构建：缓存构建内容，并跳过已经计算过的内容，通过增量构建来提高构建速度</p></li><li><p>内容hash：通过文件内容计算出来的hash来判断文件是否需要进行构建，缓存在云端，登录即可享受</p></li><li><p>云缓存：可以和团队成员共享CI&#x2F;CD的云构建缓存，来实现更快的构建</p></li><li><p>多任务并行执行：在不浪费空闲 CPU 的情况下，以最大并行数量来进行构建</p></li><li><p>任务管道：通过定义任务之间的关系，让 TurboRepo 优化构建的内容和时间</p></li><li><p>约定式配置：通过约定来降低配置的复杂度，只需要几行简单的 JSON 就能完成配置（配置turbo.json)</p></li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>对于一个新的项目，可以运行下面的命令来生成全新的代码仓库</p><pre><code class="sql">npx create-turbo@latest</code></pre><p>对于一个已经存在的 monorepo 项目，可以通过下面的步骤来接入 turborepo</p><h3 id="安装Turborepo"><a href="#安装Turborepo" class="headerlink" title="安装Turborepo"></a>安装Turborepo</h3><p>将 Turborepo 添加到项目最外层的<code>devDependecies</code>中</p><pre><code class="sql">npm install turbo -Doryarn add turbo --dev</code></pre><h3 id="创建任务管道"><a href="#创建任务管道" class="headerlink" title="创建任务管道"></a>创建任务管道</h3><p>在<code>package.json</code> 的<code>turbo</code>中，将想要”turbo”的命令添加到管道中 管道定义了 npm 包中 scripts 的依赖关系，并且为这些命令开启了缓存。这些命令的依赖关系和缓存设置会应用到 monorepo 中的各个包中</p><pre><code class="json">&#123;    &quot;turbo&quot;: &#123;        &quot;pipeline&quot;: &#123;            &quot;build&quot;: &#123;                &quot;dependsOn&quot;: [&quot;^build&quot;],                        &quot;outputs&quot;: [&quot;.next/**&quot;]                        &#125;,            &quot;test&quot;: &#123;                &quot;dependsOn&quot;: [&quot;^build&quot;],                &quot;outputs&quot;: []                                        &#125;,            &quot;lint&quot;: &#123;                &quot;outputs&quot;: []            &#125;,            &quot;dev&quot;: &#123;                &quot;cache&quot;: false                        &#125;         &#125;        &#125;&#125;</code></pre><p>上面的示例中，<code>build</code>和<code>test</code>这两个任务具有依赖性，必须要等他们的依赖项对应的任务完成后才能执行，所以这里用<code>^</code>来表示。 对于每个包中 package.json 中的 script 命令，如果没有配置覆盖项，那么Turborepo将缓存默认输出到 <code>dist/** </code>和<code>build/**</code>文件夹中。</p><h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><p>从上面的 turbo 的配置中可以看出来，管道(pipeline)是一个核心的概念，Turborepo也是通过管道来处理各个任务和他们的依赖关系的。</p><p>Turborepo提供了一种声明式的方法来指定各个任务之间的关系，这种方式能够更容易理解各个任务之间的关系，并且Turborepo也能通过这种显式的声明来优化任务的执行并充分调度CPU的多核心性能。</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230123234328.png"></p><h3 id="配置pipeline"><a href="#配置pipeline" class="headerlink" title="配置pipeline"></a>配置pipeline</h3><p>pipeline中每个键名都可以通过运行<code>turbo run</code>来执行，并且可以使用<code>dependsOn</code>来执行当前管道的依赖项。</p><p>上图的执行流程，可以配置成如下的格式</p><pre><code class="json">&#123;    &quot;turbo&quot;: &#123;        &quot;pipeline&quot;: &#123;            &quot;build&quot;: &#123;                &quot;dependsOn&quot;: [&quot;^build&quot;],                       &#125;,            &quot;test&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;],                &quot;outputs&quot;: []                                        &#125;,            &quot;lint&quot;: &#123;                &quot;outputs&quot;: []            &#125;,            &quot;deploy&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;]                       &#125;         &#125;        &#125;&#125;</code></pre><p>通过<code>dependsOn</code>的配置，可以看出各个命令的执行顺序：</p><ul><li>因为A和C依赖于B，所以包的构建存在依赖关系，根据build的dependson配置，会先执行依赖项的build命令，依赖项执行完后才会执行自己的build命令。从上面的瀑布流中也可以看出，B的build先执行，执行完以后A和C的build会并行执行</li><li>对于test，只依赖自己的build命令，只要自己的build命令完成了，就立即执行test</li><li>lint没有任何依赖，在任何时间都可以执行</li><li>自己完成build、test、lint后，再执行deploy命令</li></ul><p>可以通过下面的命令执行：</p><pre><code class="bash">npx turbo run test build lint deploy</code></pre><h3 id="常规依赖"><a href="#常规依赖" class="headerlink" title="常规依赖"></a>常规依赖</h3><p>如果一个任务的执行，只依赖自己包其他的任务，那么可以把依赖的任务放在dependsOn数组里</p><pre><code class="json">&#123;    &quot;turbo&quot;: &#123;        &quot;pipeline&quot;: &#123;            &quot;deploy&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;]                       &#125;         &#125;        &#125;&#125;</code></pre><h3 id="特定依赖"><a href="#特定依赖" class="headerlink" title="特定依赖"></a>特定依赖</h3><p>在一些场景下，一个任务可能会依赖某个包的特定的任务，这时候我们需要去手动指定依赖关系。</p><pre><code class="json">&#123;    &quot;turbo&quot;: &#123;        &quot;pipeline&quot;: &#123;            &quot;build&quot;: &#123;                &quot;dependsOn&quot;: [&quot;^build&quot;],                       &#125;,            &quot;test&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;],                &quot;outputs&quot;: []                                        &#125;,            &quot;lint&quot;: &#123;                &quot;outputs&quot;: []            &#125;,            &quot;deploy&quot;: &#123;                &quot;dependsOn&quot;: [&quot;build&quot;, &quot;test&quot;, &quot;lint&quot;]                       &#125;,            &quot;frontend#deploy&quot;: &#123;                &quot;dependsOn&quot;: [&quot;ui#test&quot;, &quot;backend#deploy&quot;]                        &#125;        &#125;        &#125;&#125;</code></pre><h2 id="Remote-cache"><a href="#Remote-cache" class="headerlink" title="Remote cache"></a>Remote cache</h2><p>当多人开个一个项目的时候，团队的成员可以共享构建的缓存，从而加快项目的构建速度。</p><p>当一个成员把某个分支构建的缓存文件推送到远程的git仓库是，另一个成员如果在同一个分支上进行开发，那么Turborepo 可以支持你去选择某个成员的构建缓存，并在运行相关的构建任务时，从远端拉去缓存文件到本地，加快构建的速度</p><p>运行 npx turbo link，进行登录后，就可以选择要使用的缓存</p><p><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230123234538.png"></p><p>显示 full turbo 则证明匹配到了云端的缓存，直接拉下来不再构建一遍</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>我相信 Turborepo 的出现在不久的将来一定会成为 Monorepo 工具链中重要的一环，无论是构建缓存功能还是基于 pipeline 的智能任务调度系统，都非常优秀的解决了传统 Monorepo 存在“慢”的问题。</p><p>为了更好的性能，大部分人将不再局限于使用 JavaScript 开发 JavaScript 工具，而是更愿意选择其他高门槛语言。</p><p>我感觉使用turbo有很好的体验，但他好像对nuxt兼容性不好，只兼容自己的亲儿子next🤣。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7051929587852247077">https://juejin.cn/post/7051929587852247077</a><br><a href="https://juejin.cn/post/7048234698048274469">https://juejin.cn/post/7048234698048274469</a><br><a href="https://juejin.cn/post/7129267782515949575">https://juejin.cn/post/7129267782515949575</a></p><p><a href="https://github.com/vercel/turbo">https://github.com/vercel/turbo</a></p><p><a href="https://turbo.build/repo/docs/core-concepts/monorepos/running-tasks">https://turbo.build/repo/docs/core-concepts/monorepos/running-tasks</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/23/MonoRepo%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HTTP协议 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/22/HTTP%E5%8D%8F%E8%AE%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/22/HTTP%E5%8D%8F%E8%AE%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sun, 22 Jan 2023 07:36:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 6 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;本堂课重点内容&quot;&gt;&lt;a href=&quot;#本堂课重点内容&quot; class=&quot;headerlink&quot; title=&quot;本堂课重点内容&quot;&gt;&lt;/a&gt;本堂课重点内容&lt;/h2&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 6 天</strong></p><h2 id="本堂课重点内容"><a href="#本堂课重点内容" class="headerlink" title="本堂课重点内容"></a>本堂课重点内容</h2><ol><li>HTTP 协议的简单介绍</li><li>HTTP 协议的报文结构</li></ol><h2 id="详细知识点介绍"><a href="#详细知识点介绍" class="headerlink" title="详细知识点介绍"></a>详细知识点介绍</h2><p>HTTP 全称超文本传输协议（Hyper Text Transfer Protocol），是一个基于TCP协议的无状态应用层协议。</p><h3 id="HTTP-发展历史"><a href="#HTTP-发展历史" class="headerlink" title="HTTP 发展历史"></a>HTTP 发展历史</h3><ul><li><p>HTTP&#x2F;0.9</p><ul><li><p>只有GET类型的请求</p></li><li><p>只能响应HTML文档</p></li></ul></li><li><p>HTTP&#x2F;1.0</p><ul><li><p>增加了 Header</p></li><li><p>增加了状态码</p></li><li><p>支持了多种文档类型</p></li></ul></li><li><p>HTTP&#x2F;1.1(常见)</p><ul><li><p>连接复用</p></li><li><p>提供了缓存支持</p></li><li><p>支持内容协商</p></li></ul></li><li><p>HTTP&#x2F;2</p><ul><li><p>二进制协议</p></li><li><p>支持Header压缩</p></li><li><p>增加了服务器推送（Server Push）</p></li></ul></li><li><p>HTTP&#x2F;3</p><ul><li>基于QUIC（udp）协议</li></ul></li></ul><h3 id="常见的-HTTP-Methods"><a href="#常见的-HTTP-Methods" class="headerlink" title="常见的 HTTP Methods"></a>常见的 HTTP Methods</h3><table><thead><tr><th>请求类型</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>请求一个指定的资源。使用GET的请求一般用于获取数据</td></tr><tr><td>POST</td><td>将实体提交到指定资源，通常导致服务器上的状态变化或副作用</td></tr><tr><td>PUT</td><td>用于请求有效载荷替换目标资源</td></tr><tr><td>DELETE</td><td>用于删除指定的资源</td></tr><tr><td>HEAD</td><td>请求一个与GET请求的响应相同的响应，但没有响应体</td></tr><tr><td>OPTIONS</td><td>预检请求，用于描述目标资源的通信选项</td></tr></tbody></table><p>其中最常见的是 <code>GET</code> 请求和 <code>POST</code> 请求，<code>PUT</code> <code>DELETE</code> 常见于各类 RESTful API 中。而 <code>OPTIONS</code> 请求被称为预检请求，倘若我们尝试为前面的几个请求类型增加自定义Header，浏览器会默认向服务器发出一个OPTIONS请求，用于判断服务器能否接收&#x2F;处理该header。</p><h3 id="常见-HTTP-状态码"><a href="#常见-HTTP-状态码" class="headerlink" title="常见 HTTP 状态码"></a>常见 HTTP 状态码</h3><blockquote><p>1xx - 指示信息 </p><p>2xx - 请求成功 </p><p>3xx - 重定向操作 </p><p>4xx - 客户端错误 </p><p>5xx - 服务端错误</p></blockquote><ul><li><code>200</code> 正常响应</li><li><code>301</code> 永久重定向</li><li><code>302</code> 临时重定向</li><li><code>401</code> 未授权</li><li><code>403</code> 请求被拒绝</li><li><code>404</code> 请求资源不存在</li><li><code>500</code> 服务器错误</li><li><code>504</code> 网关错误</li></ul><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>他是一种API设计风格。</p><ol><li>每一个URL代表一种资源</li><li>客户端和服务端之间，传递这种资源的某种表现层。</li><li>客户端通过HTTP method，对服务端资源进行操作，实现”表现层状态转化”</li></ol><h3 id="常见请求头"><a href="#常见请求头" class="headerlink" title="常见请求头"></a>常见请求头</h3><ul><li>Accept：接受类型</li><li>Content-Type：客户端发送出去实体内容的类型</li><li>Cache-Control：指定请求和响应遵循的缓存机制。</li><li>Cookie：有cookie会自动带上</li></ul><h3 id="常用响应头"><a href="#常用响应头" class="headerlink" title="常用响应头"></a>常用响应头</h3><ul><li>Set-Cookie：设置和页面关联的Cookie</li><li>Content-Type：服务端</li></ul><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>帧：http2最小通信单位，每个帧都包含帧头</p><p>消息：与逻辑请求或响应消息对应的完整的一系列帧。</p><p>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</p><p>交错发送，接收方重组织。</p><p>HTTP2连接是永久的，而且仅需要每个来源一个连接。</p><p>流控制：阻止发送方向接收方发送大量数据的机制。</p><p>服务器有主动推送能力，可以提前推送静态资源。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS &#x3D; HTTP + SSL</p><p>对称加密：加密和解密都是用同一个密钥</p><p>非对称加密：加密和解密都需要使用两个不同的密钥：公钥和私钥。</p><h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><ul><li>Session+Cookie</li><li>JWT</li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ul><li>浏览器与服务器进行全双工通讯的网络技术</li><li>实时性高</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>QUIC：HTTP3的新特性</p><h2 id="实践练习例子"><a href="#实践练习例子" class="headerlink" title="实践练习例子"></a>实践练习例子</h2><p><a href="https://www.w3schools.cn/html/exercise.asp">https://www.w3schools.cn/html/exercise.asp</a></p><h2 id="课后个人总结"><a href="#课后个人总结" class="headerlink" title="课后个人总结"></a>课后个人总结</h2><p>本次课程主要介绍了 HTTP 协议的基本知识，以及 HTTP 的发展历史，以及常见的请求方法和状态码，以及 RESTful API。另外还介绍了 HTTPS 和 WebSocket 以及 QUIC 等新特性。学完本节课，我对 HTTP 协议有了更深入的理解，掌握了其中的常见请求头和响应头，以及常用的状态码，并且了解了 HTTP2，HTTPS，WebSocket，以及 QUIC 等新特性。</p><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP</a></p><p><a href="https://jwt.io/">https://jwt.io/</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/22/HTTP%E5%8D%8F%E8%AE%AE%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TypeScript ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/19/TypeScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/19/TypeScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Thu, 19 Jan 2023 15:55:39 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 4 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;本堂课重点内容&quot;&gt;&lt;a href=&quot;#本堂课重点内容&quot; class=&quot;headerlink&quot; title=&quot;本堂课重点内容&quot;&gt;&lt;/a&gt;本堂课重点内容&lt;/h2&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 4 天</strong></p><h2 id="本堂课重点内容"><a href="#本堂课重点内容" class="headerlink" title="本堂课重点内容"></a>本堂课重点内容</h2><ol><li>TypeScript 定义解析</li><li>TypeScript 基础语法</li></ol><h2 id="详细知识点介绍"><a href="#详细知识点介绍" class="headerlink" title="详细知识点介绍"></a>详细知识点介绍</h2><ol><li>语言特性</li><li>基本数据类型</li></ol><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>JavaScript 是动态类型的语言，而TypeScript顾名思义是静态类型的语言。与js相比，静态类型的特性为ts带来了许多优势</p><ul><li>更强的可读性</li><li>更强的可维护性</li><li>大型项目中提升稳定性</li><li>开发效率</li></ul><p>而作为js的超集，ts兼容所有js特性，且支持与js共存，能够渐进式地引入和升级。</p><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>TypeScript能够在变量名称后面添加冒号和期望的类型来为变量赋予具体的类型，例如下面的代码，常见的类型有 <code>string</code> <code>number</code> <code>boolean</code> <code>null</code> <code>undefined</code></p><pre><code class="ts">let a: string = &quot;string&quot;let b: number = 12let c: boolean = true</code></pre><p>如果在之后尝试给变量赋值不同类型的值，将会产生报错</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>ts使用<code>interface</code>关键字来定义新类型</p><pre><code class="ts">interface ICustomObject &#123;    name: string    age: number    hobby?: string    readonly id: number&#125;const obj: ICustonObject &#123;    name: &quot;hello world&quot;,    age: 12,    hobby: &#39;coding&#39;,    id: 10&#125;</code></pre><p>对于只读属性，可以在类型定义时增加readonly修饰符，在之后倘若修改只读属性，将会报错。在属性名后面紧跟问号表示该属性可选（可能不存在），后续倘若直接读取该属性，将导致报错（需要先判断该属性是否存在）</p><blockquote><p>一般情况下，约定自定义类型以大写字母<code>I</code>开头，例如上面的 <code>ICustomObject</code></p></blockquote><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>在某些情况下，对象的键名（key）可能并不固定，比如我希望某个对象键名是任意string，键值是布尔型，那么可以向下面这样定义</p><pre><code class="ts">interface IObj &#123;    [key: string]: boolean&#125;</code></pre><p>或者使用 <code>type</code> 关键字</p><pre><code class="ts">type IObj = Record&lt;string, boolean&gt;</code></pre><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>假设有一个js函数 <code>add</code></p><pre><code class="js">function add(x, y) &#123;    return x + y&#125;</code></pre><p>为其添加类型声明后</p><pre><code class="ts">function add(x: number, y: number):number &#123;    return x + y&#125;</code></pre><p>对于匿名的箭头函数，我们也可以为其添加类型</p><pre><code class="ts">// jsconst add = (x, y) =&gt; x + y// tsconst add: (x: number, y: number) =&gt; number = (x, y) =&gt; x + y</code></pre><p>或许在某些情况下，将类型和函数写在一起会稍显凌乱，那么我们也可以将函数类型单独定义，例如下面这样</p><pre><code class="ts">interface IAdd &#123;    (x: number, y: number): number&#125;const add: IAdd = (x, y) =&gt; x + y</code></pre><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组的类型定义有很多方法，最常见的是像c语言那样的类型定义</p><pre><code class="ts">type IArray = number[]const array: IArray = [1, 2, 3, 4, 5]</code></pre><p>同样也可以使用ts提供的Array泛型，是一样的效果</p><pre><code class="ts">type IArray = Array&lt;number&gt;const array: IArray = [1, 2, 3, 4, 5]</code></pre><p>因为数组实际上就是键名特殊的对象，所以也可以用表示对象的方法来表示</p><pre><code class="ts">interface IArray &#123;    [key: number]: number&#125;const array: IArray = [1, 2, 3, 4, 5]</code></pre><h3 id="TS-新增的类型"><a href="#TS-新增的类型" class="headerlink" title="TS 新增的类型"></a>TS 新增的类型</h3><p>为了实现一些特殊需求，ts也新增了许多类型方便使用</p><h4 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h4><pre><code class="ts">function test(): void &#123;    alert(&quot;hello&quot;)&#125;</code></pre><p>顾名思义，表示无赋值，例如函数没有返回值</p><h3 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h3><pre><code class="ts">type IArray = Array&lt;any&gt;const array: IArray = [1, &quot;string&quot;, true, &#123;a: 1&#125;]</code></pre><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>该类型能够通过枚举名查枚举值，同时能够使用枚举值查枚举名</p><pre><code class="ts">enum EnumTest &#123;    man = &#39;male&#39;,    woman = &#39;female&#39;,&#125;EnumTest[&#39;man&#39;] === &#39;male&#39;EnumTest[&#39;male&#39;] === &#39;man&#39;</code></pre><p>在不提供枚举名的时候，将默认为由0开始的索引值</p><pre><code class="ts">enum EnumWeekDay &#123; Mon, Tue, Wed, Thu, Fri &#125;EnumTest[&#39;Mon&#39;] === 0EnumTest[&#39;Tue&#39;] === 1</code></pre><h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><h4 id="联合类型与交叉类型"><a href="#联合类型与交叉类型" class="headerlink" title="联合类型与交叉类型"></a>联合类型与交叉类型</h4><p>联合类型： <code>IA | IB</code>;</p><p>交叉类型： <code>IA &amp; IB;</code></p><h4 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h4><p>可以直接通过<code>.type</code>然后拿到某个变量的类型，可用于后续变量类型的判断，达到类型保护的作用。</p><h4 id="补充类型"><a href="#补充类型" class="headerlink" title="补充类型"></a>补充类型</h4><ul><li>空类型，表示无赋值</li><li>任意类型，是所有类型的子类型</li><li>枚举类型：支持枚举值到枚举名的正、反向映射</li></ul><h2 id="课后个人总结"><a href="#课后个人总结" class="headerlink" title="课后个人总结"></a>课后个人总结</h2><p>TypeScript是一个非常有用的语言，给JavaScript开发带来了严格的检查</p><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><p><a href="http://www.typescriptlang.org/docs/">www.typescriptlang.org/docs/</a></p><p><a href="https://bytedance.feishu.cn/file/boxcnIjrYQpF7pL6nWGtTl5W8Jd">https://bytedance.feishu.cn/file/boxcnIjrYQpF7pL6nWGtTl5W8Jd</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/19/TypeScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JavaScript ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/18/JavaScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/18/JavaScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 18 Jan 2023 14:51:23 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 3 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;课程重点&quot;&gt;&lt;a href=&quot;#课程重点&quot; class=&quot;headerlink&quot; title=&quot;课程重点&quot;&gt;&lt;/a&gt;课程重点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;编码原则</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 3 天</strong></p><h2 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h2><ol><li>编码原则</li><li>组件封装</li><li>过程抽象概念</li><li>高阶函数使用模式</li><li>JavaScript 编程范式</li></ol><h2 id="详细知识点介绍"><a href="#详细知识点介绍" class="headerlink" title="详细知识点介绍"></a>详细知识点介绍</h2><h3 id="编码原则"><a href="#编码原则" class="headerlink" title="编码原则"></a>编码原则</h3><p>各司其职，组件封装，过程抽象</p><p>我们在编码的时候需要注意，尽量让HTML&#x2F;CSS&#x2F;JS各司其职，避免不必要的由JS直接操作样式。</p><h3 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h3><p>组件是指一个包含模板、功能、样式的单元，好的组件具有封装性、正确性、扩展性、复用性。 </p><h3 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h3><p>过程抽象用来处理细节控制的一些方法。 需要函数式编程的思想。</p><p>函数式编程，简单理解就是无副作用的输入-&gt;处理-&gt;输出。</p><p>为了能够让<code>只执行一次</code>的需求覆盖不同的事件处理，我们可以将这个需求剥离出来，这个过程我们称为<code>过程抽象</code>。</p><h3 id="高阶函数（HOF）介绍"><a href="#高阶函数（HOF）介绍" class="headerlink" title="高阶函数（HOF）介绍"></a>高阶函数（HOF）介绍</h3><ul><li><p>以函数作为参数</p></li><li><p>以函数作为返回值</p></li><li><p>常用于作为函数装饰器</p></li></ul><h3 id="常见的高阶函数"><a href="#常见的高阶函数" class="headerlink" title="常见的高阶函数"></a>常见的高阶函数</h3><h4 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h4><p>用于只需要执行一次的函数</p><pre><code class="js">function once(fn) &#123;    return function(...args) &#123;        if(fn) &#123;            const ret = fn.apply(this, args);            fn = null;            return ret;        &#125;    &#125;&#125;</code></pre><p>使用方法：</p><pre><code class="js">const print = (content) =&gt; &#123;    console.log(content)&#125;const printOnce = once(print)printOnce(&quot;1&quot;) // 输出 1printOnce(&quot;2&quot;) // 不输出</code></pre><p>常用于只需要执行一次的的事件侦听器（也可以使用事件侦听器自带的once option，或者手动在执行后移除侦听器）</p><h4 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a>节流（Throttle）</h4><p>如果快速调用函数，那么只有第一次能成功调用函数，之后时间间隔之内的调用会被忽略。常用于滚动条事件&#x2F;瀑布流无限滚动的场景（限制函数调用频率，保证一段时间内函数只调用一次）</p><pre><code class="js">function throttle(fn, time = 500) &#123;    let timer = null;    return function (...args) &#123;        if (timer) return;        fn.apply(this, args);        timer = setTimeout(() =&gt; &#123;            timer = null;        &#125;, time);    &#125;&#125;</code></pre><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>当在时间间隔之内快速调用函数时，函数将始终没法执行，直到停止后，函数才会被执行。常用于一些文本输入的场景（比如搜索框停止输入后，展示联想词；文章编辑器中，输入停止后，进行草稿的保存）。</p><pre><code class="js">function debounce(fn, time = 500) &#123;    let timer = null;    return function (...args) &#123;        if (timer) clearTimeout(timer);        timer = setTimeout(() =&gt; &#123;            fn.apply(this, args);        &#125;, time);    &#125;&#125;</code></pre><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>从名字也很好理解，当快速点击时，函数并不会立刻被调用，而是先将任务推入列表，然后在一定时间后一个一个消费掉。</p><pre><code class="js">function consumer(fn, time = 500) &#123;    let tasks = [];    let timer = null;    return function (...args) &#123;        tasks.push(args);        if (timer) return;        timer = setInterval(() =&gt; &#123;            fn.apply(this, tasks.shift());            if (tasks.length === 0) &#123;                clearInterval(timer);                timer = null;            &#125;        &#125;, time)    &#125;&#125;</code></pre><h4 id="Lterative-可迭代函数"><a href="#Lterative-可迭代函数" class="headerlink" title="Lterative 可迭代函数"></a>Lterative 可迭代函数</h4><h3 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h3><p>命令式与声明式。</p><p>命令式趋向于怎么做。声明式趋向于做什么。</p><p>JS是既有命令式又有声明式。</p><h4 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h4><pre><code class="js">let list =[1,2,3]let map = []for(let i =0;i&lt;list.length;i++)&#123;    map.push(list[i]*2);&#125;</code></pre><h4 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h4><pre><code class="js">let list = [1,2,3,4];const double = x =&gt; x*2;list.map(double);</code></pre><h2 id="实践练习例子"><a href="#实践练习例子" class="headerlink" title="实践练习例子"></a>实践练习例子</h2><p>实现一个只能执行一次的函数：</p><pre><code class="js">// 只执行一次函数const once = (fn) =&gt; &#123;  let done = false;  return function (...args) &#123;    if (!done) &#123;      done = true;      return fn.apply(this, args);    &#125;  &#125;&#125;// 测试const sayHello = (name) =&gt; &#123;  console.log(`Hello $&#123;name&#125;`);&#125;;const sayHelloOnce = once(sayHello);sayHelloOnce(&#39;xiaoming&#39;); // Hello xiaomingsayHelloOnce(&#39;xiaohong&#39;); // undefined</code></pre><h2 id="课后个人总结"><a href="#课后个人总结" class="headerlink" title="课后个人总结"></a>课后个人总结</h2><p>​本次课程让我学到了很多有关编程原则、组件封装、过程抽象概念、高阶函数使用模式以及JavaScript编程范式的知识，收获很大。 </p><p>​对于高阶函数，过去只是略有了解，现在能够真正去理解它们是什么，以及它们的用处如何。</p><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><p><a href="https://bytedance.feishu.cn/file/boxcnxKucsHPvnJ7PfXyCQF5WCd">https://bytedance.feishu.cn/file/boxcnxKucsHPvnJ7PfXyCQF5WCd</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/18/JavaScript%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入CSS ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/17/%E6%B7%B1%E5%85%A5CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/17/%E6%B7%B1%E5%85%A5CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 17 Jan 2023 14:39:40 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 2 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;课程重点&quot;&gt;&lt;a href=&quot;#课程重点&quot; class=&quot;headerlink&quot; title=&quot;课程重点&quot;&gt;&lt;/a&gt;课程重点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;选择器的</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 2 天</strong></p><h2 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h2><ol><li>选择器的特异度</li><li>属性的继承</li><li>Layout 方式</li><li>盒子模型</li><li>块级元素和行级元素</li><li>flex</li><li>grid</li><li>float</li><li>position</li></ol><h2 id="详细知识点介绍："><a href="#详细知识点介绍：" class="headerlink" title="详细知识点介绍："></a>详细知识点介绍：</h2><h3 id="1-选择器的特异度（Specificity）"><a href="#1-选择器的特异度（Specificity）" class="headerlink" title="1. 选择器的特异度（Specificity）"></a>1. 选择器的特异度（Specificity）</h3><p>即 CSS 选择器的<strong>优先级</strong>，当一个元素能够匹配多个样式时，浏览器会根据优先级为元素赋予正确的样式。</p><p>一般情况下，ID选择器优先级最高，其次是类选择器&#x2F;属性选择器&#x2F;伪类，优先级最低的是类型选择器和伪元素选择器。不同选择器的叠加也会改变优先级。<code>!important</code> 的样式会覆盖其他样式。</p><p>在 <code>VSCode</code> 中，鼠标悬浮在选择器上是，能实时看到选择器的优先级数值</p><p>id选择器 大于 类选择器 大于 标签选择器</p><h3 id="2-CSS-属性的继承"><a href="#2-CSS-属性的继承" class="headerlink" title="2. CSS 属性的继承"></a>2. CSS 属性的继承</h3><p>某些属性会自动继承其父元素的计算值除非显式指定一个值</p><p>不同的 CSS 属性有着不同的继承规则。对于一个能够被继承的样式属性，子元素能够从父元素继承相同的属性值，而不需要额外的设置。当然，对于一个默认不继承的样式，也可以通过将其值设置为<code>inherit</code>来强制从父元素继承。</p><p>初始值：CSS 中，每个属性都有一个初始值 <code>background-color</code> 的初始值为 <code>transparent</code><br><code>margin-left</code> 的初始值为 0<br>可以使用 <code>initial</code> 关键字显式重置为初始值<br><code>background-color: initial</code></p><h3 id="3-CSS-布局方式"><a href="#3-CSS-布局方式" class="headerlink" title="3. CSS 布局方式"></a>3. CSS 布局方式</h3><p>CSS 存在许多种布局方式。总体上分为三类：常规流&#x2F;文档流、浮动、绝对定位。其中，在正常的文档流中，又可以细分出很多布局方式，例如行级、块级、表格布局、弹性布局（flex）、网格布局（grid）</p><p>盒子模型：<code>margin</code> <code>border</code> <code>padding</code></p><h3 id="4-CSS-盒子模型"><a href="#4-CSS-盒子模型" class="headerlink" title="4. CSS 盒子模型"></a>4. CSS 盒子模型</h3><p>width: content box 的宽度</p><p>height: content box 的高度</p><p>padding: 元素内边距，百分比相对于<strong>元素宽度</strong></p><p>border: 元素的边框样式、粗细和颜色</p><p>margin: 元素外边距，百分比相对于<strong>元素宽度</strong></p><p>当 box-sizing 取值为 border-box 时，模型会发生相应变化。</p><h3 id="5-块级元素"><a href="#5-块级元素" class="headerlink" title="5. 块级元素"></a>5. 块级元素</h3><p>即 <code>display</code> 属性值为 <code>block</code> 的元素。例如 <code>body</code>、<code>article</code>、<code>div</code>、<code>main</code>、<code>section</code>、<code>p</code>、<code>h1</code>~&#96;h6<code>、</code>ul<code>/</code>ol<code>、</code>li&#96; 等</p><h3 id="行级元素"><a href="#行级元素" class="headerlink" title="行级元素"></a>行级元素</h3><p>即 <code>display</code> 属性值为 <code>inline</code> 的元素。</p><h3 id="6-flex"><a href="#6-flex" class="headerlink" title="6. flex"></a>6. flex</h3><p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>2009年，W3C提出了一种新的方案—Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性.</p><pre><code class="css">.box&#123;  display: flex;&#125;</code></pre><p>任何一个容器都可以指定为Flex布局。</p><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><pre><code class="css">.box &#123;  flex-direction: row | row-reverse | column | column-reverse;&#125;</code></pre><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><h3 id="7-grid"><a href="#7-grid" class="headerlink" title="7. grid"></a>7. grid</h3><p>网格是一组相交的水平线和垂直线，它定义了网格的列和行。</p><p>CSS 提供了一个基于网格的布局系统，带有行和列，可以让我们更轻松地设计网页，而无需使用浮动和定位。</p><p>当一个 HTML 元素将 display 属性设置为 grid 或 inline-grid 后，它就变成了一个网格容器，这个元素的所有直系子元素将成为网格元素。</p><pre><code class="css">grid: none;grid: &quot;a&quot; 100px &quot;b&quot; 1fr;grid: [linename1] &quot;a&quot; 100px [linename2];grid: &quot;a&quot; 200px &quot;b&quot; min-content;grid: &quot;a&quot; minmax(100px, max-content) &quot;b&quot; 20%;grid: 100px / 200px;grid: minmax(400px, min-content) / repeat(auto-fill, 50px);grid: 200px / auto-flow;grid: 30% / auto-flow dense;grid: repeat(3, [line1 line2 line3] 200px) / auto-flow 300px;grid: [line1] minmax(20em, max-content) / auto-flow dense 40%;grid: auto-flow / 200px;grid: auto-flow dense / 30%;grid: auto-flow 300px / repeat(3, [line1 line2 line3] 200px);grid: auto-flow dense 40% / [line1] minmax(20em, max-content);grid: inherit;grid: initial;grid: unset;</code></pre><p>我们通过 <strong>grid-template-columns</strong> 和 <strong>grid-template-rows</strong> 属性来定义网格中的行和列。</p><p>这些属性定义了网格的轨道，一个网格轨道就是网格中任意两条线之间的空间。</p><p>在下图中你可以看到一个绿色框的轨道——网格的第一个行轨道。第二行有三个白色框轨道。</p><p>轨道可以使用任何长度单位进行定义。</p><p>网格引入了 <strong>fr</strong> 单位来帮助我们创建灵活的网格轨道。一个 fr 单位代表网格容器中可用空间的一等份。</p><p>以下实例定义了一个网格定义将创建三个相等宽度的轨道，这些轨道会随着可用空间增长和收缩。</p><p>一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。现在再看回我们前面的一个例子, 一旦一个网格元素被定义在一个父级元素当中，那么他的子级元素将会排列在每个事先定义好的网格单元中。</p><p>列与列，行与行之间的交接处就是网格线。</p><p>Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素。</p><pre><code class="css">#container &#123;  display: grid;  grid: repeat(2, 60px) / auto-flow 80px;&#125;#container &gt; div &#123;  background-color: #8ca0ff;  width: 50px;  height: 50px;&#125;</code></pre><p>网格线的编号顺序取决于文章的书写模式。在从左至右书写的语言中，编号为 1 的网格线位于最左边。在从右至左书写的语言中，编号为 1 的网格线位于最右边。</p><p>接下来我使用了 grid-column-start, grid-column-end, grid-row-start 和 grid-row-end 属性来演示如何使用网格线。</p><p>以下实例我们设置一个网格元素的网格线从第一列开始，第三列结束：</p><pre><code class="css">.item1 &#123;  grid-column-start: 1;  grid-column-end: 3;&#125;</code></pre><p><a href="https://www.runoob.com/try/gridgarden/index.html">https://www.runoob.com/try/gridgarden/index.html</a></p><p>菜鸟教程的grid布局小游戏</p><h2 id="实践练习例子："><a href="#实践练习例子：" class="headerlink" title="实践练习例子："></a>实践练习例子：</h2><h3 id="特异度相关例子"><a href="#特异度相关例子" class="headerlink" title="特异度相关例子"></a>特异度相关例子</h3><p>下面的文字是什么颜色？</p><pre><code class="html">&lt;div class=&quot;wrapper1&quot;&gt;  &lt;div class=&quot;text1&quot;&gt;文本1&lt;/div&gt;&lt;/div&gt;&lt;style&gt;  .wrapper1 .text1 &#123;    color: red;  &#125;    .text1 &#123;    color: black;  &#125;&lt;/style&gt;</code></pre><p>正确答案是红色</p><p>虽然黑色的属性声明在后面，理应覆盖掉前面的红色，但是前面是两个类选择器的叠加，优先级是 <code>0, 2, 0</code> ，后者只有一个类选择器，优先级是 <code>0, 1, 0</code>，所以最终浏览器应用了红色。</p><h2 id="课后个人总结："><a href="#课后个人总结：" class="headerlink" title="课后个人总结："></a>课后个人总结：</h2><p>本节课中，我学习了CSS中特异度、属性继承、布局方式、盒子模型、块级元素和行级元素、flex、grid等概念，掌握了相关的知识和应用。 特异度是CSS中最重要的概念之一，让我们明白当一个元素能够匹配多个样式时，浏览器会根据优先级为元素赋予正确的样式。</p><p>属性的继承也是重要的概念，它会依赖于不同的CSS属性，有了它，我们可以让HTML元素的样式可以从父元素继承。</p><p>我们还学习了CSS中的布局方式，包括常规流&#x2F;文档流、浮动、绝对定位等，以及flex、grid等网格布局。</p><p>熟练掌握这些知识，我们可以更好的制作网页，满足各种布局的需求。</p><h2 id="引用参考："><a href="#引用参考：" class="headerlink" title="引用参考："></a>引用参考：</h2><p>课程ppt</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid">https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</a></p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/17/%E6%B7%B1%E5%85%A5CSS%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>前端与 HTML ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/16/%E5%89%8D%E7%AB%AF%E4%B8%8E%20HTML%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/16/%E5%89%8D%E7%AB%AF%E4%B8%8E%20HTML%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 16 Jan 2023 04:18:33 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;这是我参与「第五届青训营」伴学笔记创作活动的第 1 天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;本堂课重点内容：&quot;&gt;&lt;a href=&quot;#本堂课重点内容：&quot; class=&quot;headerlink&quot; title=&quot;本堂课重点内容：&quot;&gt;&lt;/a&gt;本堂课重点内容：&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>这是我参与「第五届青训营」伴学笔记创作活动的第 1 天</strong></p><h2 id="本堂课重点内容："><a href="#本堂课重点内容：" class="headerlink" title="本堂课重点内容："></a>本堂课重点内容：</h2><ol><li>前端的介绍</li><li>HTML 标签的简单介绍</li><li>HTML 语义化</li></ol><h2 id="详细知识点介绍："><a href="#详细知识点介绍：" class="headerlink" title="详细知识点介绍："></a>详细知识点介绍：</h2><ol><li>前端技术栈</li><li>前端的边界、开发环境（ide、浏览器）</li><li>DOM 树的简单介绍</li><li>HTML 语法简单介绍</li><li>各类常用标签（h1-h5、p、form、a）</li><li>常见的语义化标签（main&#x2F;footer&#x2F;section）</li><li>语义化的优势</li></ol><h2 id="实践练习例子："><a href="#实践练习例子：" class="headerlink" title="实践练习例子："></a>实践练习例子：</h2><h3 id="1-标题元素"><a href="#1-标题元素" class="headerlink" title="1. 标题元素"></a>1. 标题元素</h3><p>使用 <code>h1</code>~&#96;h6&#96; 标签将标题文本包裹，标题会根据级别拥有默认的字重、字号和外边距。</p><pre><code class="html">&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt;</code></pre><h3 id="2-图片元素"><a href="#2-图片元素" class="headerlink" title="2. 图片元素"></a>2. 图片元素</h3><p>使用 <code>src</code> 属性来确定图片链接，<code>alt</code> 属性用于表示图片无法显示时的替代文本</p><pre><code class="html">&lt;img src=&quot;https://example.com/image&quot; /&gt;&lt;img src=&quot;https://example.com&quot; alt=&quot;显示不出来的图片&quot; /&gt;</code></pre><h3 id="3-单选框"><a href="#3-单选框" class="headerlink" title="3. 单选框"></a>3. 单选框</h3><p><code>radio</code> 类型的 <code>input</code> 元素，相同 <code>name</code> 的单选框会归为同一组（只能选其中一个） 使用 <code>label</code> 标签来标识单选框的内容</p><pre><code class="html">&lt;input type=&quot;radio&quot; id=&quot;el1&quot; name=&quot;group1&quot; /&gt;&lt;label for=&quot;el1&quot;&gt;第一组-选项1&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;el2&quot; name=&quot;group1&quot; /&gt;&lt;label for=&quot;el2&quot;&gt;第一组-选项1&lt;/label&gt;&lt;br&gt;&lt;input type=&quot;radio&quot; id=&quot;el3&quot; name=&quot;group2&quot; /&gt;&lt;label for=&quot;el3&quot;&gt;第二组-选项1&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;el4&quot; name=&quot;group2&quot; /&gt;&lt;label for=&quot;el4&quot;&gt;第二组-选项2&lt;/label&gt;</code></pre><h3 id="4-超链接"><a href="#4-超链接" class="headerlink" title="4. 超链接"></a>4. 超链接</h3><p>使用 <code>a</code> 标签包裹文本，<code>href</code> 属性是目标链接，默认在当前页面打开，为了在新标签页打开，可以将 <code>target</code> 属性设置为 <code>_blank</code></p><pre><code class="html">&lt;a href=&quot;https://example.com&quot;&gt;在当前页面打开&lt;/a&gt;&lt;a href=&quot;https://example.com&quot; target=&quot;_blank&quot;&gt;在新页面打开&lt;/a&gt;</code></pre><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>最外层使用 <code>ol</code>标签包裹，内部包含多个 <code>li</code> 标签</p><pre><code class="html">&lt;ol&gt;    &lt;li&gt;第一&lt;/li&gt;    &lt;li&gt;第二&lt;/li&gt;    &lt;li&gt;&lt;em&gt;第三&lt;/em&gt;&lt;/li&gt;&lt;/ol&gt;</code></pre><h3 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6. 无序列表"></a>6. 无序列表</h3><p>最外层使用 <code>ul</code>标签包裹，内部包含多个 <code>li</code>标签</p><pre><code class="html">&lt;ul&gt;    &lt;li&gt;第一&lt;/li&gt;    &lt;li&gt;第二&lt;/li&gt;    &lt;li&gt;&lt;em&gt;第三&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="课后个人总结："><a href="#课后个人总结：" class="headerlink" title="课后个人总结："></a>课后个人总结：</h3><p>本节课主要介绍了前端的技术栈，以及 HTML 标签的简单介绍和 HTML 语义化，通过本节课的学习，我对 HTML 标签有了一定的了解，掌握了如何使用标签来表达页面元素，并且学习了如何使用语义化标签来提高前端代码的可读性，以及提升代码的可维护性。</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/16/%E5%89%8D%E7%AB%AF%E4%B8%8E%20HTML%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HTTP3初体验 ｜ 青训营笔记</title>
      <link>https://xyxsw.ltd/2023/01/11/HTTP3%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</link>
      <guid>https://xyxsw.ltd/2023/01/11/HTTP3%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 11 Jan 2023 13:57:32 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;HTTP-x2F-3试水&quot;&gt;&lt;a href=&quot;#HTTP-x2F-3试水&quot; class=&quot;headerlink&quot; title=&quot;HTTP&amp;#x2F;3试水&quot;&gt;&lt;/a&gt;HTTP&amp;#x2F;3试水&lt;/h2&gt;&lt;h3 id=&quot;I&quot;&gt;&lt;a href=&quot;#I&quot; class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="HTTP-x2F-3试水"><a href="#HTTP-x2F-3试水" class="headerlink" title="HTTP&#x2F;3试水"></a>HTTP&#x2F;3试水</h2><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>小看一眼，发现全是编译啥的。应该会踩很多坑的，这次用国外没东西的小1h512M服务器试水一下。<br>目前cloudflare给出了一键开启http3。很好用，我在netlify托管的网页一键开开了。<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230111221046.png" alt="1"><br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230111221121.png" alt="2"></p><h3 id="II"><a href="#II" class="headerlink" title="II"></a>II</h3><p>现在要编译安装一个nginx，用的是<a href="https://github.com/cloudflare/quiche">https://github.com/cloudflare/quiche</a>方案。<br><a href="https://github.com/cloudflare/quiche/tree/master/nginx">https://github.com/cloudflare/quiche/tree/master/nginx</a>处理nginx的教程在这里，一步步跟上</p><pre><code class="bash">  curl -O https://nginx.org/download/nginx-1.16.1.tar.gz  tar xzvf nginx-1.16.1.tar.gz  git clone --recursive https://github.com/cloudflare/quiche  cd nginx-1.16.1  patch -p01 &lt; ../quiche/nginx/nginx-1.16.patch</code></pre><p>在之前要apt upgrade一下避免有装不上的东西<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230111221522.png" alt="3"><br>外网服务器下的就是快😎<br>要编译了发现cmake没有  装个cmake先<br><code>apt install cmake</code></p><p>gcc g++也没有 装个</p><p>接下来</p><pre><code class="bash">  ./configure                                 \       --prefix=$PWD                           \       --build=&quot;quiche-$(git --git-dir=../quiche/.git rev-parse --short HEAD)&quot; \       --with-http_ssl_module                  \       --with-http_v2_module                   \       --with-http_v3_module                   \       --with-openssl=../quiche/quiche/deps/boringssl \       --with-quiche=../quiche  make</code></pre><p>nginx configure 时候报错，<br><code>the HTTP rewrite module requires the PCRE library.</code><br>搜了 装这个 <code>apt install libpcre3 libpcre3-dev</code></p><p><code>the HTTP gzip module requires the zlib library</code><br>搜了 装这个 <code>apt install zlib1g-dev</code></p><p>又error 没有cargo 装个<br><code>apt install cargo</code></p><p>make好了</p><pre><code class="bash">nginx -V</code></pre><p>装是装好了 好像要一个https证书啊<br>acme签一个<br><code>https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E</code></p><pre><code class="conf">events &#123;    worker_connections  1024;&#125;http &#123;    server &#123;        # Enable QUIC and HTTP/3.        listen 443 quic reuseport;        # Enable HTTP/2 (optional).        listen 443 ssl http2;        ssl_certificate      cert.crt;        ssl_certificate_key  cert.key;        # Enable all TLS versions (TLSv1.3 is required for QUIC).        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;        # Add Alt-Svc header to negotiate HTTP/3.        add_header alt-svc &#39;h3=&quot;:443&quot;; ma=86400&#39;;    &#125;&#125;</code></pre><p>签证书签了半天 签好了 放在</p><pre><code class="bash">        ssl_certificate      cert.crt;        ssl_certificate_key  cert.key;</code></pre><p>里面<br>配置好nginx 注意网站不要在root下<br>在root下nginx访问不到直接403了<br>建一个<code>/www/wwwroot/domin</code>文件夹放东西</p><h3 id="III"><a href="#III" class="headerlink" title="III"></a>III</h3><p>最后配置结果是这样滴</p><h4 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h4><p><a href="https://geekflare.com/tools/test/yn22t29e04y7v0u5jl61mcark2dwxmbn">https://geekflare.com/tools/test/yn22t29e04y7v0u5jl61mcark2dwxmbn</a><br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230112004019.png" alt="6"><br>这个网站会检测什么h3-xxx的版本协议 （看不懂，看懂了在写一篇<br>你没有这个版本号的协议这个网站就检测不出来好像 在这里改就行<br><code>add_header alt-svc &#39;h3=&quot;:443&quot;; ma=86400&#39;;</code><br>我加了版本号114514🤓<br><code>add_header alt-svc h3=&quot;:443&quot;; ma=86400; h3-114514=&quot;:443&quot;; ma=86400</code><br>上面这个好像就检测这个alt-svc这个头</p><h4 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h4><p><a href="https://http3check.net/?host=http3.typescriptactions.xyz">https://http3check.net/?host=http3.typescriptactions.xyz</a><br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230112004253.png" alt="7"><br>这个就很正常了 不加版本直接检测h3的</p><h4 id="第三个"><a href="#第三个" class="headerlink" title="第三个"></a>第三个</h4><p>然后是wappalyzer插件<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230112004611.png" alt="8"></p><h4 id="第四个"><a href="#第四个" class="headerlink" title="第四个"></a>第四个</h4><p>然后是浏览器devtools的协议检查<br><img src="https://picxyxsw.oss-cn-hangzhou.aliyuncs.com/20230112004854.png" alt="9"></p><h3 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h3><p>总结一下<br>2023-1-11 21:57:32 开始的<br>2023-1-12 00:53:12 写完这篇<br>🤥感觉没啥可总结的 国外服务器也测不了http3优势啥的<br>下班！睡觉！😝</p>]]></content:encoded>
      
      
      
      <category domain="https://xyxsw.ltd/tags/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/">青训营笔记</category>
      
      
      <comments>https://xyxsw.ltd/2023/01/11/HTTP3%E5%88%9D%E4%BD%93%E9%AA%8C%20%EF%BD%9C%20%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
